<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>T20200603赛后总结</title>
    <url>/DeNeRATe.github.io/2020/06/24/T20200603%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="T20200603赛后总结"><a href="#T20200603赛后总结" class="headerlink" title="T20200603赛后总结"></a>T20200603赛后总结</h1><h2 id="成绩排行：T20200603成绩"><a href="#成绩排行：T20200603成绩" class="headerlink" title="成绩排行：T20200603成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200603/result20200603.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200603/result20200603.html">T20200603成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>emm。。。这套题我只想吐槽一下T1。</p>
<p>为啥$ nh $的假贪心可以直接过？？？<del>我吐了</del></p>
<p>我和LMK写的$ nlogh $的真线段树贪心它不香吗。。。</p>
<p>就是排序写挂了。。。100=&gt;0 wonderful！！！</p>
<p>然后就是T3，没懂+INF。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P1250" target="_blank" rel="noopener">P1250 种树</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心</strong></p>
<p>但是我觉得需要<strong>线段树+贪心</strong>比较好。。。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/5LEIkVxpAKNW1Sr.png" alt="T20200603 trees.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一看，啥都不用说，丫的就是一个贪心，每次选出被覆盖次数最多的那个区域种上树，不久OU了吗。</p>
<p>那么现在要做的就是如何每次选出被覆盖次数最多的区域了。</p>
<p>对于这些区间，需要想到的就是区间排序在操作，所以此时就有两种操作了，１.左对齐排序　２.右对齐排序。经过我亲身排序错误的爆零尝试，才知道我脑抽了。。。右对齐它多香啊。。。</p>
<p>所以之后就每次枚举当前区间，将最右边的全部覆盖掉。</p>
<p>时间复杂度：$ O(nh) $或$ O(nlogh) $</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trees</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line">LL Total,House;</span><br><span class="line">LL Tree[MAXn&lt;&lt;<span class="number">2</span>],Tag[MAXn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    LL B,E,T;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;Temp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(E==Temp.E) <span class="keyword">return</span> B&lt;Temp.B;</span><br><span class="line">        <span class="keyword">return</span> E&lt;Temp.E;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(LL X)</span></span>&#123; Tree[X]=Tree[Lson]+Tree[Rson]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UP</span><span class="params">(LL L, LL R, LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[X]=(R-L+<span class="number">1</span>);</span><br><span class="line">    Tag[X]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(LL L,LL R,LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">    LL Mid=(L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    UP(L,Mid,Lson);</span><br><span class="line">    UP(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">    Tag[X]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) </span><br><span class="line">    &#123;</span><br><span class="line">        Tree[X]=R-L+<span class="number">1</span>;</span><br><span class="line">        Tag[X]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) UpDate(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) UpDate(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) <span class="keyword">return</span> Tree[X];</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) Ans+=Query(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) Ans+=Query(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL TL,LL TR,LL T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL L=TL,R=TR,Ans=TL;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">        LL Mid=(L+R)&gt;&gt;<span class="number">1</span>, S=((Mid<span class="number">-1</span>)&lt;TL ? <span class="number">0</span> : Query(<span class="number">1</span>,Total,TL,Mid<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (S+TR-Mid+<span class="number">1</span>&gt;=T) Ans=Mid,L=Mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=Mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL L,LL R,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Tree[X]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Print(L,Mid,Lson); Print(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trees.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"trees.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;Total,&amp;House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>,&amp;Num[i].B,&amp;Num[i].E,&amp;Num[i].T);    </span><br><span class="line">    sort(Num,Num+House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) &#123;</span><br><span class="line">        LL Res=Query(<span class="number">1</span>,Total,Num[i].B,Num[i].E);</span><br><span class="line">        <span class="keyword">if</span>(Res&gt;=Num[i].T) <span class="keyword">continue</span>;</span><br><span class="line">        LL Place=Get(Num[i].B,Num[i].E,Num[i].T);</span><br><span class="line">        UpDate(<span class="number">1</span>,Total,Place,Num[i].E);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Tree[<span class="number">1</span>]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>倍增</strong></p>
<p>或<strong>树状数组</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/yiSBUuOHe4xgCW2.png" alt="T20200603 at.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于本题考试的时候没有一个不是AC的，所以也就没什么必要分析了</p>
<p>我还是来一波solution的分析吧</p>
<blockquote>
<p>题目实际上是求每个结点深度差不超过K的儿子个数。</p>
<pre><code>由于涉及到方面有：深度、子树求和，大概思路可以想到是先预处理，然后按深度从大到小增删点，再查询某子树有多少个点。

增删点的过程可以通过给点设权值来实现，1表示这个点存在，0表示不存在。那么查询某子树有多少个点就相当于是对某个子树中点的权值进行求和。

与子树相关可用dfs序，修改和求和可以用树状数组实现。
</code></pre></blockquote>
<p>所以，就这么OU了，真香。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//at</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,K,u,v,Cur;</span><br><span class="line">LL Sum[MAXn],Val[MAXn],Temp[MAXn],Anc[MAXn][<span class="number">20</span>];</span><br><span class="line">LL Head[MAXn],Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">DFS</span><span class="params">(LL X, LL Fa)</span> </span>&#123;</span><br><span class="line">    Anc[X][<span class="number">0</span>]=Fa; Temp[Fa]++;</span><br><span class="line">    FOR(i,<span class="number">1</span>,<span class="number">19</span>) Anc[X][i]=Anc[Anc[X][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    LL TO=X,TK=K;</span><br><span class="line">    <span class="keyword">for</span> (LL i=<span class="number">0</span>;TK;++i)</span><br><span class="line">        <span class="keyword">if</span> (TK &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            TK ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            TO=Anc[TO][i];</span><br><span class="line">        &#125;</span><br><span class="line">    Temp[Anc[TO][<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">for</span> (LL i=Head[X];i;i=Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(End[i]==Fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(End[i],X);</span><br><span class="line">        Temp[X]+=Temp[End[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(LL From,LL To)</span> </span>&#123;</span><br><span class="line">    Next[++Cur]=Head[From];</span><br><span class="line">    Head[From]=Cur;</span><br><span class="line">    End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"at.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"at.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;N,&amp;K);</span><br><span class="line">	FOR(i,<span class="number">1</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        AddEdge(u,v); AddEdge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,N) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,Temp[i]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>构造+组合数学</strong></p>
<p>或<strong>矩阵快速幂+动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FEVoNZiWK3J1r7s.png" alt="T20200603 poker.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>其实我不怎么想分析，因为</p>
<p>1.这明明叫高二学堂，他跟题面有啥关系啊？！</p>
<p>2.这题解写的是嘛呀，看不懂（高二巨佬也没搞懂，只看懂了80分）</p>
<p>综上所述，我就直接上solution了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>输出$n$，不解释。。。</p>
<p>期望得分：10</p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>利用上式对$Ai$和$Xi$进行搜索，同样不解释。。。</p>
<p>期望得分：20</p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>把牌按数值大小编号，数值相同的编上4个不同号码。</p>
<p>用$ f[i][j][k] $表示现在处理完前i张牌，一共用了$j$张，构成和为$k$的方案数。转移只要使用类似背包的方法即可。</p>
<p>方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f’[i][j][k]=f[i][j][k]+Σf[i<span class="number">-1</span>][j<span class="number">-1</span>][k-w(i)]。</span><br></pre></td></tr></table></figure>
<p>其中$ w(i) $为$i$的牌面。</p>
<p>为免MLE，可把第一维省去。</p>
<p>期望得分：40</p>
<h4 id="【算法四】"><a href="#【算法四】" class="headerlink" title="【算法四】"></a>【算法四】</h4><p>这是Symbol提出来的方法。</p>
<p>如果现在所有的牌面都大于1，假设有$k$’张，那么把所有牌面都减小1，总和减少$k’$之后，问题显然是等价的；而如果有牌面等于1，那么只要把这几张牌去掉，剩下的牌面就又都是大于1的了。</p>
<p>所以可以使用$ f[i][j] $表示用j张牌构成和为$i$的方案数，转移的时候分情况：</p>
<p>1）所有牌面大于1，则$ f[i][j]+=f[i-j][j] $；</p>
<p>2）有牌面等于1，那么我们可以枚举这些牌的数量$ t（\leq 4） $，则$ f[i][j]+=f[i-j][j-t] $。</p>
<p>最后答案就是$ f[n][1 \rightarrow k] $的最小值。</p>
<p>时间复杂度为$ O(nk) $</p>
<p>期望得分：60</p>
<h4 id="【算法五】"><a href="#【算法五】" class="headerlink" title="【算法五】"></a>【算法五】</h4><p>对算法4进行优化，考虑到$k$比较小，而转移只需要用到前$k$层的值。</p>
<p>我们可以把连续$k$层的f压在一个矩阵内，并按一维编号，最多不超过$k^2$个。然后我们每次转移1层的$f$，也就是如果现在矩阵记录的是$f[1 \rightarrow k][]$的值，那么转移一次，矩阵记录的就变成了$f[2 \rightarrow k+1][]$的值。然后填矩阵就是了。</p>
<p>时间复杂度为$ O(logn \times k^6) $，多组数据下，这个方法会由于常数大被卡掉。</p>
<p>期望得分：80</p>
<h4 id="【算法六】"><a href="#【算法六】" class="headerlink" title="【算法六】"></a>【算法六】</h4><p>首先，假设牌面的集合为$ {xi} $，集合中的每个元素对应一个$ ai（\leq 4）$，表示这个牌面用了多少张。那么问题就转化成了求$ Σai \times xi=n $的正整数解个数，其中$ x1&lt;x2&lt;…&lt;xm，Σai≤k $。由于ai和k都比较小，我们可以暴力枚举所有情况，再去解方程。而现在约束还是比较多的，我们得想办法除去约束。</p>
<p>设$ yi=xi-x_{i-1} $，换元后方程变为$ Σbi \times yi=n $的形式，其中$ bi \leq k $。至此，我们成功把未知数单调这个棘手的约束解决了。</p>
<p>接下来，我们发现$bi$比较小$(≤10)$，那么可以把$bi$的lcm算出来，最多为<strong>2520</strong>。然后把$bi \times yi$表示成$ pi \times lcm+qi $的形式，其中$qi$必须能被$bi$整除。</p>
<p>现在方程转化为</p>
<script type="math/tex; mode=display">
lcm \times Σpi+Σqi=n。</script><p>考虑到$ Σqi $还是比较小的$(≤3W)$，可以枚举$ Σqi $的每个可能值，那么$pi$的方案数就可以用经典的隔板法来计算。而对于$ Σqi $的计算，我们可以用背包来实现。背包的时候要注意各种细节，而且注意复杂度的把握。</p>
<p>期望得分：100</p>
<p>（由于这道题我是实在不知道题解和代码的意思，所以就只能用std的代码了。。。我太CHAI了 害~~~）</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poker Hewr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fo(i,a,b) for (int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,a,b) for (int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn=<span class="number">11</span>,mm=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> a[mn],d[mn],Rev[mn],f[mm],F[mm];</span><br><span class="line"><span class="keyword">int</span> n,k,m,L,Ans,NowS,N,A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> (c=(a%b)) a=b,b=c;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=Rev[b];</span><br><span class="line">	fo (i,a-b+<span class="number">1</span>,a) ret=(LL)ret*i%mo;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=(LL)ret*a%mo;</span><br><span class="line">		a=(LL)a*a%mo,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS) F[i]=f[i];</span><br><span class="line">	<span class="keyword">int</span> l=L/x*x;</span><br><span class="line">	fo (i,NowS+<span class="number">1</span>,<span class="built_in">min</span>(n,NowS+l)) F[i]=<span class="number">0</span>;</span><br><span class="line">	NowS=<span class="built_in">min</span>(n,NowS+l);</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS)&#123;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=x)&#123;</span><br><span class="line">			F[i]=(F[i]+(f[i]=F[i-x]))%mo;</span><br><span class="line">			<span class="keyword">if</span> (i&gt;=l+x) f[i]=(f[i]-F[i-l-x]+mo)%mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	d[m]=a[m];</span><br><span class="line">	fd (i,m<span class="number">-1</span>,<span class="number">1</span>) d[i]=d[i+<span class="number">1</span>]+a[i];</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,NowS=<span class="number">0</span>,L=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,m) L=L*d[i]/gcd(L,d[i]);</span><br><span class="line">	fo (i,<span class="number">1</span>,m) dp(d[i]);</span><br><span class="line">	fo (nn,m,NowS) <span class="keyword">if</span> (!((N=n-nn)%L) &amp;&amp; (A=f[nn]))&#123;</span><br><span class="line">		B=C(N/L+m<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">		Ans=((LL)A*B+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> M,<span class="keyword">int</span> K,<span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (M&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		m=M<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp=work();</span><br><span class="line">		Ans=((LL)tmp*W+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!K) <span class="keyword">return</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> (i&lt;=K)&#123;</span><br><span class="line">		a[M]=i;</span><br><span class="line">		dfs(M+<span class="number">1</span>,K-i,(LL)W*C(<span class="number">4</span>,i)%mo);</span><br><span class="line">		a[M]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Rev[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,mn<span class="number">-1</span>) Rev[i]=(LL)Rev[i<span class="number">-1</span>]*Pow(i,mo<span class="number">-2</span>)%mo;</span><br><span class="line">	freopen(<span class="string">"poker.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"poker.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n+k)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,k,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200529赛后总结</title>
    <url>/DeNeRATe.github.io/2020/06/24/T20200529%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="T20200529赛后总结"><a href="#T20200529赛后总结" class="headerlink" title="T20200529赛后总结"></a>T20200529赛后总结</h1><h2 id="成绩排行：T20200529成绩"><a href="#成绩排行：T20200529成绩" class="headerlink" title="成绩排行：T20200529成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200529/result20200529.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200529/result20200529.html">T20200529成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是集训的第一套题。。。可谓是<strong>开门黑</strong>。</p>
<p>在此膜拜 stO 欧巨 Orz。</p>
<p>总的来说，这一套题除了第二题外没有什么难搞的，好吧，T3的代码量有点大。。。</p>
<p>本以为T1瞬秒之后准备AK了。。。结果T3我成功反驳了我的正确思路QwQ</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FyraMX3N4cH6GgY.png" alt="T20200529 words.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>定睛手膜一下样例可以知道，若我分析到$tr$了，下一个是$e$，如果直接算下一个$tre$个数量的话，会有一部分重复，而这部分的重复个数刚好就是$tr$之后的这个字母在$heap$里边的出现次数，因此，在手摸几个样例发现，这个思路确实是毫无破绽，那么正解不就出来了吗。。。</p>
<p>温馨提示：我就是因为没有判首尾是否需要算入答案的情况，使得我的100=&gt;0wonderful!</p>
<p>时间复杂度：$ O(2n) $</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//words</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[MAXn],B[MAXn];</span><br><span class="line">LL Cnt[<span class="number">30</span>],DP,Ans,Lena,Lenb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"words.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"words.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+<span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">"%s"</span>,B+<span class="number">1</span>);</span><br><span class="line">	Lena=<span class="built_in">strlen</span>(A+<span class="number">1</span>); Lenb=<span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Lenb<span class="number">-1</span>) Cnt[B[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Lena) &#123;</span><br><span class="line">		DP=Lenb-Cnt[A[i]-<span class="string">'a'</span>+<span class="number">1</span>],Ans+=DP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans+Lenb);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+斜率优化</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/NTXyKD1ALVrlOou.png" alt="T20200529 distance.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当我看到$ n \leq 1,000 $，然后又看到是一个矩阵时，我就知道了这道题100%是一个$ O(n^2) $的时间复杂度。</p>
<p>继而就没什么思路了。</p>
<p>（我发现我口胡这道题好像不太行，那就直接上题解？）</p>
<blockquote>
<p>分别从左上，右上，左下，右下四个方向做一次斜率DP取最优值即可。</p>
</blockquote>
<p>没错，这个就是solution里边写的东西，你看，这是人说的话吗？！</p>
<p>$ \approx $没说。。。所以，最后还是需要我来口胡一哈。。。</p>
<p>相当于就是记录每一行的一个单调队列，因为对于同一行，他们的纵坐标是一定的，那么横坐标又是单调递增的，所以可以直接推出转移式，记录并转移（<del>口胡完毕</del>）</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//distance</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Row,Line,DP[MAXn][MAXn],Dis[MAXn];</span><br><span class="line"><span class="keyword">char</span> Sta[MAXn][MAXn];</span><br><span class="line">LL Cube[MAXn][MAXn],F[MAXn][MAXn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL X,Y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Node <span class="keyword">operator</span> - (Node A,Node B) &#123;</span><br><span class="line">		Node Temp;</span><br><span class="line">		Temp.X=A.X-B.X; </span><br><span class="line">		Temp.Y=A.Y-B.Y;</span><br><span class="line">		<span class="keyword">return</span> Temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;Queue[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.X*B.Y-A.Y*B.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B,Node C)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Cross(B-A,C-A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"distance.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"distance.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Calc</span><span class="params">(Node A,LL Loc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.Y<span class="number">-2</span>*Loc*A.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		LL Head=<span class="number">0</span>,Tail=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Sta[i][j]==<span class="string">'1'</span>) Dis[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> ++Dis[i];</span><br><span class="line">			Node New;</span><br><span class="line">			New.X=j; New.Y=j*j+Dis[j]*Dis[j];</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Cross(Queue[Tail<span class="number">-1</span>],Queue[Tail],New)&lt;=<span class="number">0</span>) Tail--;</span><br><span class="line">			Queue[++Tail]=New;</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Calc(Queue[Head+<span class="number">1</span>],j)&gt;Calc(Queue[Head+<span class="number">2</span>],j)) Head++;</span><br><span class="line">			DP[i][j]=Calc(Queue[Head+<span class="number">1</span>],j)+j*j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>(); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Row,&amp;Line);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,Sta[i]+<span class="number">1</span>);</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) Cube[i][j]=Sta[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = DP[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[i][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j) </span><br><span class="line">			Sta[i][j] = Cube[Row - i + <span class="number">1</span>][j];</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, F[i][j], j == Line ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P6122" target="_blank" rel="noopener">P6122 Mole Tunnels</a></p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>模拟最大流+贪心</strong></p>
<p>但是我觉得（<strong>树链剖分+贪心</strong>）也是可以的</p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/KUHBTmeN9fWcDGY.png" alt="T20200529 tree.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先观察到，这道题的树非常的特殊，是一颗完美二叉树，这就不免是我们想到这道题一定不简单，没错我就是被这种思想禁锢了。。。使得我最后用手摸样例推翻了我自己的思路。。。害~~~</p>
<p><img src="https://i.loli.net/2020/06/24/B4NpU8E1OMaKS2z.png" alt="T20200529 tree 草稿1.png"></p>
<p>可以发现这个时候有两条边被重复走了。那么我们肯定可以找出更优解，即：</p>
<p><img src="https://i.loli.net/2020/06/24/GkIDg3u4ytUbP8R.png" alt="T20200529 tree 草稿2.png"></p>
<p>这个时候，我们发现这两条被来回走过的边，<strong>他们无了！！！</strong>。</p>
<p>脑洞瞬间打开（而我不一样，我不知道为啥举了一个假样例，否定了我的想法。。。）</p>
<p>所以我们可以维护每一条边的使用次数，记向上走的为$+1$，向下走的为$-1$，那么就可以用（树链剖分）模拟最大流来通过这道题。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P6122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Dis[MAXn],Loc[MAXn],Flow[MAXn];</span><br><span class="line">LL Hole,Total,Food[MAXn],New,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_down</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&gt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_up</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">    Dis[X]=INF; Loc[X]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Food[X]) Dis[X]=<span class="number">0</span>,Loc[X]=X;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Lson]+Len_down(Lson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Lson]+Len_down(Lson);</span><br><span class="line">        Loc[X]=Loc[Lson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Rson]+Len_down(Rson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Rson]+Len_down(Rson);</span><br><span class="line">        Loc[X]=Loc[Rson];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Hole,&amp;Total);</span><br><span class="line">    Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Hole) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Food[i]);</span><br><span class="line">    BOR(i,Hole,<span class="number">1</span>) Update(i);</span><br><span class="line">    <span class="keyword">while</span>(Total--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;New);</span><br><span class="line">        LL Tag=<span class="number">0</span>,Cost=INF,Temp=<span class="number">0</span>,LCA=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Cost&gt;Temp+Dis[X]) Tag=Loc[X],LCA=X,Cost=Temp+Dis[X];</span><br><span class="line">            Temp+=Len_up(X);</span><br><span class="line">        &#125;</span><br><span class="line">        Ans+=Cost;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]++;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]--;</span><br><span class="line">        Food[Tag]--;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200607赛后总结</title>
    <url>/DeNeRATe.github.io/2020/06/24/T20200607%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="T20200607赛后总结"><a href="#T20200607赛后总结" class="headerlink" title="T20200607赛后总结"></a>T20200607赛后总结</h1><h2 id="成绩排行：T20200607成绩"><a href="#成绩排行：T20200607成绩" class="headerlink" title="成绩排行：T20200607成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200607/result2019.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200607/result2019.html">T20200607成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试总体偏简单，主要是在T3上，最初的代码量高达150+行，我是真的懵逼了。。。虽然我知道绝对是错误的思路引起的，但我还是毅然决然的交了上去（<del>其实就是因为想着争取混一点分QwQ</del>），结果取得了5分的好成绩（此处应该有Big Hand！=&gt;至少证明我还是有潜能的吧。。。[<del>口胡</del>]）。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/LJIZiPxKV8WCSF7.png" alt="T20200607 exam.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题作为NOIP2016模拟题Day2T1，自然是有点神奇的。。。</p>
<p>不知道为什么最后测试来是90分，而不是满分。。。（听欧巨说是需要一个特判？？？QwQ）</p>
<p>首先看完题之后，第一个想到的就是贪心的抽屉原理（鸽巢原理），即：使得不正确的题将每$ k-1 $个正确的题隔开，那么绝对是最优的结果。</p>
<p>但思考片刻，发现情况可能复杂的多。上边的情况只是在保证不正确的题目个数$ s \leq \frac{Cor}{k-1} $的情况下成立。而对于$ s &gt; \frac{Cor}{k-1} $的情况就只能另当别论了。</p>
<p>在一番冥思苦想之后，发现！</p>
<p>在正确的题目数确定的情况下，将$s$个$ k-1 $的正确题目组合放在最后边是这种情况下最优的，即：先将所有的$Cor$放在最后边，每$k-1$个就用一个错误的隔开，最后在不正确的题目不够用时，就可以直接统计剩余的正确题目的数量了，又由于发现剩余题目的贡献是一个等差数列</p>
<script type="math/tex; mode=display">
Ans_{remain}+=\frac{a_1 \times (r^{remain}-1)}{r-1}</script><p>这鸭子之后这个题就被秒了！</p>
<p>温馨提示：注意$ k=1 $时需要特判！</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Cor,Limit,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"exam.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"exam.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>,Step=A%MOD;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*Step)%MOD;</span><br><span class="line">		Step=(Step*Step)%MOD;</span><br><span class="line">		B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Cor,&amp;Limit);</span><br><span class="line">	LL Mine=Total-Cor;</span><br><span class="line">	<span class="keyword">if</span>((Cor<span class="number">-1</span>)/(Limit<span class="number">-1</span>)+<span class="number">1</span>&lt;=Mine) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Cor); &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL Remain=Total-(Limit)*Mine;</span><br><span class="line">		LL New=Remain/Limit;</span><br><span class="line">		Ans=(((<span class="number">2</span>*Limit)%MOD)*(((Fast(<span class="number">2</span>,New)%MOD)<span class="number">-1</span>+MOD)%MOD));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Ans+(Remain-New*Limit)%MOD)%MOD+Mine*(Limit<span class="number">-1</span>))%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>前缀和+单调队列</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/YPx7CHwbp5zdijl.png" alt="T20200607 genes.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>怎么说呢，考试的时候脑阔出问题了，考后直接打了一遍。</p>
<p>=&gt;一次编译成功=&gt;一次提交成功=&gt;直接AC=&gt;害~~~</p>
<p>首先可以想到改环成链。</p>
<p>然后发现这就是一个滑动窗口，每一个窗口如果不是优质基因序列，那么绝对存在这个窗口的某一个前缀&lt;0，因此可以想到维护一个单调队列来记录和更新当前窗口中前缀和的最小值。所以这道题就AC了。。。<del>汗</del></p>
<p>废话不多说，直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//genes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Queue[MAXn],Head=<span class="number">1</span>,Tail,New;</span><br><span class="line">LL Total,Ans,Num[MAXn],Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"genes.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"genes.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,Total+<span class="number">1</span>,<span class="number">2</span>*Total) &#123;</span><br><span class="line">		Num[i]=Num[i-Total] ;</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">2</span>*Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Queue[Head]&lt;i-Total) Head++;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Pre[i]&lt;Pre[Queue[Tail]]) Tail--;</span><br><span class="line">		Queue[++Tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total &amp;&amp; Pre[Queue[Head]]-New&gt;=<span class="number">0</span>) Ans++;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total) New=Pre[i-Total+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">   fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/uBVn153NlwzhSTa.png" alt="T20200607 paths.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这道题一看到，第一个想到的就是凸包！</p>
<p>内心活动：终于可以有施展拳脚的时候了。</p>
<p>但现实总是会给我一脚。。。每个点都要走？！</p>
<p>那直接记录其中一条线路啊，$ DP[n][4] $。直接4中状态转移，<del>它不香吗</del>，但是当我写完之后定睛一看，wo GIAO，为啥是150行？？？</p>
<p>所以我取得了5分的好成绩！</p>
<p>由于正解是真的ZZ，所以我就直接上正解了。</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>由于每个点要么在去的路上，要么在回来的路上，所以用二进制数表示$N$个点的状态，对于特殊的点特判一下，然后从所有状态中取最优的</p>
<p>期望得分：20分</p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>考虑到每个点只能走一次，且从终点往回走和从起点再走一遍到终点没有区别，所以这道题可以转化为求两条不相交路径和的最小值。</p>
<p>于是考虑用动态规划求解。</p>
<p>用$ F[i][j] $表示第一个点走到i,第二个点(回去的那个点)走到j的最优值。</p>
<p>为了保证更新时不会更新出$ F[i][i] $(即一个点走了两次)，而且每个点都会在路径上，我们每次用$ F[i][j] $去更新点$ max(i,j)+1 $，所以转移方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; k=<span class="built_in">max</span>(i,j)+<span class="number">1</span>，</span><br><span class="line">F[k][j]=<span class="built_in">max</span>(F[k][j],F[i][j]+Dis(i,k));</span><br><span class="line">F[i][k]=<span class="built_in">max</span>(F[i][k],F[i][j]+Dis(j,k));</span><br></pre></td></tr></table></figure>
<p>$ Dis(i,j) $为从i直接走到j点的距离.</p>
<p>对于两个特殊点和$ max(i,j)=N $的情况特判处理即可。</p>
<p>期望得分：100</p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>同时上面的DP也可以用记忆化搜索实现，对于$ |x-y|&gt;1 $的情况，说明当前情况只能从$ max(x,y)-1 $转移过来，当$ |x-y|=1 $时，则能从$ 1 \rightarrow min(x,y) $中的任意一点转移过来，于是用记忆化搜索完成上面的步骤，加上适当剪枝即可。</p>
<p>期望得分：60~100分</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//paths</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> DP[MAXn][MAXn];</span><br><span class="line"><span class="keyword">int</span> Total,A,B;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> X,Y;</span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"paths.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"paths.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node F,Node T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((F.X-T.X)*(F.X-T.X)+(F.Y-T.Y)*(F.Y-T.Y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Total,&amp;A,&amp;B);</span><br><span class="line">	A++; B++;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Num[i].X,&amp;Num[i].Y);</span><br><span class="line">	Cl(DP,<span class="number">0x7f</span>);</span><br><span class="line">	DP[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0.0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) </span><br><span class="line">		FOR(j,<span class="number">1</span>,Total) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==Total &amp;&amp; j==Total) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> k=<span class="built_in">max</span>(i,j);</span><br><span class="line">			<span class="keyword">if</span>(k==Total) &#123;</span><br><span class="line">				<span class="keyword">if</span>(k!=A &amp;&amp; j!=Total) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B &amp;&amp; i!=Total) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k]));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				k++;</span><br><span class="line">				<span class="keyword">if</span>(k!=A) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k])); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,DP[Total][Total]);</span><br><span class="line"> fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图扩展概念</title>
    <url>/DeNeRATe.github.io/2020/06/24/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%89%A9%E5%B1%95%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="二分图扩展概念"><a href="#二分图扩展概念" class="headerlink" title="二分图扩展概念"></a>二分图扩展概念</h1><h2 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h2><p>在二分图中寻找一个尽量小的点集，使图中每一条边至少有一个点在该点集中。<br><strong>最小顶点覆盖 = 最大匹配</strong></p>
<h3 id="证明（反证法）"><a href="#证明（反证法）" class="headerlink" title="证明（反证法）"></a>证明（反证法）</h3><p>假设当前存在一条两个端点都不在最小顶点覆盖点集中，那么这么光芒四射的边定可以增大最大匹配边集，与最大匹配矛盾，所以得证。</p>
<h2 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h2><p>在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。<br><strong>最小路径覆盖 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>因为一条边最多可以包含两个顶点，所以我们选边的时候让这样的边尽量多，也就是说最大匹配的边集数目咯。剩下的点就只能一个边连上一个点到集合里啦。</p>
<h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。<br><strong>最大独立集 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>因为去掉最大匹配两端的顶点去掉以后，剩下的点肯定是独立集。我们再从每个匹配里面挑选出来一个点加入到独立集中，也是不会破坏原有独立集的独立性的。</p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>树上三点最短路</title>
    <url>/DeNeRATe.github.io/2020/06/24/%E6%A0%91%E4%B8%8A%E4%B8%89%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="树上三点最短路"><a href="#树上三点最短路" class="headerlink" title="树上三点最短路"></a>树上三点最短路</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>若这三个点为$u$,$v$,$w$<br>首先通<strong>瞪眼法</strong>可以发现</p>
<h3 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h3><p>a=LCA(u,v),b=LCA(u,w),c=LCA(v,w)中一定有两个是相等的，即u,v,w中绝对有两个的最近公共祖先是同一个点<br>同样的，通过<strong>信仰模拟法</strong>可以发现</p>
<h3 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h3><p>三点之间的最短路=Dep[u]+Dep[v]+Dep[w]-Dep[a]-Dep[b]-Dep[c];</p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200610赛后总结</title>
    <url>/DeNeRATe.github.io/2020/06/24/T20200610%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="T20200610赛后总结："><a href="#T20200610赛后总结：" class="headerlink" title="T20200610赛后总结："></a>T20200610赛后总结：</h1><h2 id="成绩排行：T20200610成绩"><a href="#成绩排行：T20200610成绩" class="headerlink" title="成绩排行：T20200610成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200610/result20200610.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200610/result20200610.html">T20200610成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试题目比较中等，就是坑点太多，比如我们的LMK同学因为LL的问题从185=&gt;120.  </p>
<p>我也因为倒序的ZZ问题，从205=&gt;115 (<del>表面笑嘻嘻，心里MMP</del>)</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞+构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/V8upjCZtH1XE6as.png" alt="T20200610 eat.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先通过数据范围$ n \leq 200,000 $ ，再加上这是T1，可以推测时间复杂度是$ O(n) $，那么就可以通过这个思路来想正解</p>
<p>可以知道如果现在有一种吃到没有人的情况，那么每个点应该会有一个深度，如果**想要吃掉这些城市，那么唯一的通用方法就是从深度最浅的开始吃，吃到深度极大的。</p>
<p>然后但对于这种情况来说，不一定可以把每一个城市都吃完，因为其中可能会有城市在吃它之前，他就无了，那么假设我们选出来的这些城市都可以吃完，那么最后的总值就是</p>
<script type="math/tex; mode=display">
\sum^{k}_{i=1} Val[i] -\frac {k \times (k-1)}{2}</script><p>同时，为了达到最大并且让最小的那个能够被吃掉，直接可以$ O(n) $枚举后缀位置，给$ Ans $附上最大值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e5</span>+<span class="number">10</span>,MAXm=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Side,Val[MAXn],Ans;</span><br><span class="line">LL u,v,w,Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"eat.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"eat.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Val[i]);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">	sort(Val+<span class="number">1</span>,Val+Total+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Pre[i]=Pre[i<span class="number">-1</span>]+Val[i];</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Val[i]&lt;(Total-i+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="built_in">max</span>(Ans,Pre[Total]-Pre[i<span class="number">-1</span>]-(Total-i)*(Total-i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>质数+乱搞</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/iRHhlPDvWwFVxd4.png" alt="T20200610 division.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>（说实话，感觉这道题直接水是没问题的，<del>90分呀呀呀呀</del>）</p>
<p>分析数据范围，对于70%的数据，$ 2 \leq n \leq 1,000,000,000 \ , 1 \leq m \leq 200 $所以总的来说是算部分分中必须拿到的了。</p>
<p>因为我们可以想到，集合中的每一个数都有两种选择方式，所以集合中共有$ 2^{200} $种选择方式（<del>吓死宝宝了</del>），但是<del>定睛一看</del>（其实我看了几百年QwQ），可以发现，如果直接用map爆搜，那么map中只可能出现$ n $的约数，即设$ k $为map中的 数的个数，则据对有有$ k \leq \sqrt{n} $，时间复杂度$ O( \sqrt{n} \times m) $,那这个70分稳了！（其实考场上我用的就是这个，并且取得了90分的好成绩！。。。）但是定睛一看，打一个表，取出最小的k个质数乘一下！发现</p>
<script type="math/tex; mode=display">
\sum^{15}_{i=1,i \in prime} \geq 2^{64}(LL)</script><p>这下发现，对于100%的数据，$ 2 \leq 10^{18} \ ,1 \leq 500 $它就是个弟弟。</p>
<p>总的时间复杂度：$ O(2^{15}M) $</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//division</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt;DP;</span><br><span class="line">priority_queue&lt;LL&gt;Mine;</span><br><span class="line">LL Total,Size,Res,New;</span><br><span class="line"><span class="keyword">bool</span> Jud=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">GCD</span><span class="params">(LL X,LL Y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!Y) ? X : GCD(Y,X%Y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"division.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"division.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Size);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;Total&lt;&lt;endl&lt;&lt;Size&lt;&lt;endl;</span></span><br><span class="line">	FOR(i,<span class="number">1</span>,Size) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Res);</span><br><span class="line">		<span class="keyword">if</span>(Res!=<span class="number">1</span> &amp;&amp; Res&lt;=Total &amp;&amp; (GCD(Total,Res)==Res)) Mine.push(Res);</span><br><span class="line">		<span class="keyword">if</span>(Res==<span class="number">1</span>) Jud=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	while(!Mine.empty()) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;Mine.top();</span></span><br><span class="line"><span class="comment">//		Mine.pop();</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) &#123; </span><br><span class="line">		New=Mine.top();</span><br><span class="line">		Mine.pop();</span><br><span class="line">		<span class="built_in">map</span>&lt;LL,LL&gt;::iterator Iter=DP.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="comment">//DP.size()&lt;=sqrt(Total)</span></span><br><span class="line">		<span class="comment">//M*sqrt(Total)</span></span><br><span class="line">		<span class="keyword">while</span>(Iter!=DP.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			LL Next=(Iter-&gt;first)*New;</span><br><span class="line">			<span class="keyword">if</span>((GCD(Total,Next)==<span class="number">1</span>) || (Next&gt;Total) || (GCD(New,(Iter-&gt;first))!=<span class="number">1</span>)) &#123;</span><br><span class="line">				++Iter;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			DP[Next]+=(Iter-&gt;second);</span><br><span class="line">			++Iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Jud ? DP[Total]*<span class="number">2</span> : DP[Total]);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+拓扑排序+图的构建</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/fYNRp35G4rqiwX8.png" alt="T20200610 trip.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>作为本套试题的压轴题，不妙怎么行。。。（<del>口胡</del>）</p>
<p>首先本题是要求最长边权递增最长路，并统计路径条数。</p>
<p>我考场上直接暴力可还行。。。所以我直接上题解了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>把所有边按边权排序，暴力枚举选出的边集，然后判断该边集是否满足边权互不相同，且能依次组成一条路径。</p>
<p>时间复杂度$ O(2^m \times m) $，期望得分10分。</p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>首先考虑有向图该怎么做，然后只需把无向图的边拆成两条有向边即可。</p>
<p>把边当做点构造一张新图。对于原图的每个点，把与它关联的边分成两类，一类是连向它的边，称其为“入边”；另一类是从它连出去的边，称为“出边”。对于一条入边$ i $和出边$ j $，如果$ w_i &lt; w_j $，则在新图中$ i $向$ j $连一条有向边。</p>
<p>这样得到一张点数为$ m $，边数为$ O(m^2) $的新图，问题转化为：求这张新图的最长路和最长路的方案数。</p>
<p>由于连边的时候总满足$ w_i &lt; w_j $，所以新图不可能出现环，于是新图就是一张有向无环图（DAG）。对于求 DAG 的最长路和最长路的方案数，只需拓扑排序后再做动态规划即可。</p>
<p>时间复杂度$ O(n+m^2) $，期望得分 60 分。</p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>上述算法二的瓶颈在于构出新图，用上述算法得到的图边数是$ O(m^2) $显然不能承受。</p>
<p>枚举原图的每个点，然后把它的出边按边权从小到大排序。可以发现，对于一条入边$i$，如果它连向了出边$j$，则𝑖也会连向排在$j$之后的所有出边。</p>
<p>下面是构图方法：对每条出边$j$建立虚点$j’$，$j’$向$j$连权值为1的有向边。所有虚点按排好的顺序依次向下一个虚点连权值为0的有向边。对于每条入边$i$，找到出边中第一条边权大于它的边$j$，$i$向$j’$ 连权值为0的有向边。</p>
<p>这样得到的图还是 DAG，然后和算法二中一样，拓扑排序后再做动态规划即可。</p>
<p>时间复杂度$ O(n+mlog_2m) $，望得分 100 分。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Update(A,B,C,D)  <span class="meta-keyword">if</span>(A&gt;C) C=A,D=B; <span class="meta-keyword">else</span> <span class="meta-keyword">if</span>(A==C) (D+=B)%=MOD;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> Fir,Sec; </span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) &#123;  </span><br><span class="line">		<span class="keyword">if</span>(A.Fir==B.Fir) <span class="keyword">return</span> A.Sec&lt;B.Sec;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> A.Fir&lt;B.Fir;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Total,Side,Sum[MAXn],Len[MAXn];</span><br><span class="line"><span class="keyword">int</span> Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>],Head[MAXn],Cur,Val[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> In[MAXn],u,v,w,Dot,Queue[MAXn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	In[To]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trip.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"trip.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dot=<span class="number">2</span>*Side+<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		sort(Num[i].<span class="built_in">begin</span>(),Num[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">int</span> Loc=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,Num[i].<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			Add_Edge(Dot+j+<span class="number">1</span>,Num[i][j].Sec,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(;Loc&lt;Num[i].<span class="built_in">size</span>() &amp;&amp; Num[i][j].Fir == Num[i][Loc].Fir;Loc++) ;</span><br><span class="line">			<span class="keyword">if</span>(Loc&lt;Num[i].<span class="built_in">size</span>()) Add_Edge(Num[i][j].Sec^<span class="number">1</span>,Dot+Loc+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(j) Add_Edge(Dot+j,Dot+j+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="comment">//将每一个点的边成立的互相连接</span></span><br><span class="line">		Dot+=Num[i].<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;<span class="comment">//用队列来按顺序处理</span></span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) <span class="keyword">if</span>(!In[i]) Len[i]=<span class="number">0</span>,Sum[i]=<span class="number">1</span>,Queue[++R]=i;</span><br><span class="line">	<span class="keyword">for</span>(;L&lt;=R;L++) &#123;</span><br><span class="line">		<span class="keyword">int</span> New=Queue[L];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=Head[New];i;i=Next[i]) &#123;</span><br><span class="line">			Update(Len[New]+Val[i],Sum[New],Len[End[i]],Sum[End[i]]);</span><br><span class="line">			<span class="keyword">if</span>(!--In[End[i]]) Queue[++R]=End[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) Update(Len[i],Sum[i],A,B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,A,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		Num[u].push_back(Node&#123; w,i*<span class="number">2</span> &#125;);</span><br><span class="line">		Num[v].push_back(Node&#123; w,i*<span class="number">2</span>+<span class="number">1</span> &#125;);</span><br><span class="line">	&#125;<span class="comment">//初始化联通每一点的边 方便中途连图的时候的排序</span></span><br><span class="line">	Build();<span class="comment">//重新建图</span></span><br><span class="line">	Solve();<span class="comment">//直接每个点更新答案</span></span><br><span class="line"><span class="comment">//  fclose(stdin); fclose(stdout);</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>赛后总结</tag>
      </tags>
  </entry>
  <entry>
    <title>快速乘 &amp; 龟速乘</title>
    <url>/DeNeRATe.github.io/2020/06/24/%E5%BF%AB%E9%80%9F%E4%B9%98-%E9%BE%9F%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<h1 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>就是用来解决LL $ \times $ LL%MOD时LL会爆掉但%MOD之后不会爆掉的运算</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Slow</span><span class="params">(LL L,LL R,LL M)</span> </span>&#123;</span><br><span class="line">    L=(L%M+M)%M; </span><br><span class="line">    R=(R%M+M)%M;<span class="comment">//我也不知道为什么 </span></span><br><span class="line">	LL Res=L*R-(LL)((LD)L/M*R+<span class="number">1e-8</span>)*M;</span><br><span class="line">	<span class="keyword">return</span> Res&lt;<span class="number">0</span> ? Res+M : Res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>与龟速乘同理，只是改变了一下形式，用类似快速幂的方式完成QwQ</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick_mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span> == <span class="number">1</span>)ans+=x,ans%=mod;</span><br><span class="line">        x=x+x,x%=mod;</span><br><span class="line">    	y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>测试模板</title>
    <url>/DeNeRATe.github.io/2020/06/24/%E6%B5%8B%E8%AF%95%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\DeNeRATe.github.io\assets\css\APlayer.min.css"><script src="\DeNeRATe.github.io\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=440 height=86 src="//music.163.com/outchain/player?type=2&id=1374056689&auto=1&height=66"></iframe>

<iframe class="bilibili" src="//player.bilibili.com/player.html?aid=73773499&bvid=BV1tE411h7x4&cid=146795963&page=1&danmaku=1" scrolling="”no”" border="”0″" frameborder="”no”" framespacing="”0″" allowfullscreen="”true”" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>
]]></content>
      <tags>
        <tag>测试模板</tag>
      </tags>
  </entry>
</search>
