<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>T20200610赛后总结</title>
    <url>/articles/T20200610%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200610赛后总结："><a href="#T20200610赛后总结：" class="headerlink" title="T20200610赛后总结："></a>T20200610赛后总结：</h1><h2 id="成绩排行：T20200610成绩"><a href="#成绩排行：T20200610成绩" class="headerlink" title="成绩排行：T20200610成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200610/result20200610.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200610/result20200610.html">T20200610成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试题目比较中等，就是坑点太多，比如我们的LMK同学因为LL的问题从<strong>185=&gt;120</strong>.  </p>
<p>我也因为倒序的ZZ问题，从<strong>205=&gt;115</strong> (<del>表面笑嘻嘻，心里MMP</del>)</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞+构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/V8upjCZtH1XE6as.png" alt="T20200610 eat.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先通过数据范围$ n \leq 200,000 $ ，再加上这是T1，可以推测时间复杂度是$ O(n) $，那么就可以通过这个思路来想正解</p>
<p>可以知道如果现在有一种吃到没有人的情况，那么每个点应该会有一个深度，如果**想要吃掉这些城市，那么唯一的通用方法就是从深度最浅的开始吃，吃到深度极大的。</p>
<p>然后但对于这种情况来说，不一定可以把每一个城市都吃完，因为其中可能会有城市在吃它之前，他就无了，那么假设我们选出来的这些城市都可以吃完，那么最后的总值就是</p>
<script type="math/tex; mode=display">
\sum^{k}_{i=1} Val[i] -\frac {k \times (k-1)}{2}</script><p>同时，为了达到最大并且让最小的那个能够被吃掉，直接可以<strong>$ O(n) $</strong>枚举后缀位置，给$ Ans $附上最大值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e5</span>+<span class="number">10</span>,MAXm=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Side,Val[MAXn],Ans;</span><br><span class="line">LL u,v,w,Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"eat.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"eat.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Val[i]);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">	sort(Val+<span class="number">1</span>,Val+Total+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Pre[i]=Pre[i<span class="number">-1</span>]+Val[i];</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Val[i]&lt;(Total-i+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="built_in">max</span>(Ans,Pre[Total]-Pre[i<span class="number">-1</span>]-(Total-i)*(Total-i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>质数+乱搞</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/iRHhlPDvWwFVxd4.png" alt="T20200610 division.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>（说实话，感觉这道题直接水是没问题的，<del>90分呀呀呀呀</del>）</p>
<p>分析数据范围，对于70%的数据，$ 2 \leq n \leq 1,000,000,000 \ , 1 \leq m \leq 200 $所以总的来说是算部分分中必须拿到的了。</p>
<p>因为我们可以想到，集合中的每一个数都有两种选择方式，所以集合中共有$ 2^{200} $种选择方式（<del>吓死宝宝了</del>），但是<del>定睛一看</del>（其实我看了几百年QwQ），可以发现，如果直接用map爆搜，那么map中只可能出现$ n $的约数，即设$ k $为map中的 数的个数，则据对有有$ k \leq \sqrt{n} $，<strong>时间复杂度$ O( \sqrt{n} \times m) $</strong>,那这个70分稳了！（其实考场上我用的就是这个，并且取得了90分的好成绩！。。。）但是定睛一看，打一个表，取出最小的k个质数乘一下！发现</p>
<script type="math/tex; mode=display">
\sum^{15}_{i=1,i \in prime} \geq 2^{64}(LL)</script><p>这下发现，对于100%的数据，$ 2 \leq 10^{18} \ ,1 \leq 500 $它就是个弟弟。</p>
<p><strong>总的时间复杂度：$ O(2^{15}M) </strong>$</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//division</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt;DP;</span><br><span class="line">priority_queue&lt;LL&gt;Mine;</span><br><span class="line">LL Total,Size,Res,New;</span><br><span class="line"><span class="keyword">bool</span> Jud=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">GCD</span><span class="params">(LL X,LL Y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!Y) ? X : GCD(Y,X%Y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"division.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"division.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Size);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;Total&lt;&lt;endl&lt;&lt;Size&lt;&lt;endl;</span></span><br><span class="line">	FOR(i,<span class="number">1</span>,Size) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Res);</span><br><span class="line">		<span class="keyword">if</span>(Res!=<span class="number">1</span> &amp;&amp; Res&lt;=Total &amp;&amp; (GCD(Total,Res)==Res)) Mine.push(Res);</span><br><span class="line">		<span class="keyword">if</span>(Res==<span class="number">1</span>) Jud=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	while(!Mine.empty()) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;Mine.top();</span></span><br><span class="line"><span class="comment">//		Mine.pop();</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) &#123; </span><br><span class="line">		New=Mine.top();</span><br><span class="line">		Mine.pop();</span><br><span class="line">		<span class="built_in">map</span>&lt;LL,LL&gt;::iterator Iter=DP.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="comment">//DP.size()&lt;=sqrt(Total)</span></span><br><span class="line">		<span class="comment">//M*sqrt(Total)</span></span><br><span class="line">		<span class="keyword">while</span>(Iter!=DP.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			LL Next=(Iter-&gt;first)*New;</span><br><span class="line">			<span class="keyword">if</span>((GCD(Total,Next)==<span class="number">1</span>) || (Next&gt;Total) || (GCD(New,(Iter-&gt;first))!=<span class="number">1</span>)) &#123;</span><br><span class="line">				++Iter;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			DP[Next]+=(Iter-&gt;second);</span><br><span class="line">			++Iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Jud ? DP[Total]*<span class="number">2</span> : DP[Total]);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+拓扑排序+图的构建</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/fYNRp35G4rqiwX8.png" alt="T20200610 trip.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>作为本套试题的压轴题，不妙怎么行。。。（<del>口胡</del>）</p>
<p>首先本题是要求最长边权递增最长路，并统计路径条数。</p>
<p>我考场上直接暴力可还行。。。所以我直接上题解了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>把所有边按边权排序，暴力枚举选出的边集，然后判断该边集是否满足边权互不相同，且能依次组成一条路径。</p>
<p><strong>时间复杂度</strong>$ O(2^m \times m) $，<strong>期望得分10分</strong>。</p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>首先考虑有向图该怎么做，然后只需把无向图的边拆成两条有向边即可。</p>
<p>把边当做点构造一张新图。对于原图的每个点，把与它关联的边分成两类，一类是连向它的边，称其为“入边”；另一类是从它连出去的边，称为“出边”。对于一条入边$ i $和出边$ j $，如果$ w_i &lt; w_j $，则在新图中$ i $向$ j $连一条有向边。</p>
<p>这样得到一张点数为$ m $，边数为<strong>$ O(m^2) $</strong>的新图，问题转化为：求这张新图的最长路和最长路的方案数。</p>
<p>由于连边的时候总满足$ w_i &lt; w_j $，所以新图不可能出现环，于是新图就是一张有向无环图（DAG）。对于求 DAG 的最长路和最长路的方案数，只需拓扑排序后再做动态规划即可。</p>
<p><strong>时间复杂度$ O(n+m^2) $</strong>，<strong>期望得分 60 分</strong>。</p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>上述算法二的瓶颈在于构出新图，用上述算法得到的图边数是<strong>$ O(m^2) $</strong>显然不能承受。</p>
<p>枚举原图的每个点，然后把它的出边按边权从小到大排序。可以发现，对于一条入边$i$，如果它连向了出边$j$，则𝑖也会连向排在$j$之后的所有出边。</p>
<p>下面是构图方法：对每条出边$j$建立虚点$j’$，$j’$向$j$连权值为1的有向边。所有虚点按排好的顺序依次向下一个虚点连权值为0的有向边。对于每条入边$i$，找到出边中第一条边权大于它的边$j$，$i$向$j’$ 连权值为0的有向边。</p>
<p>这样得到的图还是 DAG，然后和算法二中一样，拓扑排序后再做动态规划即可。</p>
<p><strong>时间复杂度$ O(n+mlog_2m) $</strong>，<strong>期望得分 100 分</strong>。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Update(A,B,C,D)  <span class="meta-keyword">if</span>(A&gt;C) C=A,D=B; <span class="meta-keyword">else</span> <span class="meta-keyword">if</span>(A==C) (D+=B)%=MOD;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> Fir,Sec; </span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) &#123;  </span><br><span class="line">		<span class="keyword">if</span>(A.Fir==B.Fir) <span class="keyword">return</span> A.Sec&lt;B.Sec;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> A.Fir&lt;B.Fir;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Total,Side,Sum[MAXn],Len[MAXn];</span><br><span class="line"><span class="keyword">int</span> Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>],Head[MAXn],Cur,Val[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> In[MAXn],u,v,w,Dot,Queue[MAXn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	In[To]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trip.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"trip.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dot=<span class="number">2</span>*Side+<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		sort(Num[i].<span class="built_in">begin</span>(),Num[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">int</span> Loc=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,Num[i].<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			Add_Edge(Dot+j+<span class="number">1</span>,Num[i][j].Sec,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(;Loc&lt;Num[i].<span class="built_in">size</span>() &amp;&amp; Num[i][j].Fir == Num[i][Loc].Fir;Loc++) ;</span><br><span class="line">			<span class="keyword">if</span>(Loc&lt;Num[i].<span class="built_in">size</span>()) Add_Edge(Num[i][j].Sec^<span class="number">1</span>,Dot+Loc+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(j) Add_Edge(Dot+j,Dot+j+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="comment">//将每一个点的边成立的互相连接</span></span><br><span class="line">		Dot+=Num[i].<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;<span class="comment">//用队列来按顺序处理</span></span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) <span class="keyword">if</span>(!In[i]) Len[i]=<span class="number">0</span>,Sum[i]=<span class="number">1</span>,Queue[++R]=i;</span><br><span class="line">	<span class="keyword">for</span>(;L&lt;=R;L++) &#123;</span><br><span class="line">		<span class="keyword">int</span> New=Queue[L];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=Head[New];i;i=Next[i]) &#123;</span><br><span class="line">			Update(Len[New]+Val[i],Sum[New],Len[End[i]],Sum[End[i]]);</span><br><span class="line">			<span class="keyword">if</span>(!--In[End[i]]) Queue[++R]=End[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) Update(Len[i],Sum[i],A,B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,A,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		Num[u].push_back(Node&#123; w,i*<span class="number">2</span> &#125;);</span><br><span class="line">		Num[v].push_back(Node&#123; w,i*<span class="number">2</span>+<span class="number">1</span> &#125;);</span><br><span class="line">	&#125;<span class="comment">//初始化联通每一点的边 方便中途连图的时候的排序</span></span><br><span class="line">	Build();<span class="comment">//重新建图</span></span><br><span class="line">	Solve();<span class="comment">//直接每个点更新答案</span></span><br><span class="line"><span class="comment">//  fclose(stdin); fclose(stdout);</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog Chore</title>
    <url>/articles/Blog%20Chore/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇博客主要来整理一些<strong>Blog搭建的配置</strong>比如说——-</p>
<p><strong>温馨提示</strong>：本文仅限于<strong>Markdown语法</strong>插入</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><h2 id="1-登录网易云音乐（网页版-amp-客户端）"><a href="#1-登录网易云音乐（网页版-amp-客户端）" class="headerlink" title="1.登录网易云音乐（网页版 &amp; 客户端）"></a>1.登录网易云音乐（网页版 &amp; 客户端）</h2><h2 id="2-进入Chrome应用商场"><a href="#2-进入Chrome应用商场" class="headerlink" title="2.进入Chrome应用商场"></a>2.进入Chrome应用商场</h2><h2 id="3-搜素“网易云”"><a href="#3-搜素“网易云”" class="headerlink" title="3.搜素“网易云”"></a>3.搜素“网易云”</h2><p><img src="https://i.loli.net/2020/06/25/EJyXTwlLYmnHu79.png" alt="网易云插件-1.png"></p>
<h2 id="4-添加“网易云音乐下载插件”"><a href="#4-添加“网易云音乐下载插件”" class="headerlink" title="4.添加“网易云音乐下载插件”"></a>4.添加“网易云音乐下载插件”</h2><p><img src="https://i.loli.net/2020/06/25/dqMpW3GYRuSeH2D.png" alt="网易云插件-2.png"></p>
<p><strong>温馨提示：</strong>添加成功之后Chrome右上方会有小型图标，如果看他不爽可以右键+隐藏（<del>我这个强迫症患者是有点QwQ</del>）</p>
<p><strong>温馨提示：</strong>如果你发现你的网易云插件下载之后没有亮起，不要方张。他是需要进入客户端（网页版）之后才会亮起的。。。</p>
<h2 id="5-选取需要插入的歌曲"><a href="#5-选取需要插入的歌曲" class="headerlink" title="5.选取需要插入的歌曲"></a>5.选取需要插入的歌曲</h2><p><img src="https://i.loli.net/2020/06/25/jT6RvbKFZgsMweN.png" alt="网易云插件-3.png"></p>
<h2 id="6-点击“生成外链播放器”"><a href="#6-点击“生成外链播放器”" class="headerlink" title="6.点击“生成外链播放器”"></a>6.点击“生成外链播放器”</h2><p><img src="https://i.loli.net/2020/06/25/kmKjsO8ya7tZCYf.png" alt="网易云插件-4.png"></p>
<h2 id="7-获取歌曲代码"><a href="#7-获取歌曲代码" class="headerlink" title="7.获取歌曲代码"></a>7.获取歌曲代码</h2><p><img src="https://i.loli.net/2020/06/25/7YSA6NjIVcULKvZ.png" alt="网易云插件-5.png"></p>
<h2 id="8-将获取的Markdown代码插入到Typora中"><a href="#8-将获取的Markdown代码插入到Typora中" class="headerlink" title="8.将获取的Markdown代码插入到Typora中"></a>8.将获取的Markdown代码插入到Typora中</h2><p>插入效果展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">440</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1374056689&amp;auto=1&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1374056689&auto=1&height=66"></iframe>

<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="1-登录哔哩哔哩官网"><a href="#1-登录哔哩哔哩官网" class="headerlink" title="1.登录哔哩哔哩官网"></a>1.登录哔哩哔哩官网</h2><h2 id="2-选择你要插入的视频"><a href="#2-选择你要插入的视频" class="headerlink" title="2.选择你要插入的视频"></a>2.选择你要插入的视频</h2><h2 id="3-获取“嵌入代码”"><a href="#3-获取“嵌入代码”" class="headerlink" title="3.获取“嵌入代码”"></a>3.获取“嵌入代码”</h2><p><img src="https://i.loli.net/2020/06/25/KAJ1W4OfNMkvtz8.png" alt="哔哩哔哩配置-1.png"></p>
<h2 id="4-将获取的HTML代码插入到Typora中"><a href="#4-将获取的HTML代码插入到Typora中" class="headerlink" title="4.将获取的HTML代码插入到Typora中"></a>4.将获取的HTML代码插入到Typora中</h2><p>插入效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=73773499&amp;bvid=BV1tE411h7x4&amp;cid=146795963&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然这还不够，你会发现这个时候上传，视频会变得很小。。。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="lt-1-添加“哔哩哔哩视频适配“"><a href="#lt-1-添加“哔哩哔哩视频适配“" class="headerlink" title="&lt;1.添加“哔哩哔哩视频适配“"></a>&lt;1.添加“哔哩哔哩视频适配“</h4><p>进入 <strong>C:\hexo\themes\next\source\css\_custom\custom.styl</strong></p>
<p>加入如下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/*哔哩哔哩视频适配*/</span></span><br><span class="line"><span class="string">.bilibili</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">767px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">15em;max-width:</span> <span class="string">25em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">768px)</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">991px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">20em;max-width:</span> <span class="string">30em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">992px)</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">1199px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">30em;max-width:</span> <span class="string">40em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">1200px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">40em;max-width:</span> <span class="string">50em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="lt-2-代码调整"><a href="#lt-2-代码调整" class="headerlink" title="&lt;2.代码调整"></a>&lt;2.代码调整</h4><p>加入<strong>class=“bilibili”</strong>调用哔哩哔哩的播放器</p>
<p>并加入视频的大小调整<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"</span><br></pre></td></tr></table></figure></p>
<h4 id="lt-3-效果展示"><a href="#lt-3-效果展示" class="headerlink" title="&lt;3.效果展示"></a>&lt;3.效果展示</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">"bilibili"</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=73773499&amp;bvid=BV1tE411h7x4&amp;cid=146795963&amp;page=1&amp;danmaku=1"</span> <span class="attr">scrolling</span>=<span class="string">"”no”"</span> <span class="attr">border</span>=<span class="string">"”0″"</span> <span class="attr">frameborder</span>=<span class="string">"”no”"</span> <span class="attr">framespacing</span>=<span class="string">"”0″"</span> <span class="attr">allowfullscreen</span>=<span class="string">"”true”"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lt-4-bilibili参数说明"><a href="#lt-4-bilibili参数说明" class="headerlink" title="&lt;4.bilibili参数说明"></a>&lt;4.bilibili参数说明</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">aid 视频ID 就是B站的av号</span><br><span class="line">cid 应该是客户端的id,clientid的缩写（推测） 测试表示不填也不会有什么问题</span><br><span class="line">page 第几个视频 也就是分P的 默认是1</span><br><span class="line">as_wide 是否宽屏 1：宽屏 0：小屏</span><br><span class="line">high_quality 视频质量 1：最高视频质量 0：最低视频质量</span><br><span class="line">danmaku 是否开启弹幕 1：开启（默认） 0：关闭</span><br></pre></td></tr></table></figure>
<h2 id="5-上传效果展示"><a href="#5-上传效果展示" class="headerlink" title="5.上传效果展示"></a>5.上传效果展示</h2><iframe class="bilibili" src="//player.bilibili.com/player.html?aid=73773499&bvid=BV1tE411h7x4&cid=146795963&page=1&danmaku=1" scrolling="”no”" border="”0″" frameborder="”no”" framespacing="”0″" allowfullscreen="”true”" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>这里介绍一个最实用的评论系统—-Valine，基于LeanCloud，可以在不登陆的情况下评论（十分convenientQwQ）</p>
<h2 id="1-创建LeanCloud账号"><a href="#1-创建LeanCloud账号" class="headerlink" title="1.创建LeanCloud账号"></a>1.创建LeanCloud账号</h2><p>使用<strong>“免费试用”</strong>即可</p>
<p><img src="https://i.loli.net/2020/06/25/WB8Q5VpY7xJFyb2.png" alt="Valine-1.png"></p>
<h2 id="2-身份验证-邮箱验证"><a href="#2-身份验证-邮箱验证" class="headerlink" title="2.身份验证+邮箱验证"></a>2.身份验证+邮箱验证</h2><p><strong>温馨提示：</strong>验证（<strong>个人认证</strong>）时需要<strong>支付宝</strong>扫码验证身份</p>
<p><img src="https://i.loli.net/2020/06/25/QZU7DYoevFTtg5f.png" alt="Valine-2.png"></p>
<h2 id="3-进入“控制台”创建新项目"><a href="#3-进入“控制台”创建新项目" class="headerlink" title="3.进入“控制台”创建新项目"></a>3.进入“控制台”创建新项目</h2><p>下面是我已创建好的一个项目</p>
<p><img src="https://i.loli.net/2020/06/25/5tcmJdqTx6Vn8Sy.png" alt="Valine-3.png"></p>
<p><strong>温馨提示：</strong>选取”<strong>开发版</strong>“，项目名称随便取</p>
<p><img src="https://i.loli.net/2020/06/25/hTBFoSqDwe4KtHr.png" alt="Valine-4.png"></p>
<h2 id="4-进入项目并获取App-ID和App-Key"><a href="#4-进入项目并获取App-ID和App-Key" class="headerlink" title="4.进入项目并获取App ID和App Key"></a>4.进入项目并获取App ID和App Key</h2><p>进入顺序：你的项目$ \rightarrow $设置$ \rightarrow $应用Keys（之后就可以看到这两个东东了）</p>
<p><img src="https://i.loli.net/2020/06/25/nAeyZdLQFckgz21.png" alt="Valine-5.png"></p>
<h2 id="5-主题中配置Valine"><a href="#5-主题中配置Valine" class="headerlink" title="5.主题中配置Valine"></a>5.主题中配置Valine</h2><p><strong>C:\hexo\themes\next\ _config.yml</strong></p>
<p>其中将enable改为true，notify是”是否提示“</p>
<p><img src="https://i.loli.net/2020/06/25/Gwnu7EQ9kibNBdq.png" alt="Valine-6.png"></p>
<p>（没错，就是这么<del>简单</del>）</p>
<h2 id="6-管理评论"><a href="#6-管理评论" class="headerlink" title="6.管理评论"></a>6.管理评论</h2><p>进入顺序：你的项目$ \rightarrow $存储$ \rightarrow $结构化数据$ \rightarrow $Comment</p>
<p>即可管理评论（<del>嘿嘿嘿</del>）</p>
<p><img src="https://i.loli.net/2020/06/25/DAXvehB6mgZ94fk.png" alt="Valine-7.png"></p>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>这里我就只说一下<strong>腾讯云</strong>的域名绑定吧（弄完之后再回过头来看，发现是真的简单。。。）</p>
<h2 id="1-注册腾讯云账户并进入“域名注册”"><a href="#1-注册腾讯云账户并进入“域名注册”" class="headerlink" title="1.注册腾讯云账户并进入“域名注册”"></a>1.注册腾讯云账户并进入“域名注册”</h2><p><img src="https://i.loli.net/2020/06/27/1pxKsTUV4ROImD5.png" alt="腾讯云域名-1.png"></p>
<h2 id="2-选择个性化的域名"><a href="#2-选择个性化的域名" class="headerlink" title="2.选择个性化的域名"></a>2.选择个性化的域名</h2><p><img src="https://i.loli.net/2020/06/27/JADMfnH6kiLVv8Q.png" alt="腾讯云域名-2.png"></p>
<h2 id="3-查找并选择实惠，喜爱的域名后缀"><a href="#3-查找并选择实惠，喜爱的域名后缀" class="headerlink" title="3.查找并选择实惠，喜爱的域名后缀"></a>3.查找并选择实惠，喜爱的域名后缀</h2><p>比如我现在这个Blog后缀就是ink</p>
<p>在“查询结果”中找到“<strong>最优秀</strong>”的并添加到“购物车“</p>
<p><img src="https://i.loli.net/2020/06/27/mIQ16cMpXgS5VuA.png" alt="腾讯云域名-3.png"></p>
<h2 id="4-购买域名"><a href="#4-购买域名" class="headerlink" title="4.购买域名"></a>4.购买域名</h2><p><strong>温馨提示：</strong>这里注册人需要实名认证</p>
<p><img src="https://i.loli.net/2020/06/27/m3u9nUQ5HO1hNlb.png" alt="腾讯云域名-4.png"></p>
<h2 id="5-在控制台中进入“域名管理”"><a href="#5-在控制台中进入“域名管理”" class="headerlink" title="5.在控制台中进入“域名管理”"></a>5.在控制台中进入“域名管理”</h2><p>这里直接在“腾讯云产品”处搜索“域名管理”即可</p>
<p><img src="https://i.loli.net/2020/06/27/ZILaDNEgW5dFCBh.png" alt="腾讯云域名-5.png"></p>
<h2 id="6-审核域名"><a href="#6-审核域名" class="headerlink" title="6.审核域名"></a>6.审核域名</h2><p>这里我是已经审核完毕了，但如果是新买了那么可能需要一些时间（少则几十秒，多则几个工作日，不定）来审核，完成之后就会显示“正常”</p>
<p><img src="https://i.loli.net/2020/06/27/vh49J8YDHgKoNbl.png" alt="腾讯云域名-6.png"></p>
<h2 id="7-解析域名"><a href="#7-解析域名" class="headerlink" title="7.解析域名"></a>7.解析域名</h2><p>进入顺序：解析$ \rightarrow $添加记录</p>
<p><img src="https://i.loli.net/2020/06/27/9yCIZFqMLBDQz8w.png" alt="腾讯云域名-7.png"></p>
<p><img src="https://i.loli.net/2020/06/27/kpcnAJermsd65WT.png" alt="腾讯云域名-8.png"></p>
<p>这里在添加时其实会有非常明确的注释</p>
<p>在“主机记录”栏中填入什么其实并不重要（即啥都可以填（当时必须是英文））</p>
<p>只是最后关系到域名使用的链接方式</p>
<p>当然我还是推荐直接就是选择“@”即“不需要”，这样在访问时感觉简洁一点。。。</p>
<p>这里“记录类型”需要填写CNAME</p>
<p>后边的“记录值”就是你的原本的域名</p>
<p><img src="https://i.loli.net/2020/06/27/DFkyWOcBQfG8EXK.png" alt="腾讯云域名-9.png"></p>
<h2 id="8-绑定github新域名"><a href="#8-绑定github新域名" class="headerlink" title="8.绑定github新域名"></a>8.绑定github新域名</h2><p>进入顺序：github仓库$ \rightarrow $settings$ \rightarrow $Github Pages$ \rightarrow $Custom domain</p>
<p>在这个地方输入你买的域名，save即可</p>
<p><img src="https://i.loli.net/2020/06/27/6qhETFNRi4coMfa.png" alt="腾讯云域名-10.png"></p>
<h2 id="9-添加CNAME文件"><a href="#9-添加CNAME文件" class="headerlink" title="9.添加CNAME文件"></a>9.添加CNAME文件</h2><p><strong>C:\hexo\source</strong>中添加一个名为CNAME的文件</p>
<p><strong>温馨提示：</strong>这个文件需要将其的后缀名删除！！！（如下图）</p>
<p><img src="https://i.loli.net/2020/06/27/PYplstVOXjJHzm1.png" alt="腾讯云域名-11.png"></p>
<p>再用某某方式打开它（这里我用的是Sublime）</p>
<p>并在其中添加你的新域名</p>
<p>这样之后，就Perfect了</p>
<p><img src="https://i.loli.net/2020/06/27/Zxn1OkSMr38zUhY.png" alt="腾讯云域名-12.png"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果没有这个文件，我们在每次hexo g，hexo d之后都需要重新在github上save新域名，非常的麻烦</p>
<p>所以可以直接在这个地方加一个CNAME文件，保证这个新域名地址的Blog也可以被更新</p>
<h2 id="10-修改默认域名地址"><a href="#10-修改默认域名地址" class="headerlink" title="10.修改默认域名地址"></a>10.修改默认域名地址</h2><p>这个时候我们只需要打开文件</p>
<p><strong>C:\hexo\_config.yml</strong>进行两部修改：</p>
<p>修改如图<strong>url</strong>处的域名（即改为<strong>自己购买的域名</strong>）</p>
<p>将<strong>permalink</strong>处改为如图的<strong>“articles/:title/”</strong>即可大功告成</p>
<p><img src="https://i.loli.net/2020/07/04/OToK8NcsmYp4Jw1.png" alt="腾讯云域名-13.png"></p>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200603赛后总结</title>
    <url>/articles/T20200603%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200603赛后总结"><a href="#T20200603赛后总结" class="headerlink" title="T20200603赛后总结"></a>T20200603赛后总结</h1><h2 id="成绩排行：T20200603成绩"><a href="#成绩排行：T20200603成绩" class="headerlink" title="成绩排行：T20200603成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200603/result20200603.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200603/result20200603.html">T20200603成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>emm。。。这套题我只想吐槽一下T1。</p>
<p>为啥$ nh $的假贪心可以直接过？？？<del>我吐了</del></p>
<p>我和LMK写的$ nlogh $的真线段树贪心它不香吗。。。</p>
<p>就是排序写挂了。。。<strong>100=&gt;0</strong> wonderful！！！</p>
<p>然后就是T3，没懂+INF。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P1250" target="_blank" rel="noopener">P1250 种树</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心</strong></p>
<p>但是我觉得需要<strong>线段树+贪心</strong>比较好。。。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/5LEIkVxpAKNW1Sr.png" alt="T20200603 trees.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一看，啥都不用说，丫的就是一个贪心，每次选出被覆盖次数最多的那个区域种上树，不久OU了吗。</p>
<p>那么现在要做的就是如何每次选出被覆盖次数最多的区域了。</p>
<p>对于这些区间，需要想到的就是区间排序在操作，所以此时就有两种操作了，１.左对齐排序　２.右对齐排序。经过我亲身排序错误的爆零尝试，才知道我脑抽了。。。右对齐它多香啊。。。</p>
<p>所以之后就每次枚举当前区间，将最右边的全部覆盖掉。</p>
<p><strong>时间复杂度：$ O(nh) $或$ O(nlogh) $</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trees</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line">LL Total,House;</span><br><span class="line">LL Tree[MAXn&lt;&lt;<span class="number">2</span>],Tag[MAXn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    LL B,E,T;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;Temp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(E==Temp.E) <span class="keyword">return</span> B&lt;Temp.B;</span><br><span class="line">        <span class="keyword">return</span> E&lt;Temp.E;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(LL X)</span></span>&#123; Tree[X]=Tree[Lson]+Tree[Rson]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UP</span><span class="params">(LL L, LL R, LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[X]=(R-L+<span class="number">1</span>);</span><br><span class="line">    Tag[X]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(LL L,LL R,LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">    LL Mid=(L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    UP(L,Mid,Lson);</span><br><span class="line">    UP(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">    Tag[X]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) </span><br><span class="line">    &#123;</span><br><span class="line">        Tree[X]=R-L+<span class="number">1</span>;</span><br><span class="line">        Tag[X]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) UpDate(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) UpDate(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) <span class="keyword">return</span> Tree[X];</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) Ans+=Query(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) Ans+=Query(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL TL,LL TR,LL T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL L=TL,R=TR,Ans=TL;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">        LL Mid=(L+R)&gt;&gt;<span class="number">1</span>, S=((Mid<span class="number">-1</span>)&lt;TL ? <span class="number">0</span> : Query(<span class="number">1</span>,Total,TL,Mid<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (S+TR-Mid+<span class="number">1</span>&gt;=T) Ans=Mid,L=Mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=Mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL L,LL R,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Tree[X]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Print(L,Mid,Lson); Print(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trees.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"trees.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;Total,&amp;House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>,&amp;Num[i].B,&amp;Num[i].E,&amp;Num[i].T);    </span><br><span class="line">    sort(Num,Num+House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) &#123;</span><br><span class="line">        LL Res=Query(<span class="number">1</span>,Total,Num[i].B,Num[i].E);</span><br><span class="line">        <span class="keyword">if</span>(Res&gt;=Num[i].T) <span class="keyword">continue</span>;</span><br><span class="line">        LL Place=Get(Num[i].B,Num[i].E,Num[i].T);</span><br><span class="line">        UpDate(<span class="number">1</span>,Total,Place,Num[i].E);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Tree[<span class="number">1</span>]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>倍增</strong></p>
<p>或<strong>树状数组</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/yiSBUuOHe4xgCW2.png" alt="T20200603 at.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于本题考试的时候没有一个不是AC的，所以也就没什么必要分析了</p>
<p>我还是来一波solution的分析吧</p>
<blockquote>
<p>题目实际上是求每个结点深度差不超过K的儿子个数。</p>
<pre><code>由于涉及到方面有：深度、子树求和，大概思路可以想到是先预处理，然后按深度从大到小增删点，再查询某子树有多少个点。

增删点的过程可以通过给点设权值来实现，1表示这个点存在，0表示不存在。那么查询某子树有多少个点就相当于是对某个子树中点的权值进行求和。

与子树相关可用dfs序，修改和求和可以用树状数组实现。
</code></pre></blockquote>
<p>所以，就这么OU了，真香。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//at</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,K,u,v,Cur;</span><br><span class="line">LL Sum[MAXn],Val[MAXn],Temp[MAXn],Anc[MAXn][<span class="number">20</span>];</span><br><span class="line">LL Head[MAXn],Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">DFS</span><span class="params">(LL X, LL Fa)</span> </span>&#123;</span><br><span class="line">    Anc[X][<span class="number">0</span>]=Fa; Temp[Fa]++;</span><br><span class="line">    FOR(i,<span class="number">1</span>,<span class="number">19</span>) Anc[X][i]=Anc[Anc[X][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    LL TO=X,TK=K;</span><br><span class="line">    <span class="keyword">for</span> (LL i=<span class="number">0</span>;TK;++i)</span><br><span class="line">        <span class="keyword">if</span> (TK &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            TK ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            TO=Anc[TO][i];</span><br><span class="line">        &#125;</span><br><span class="line">    Temp[Anc[TO][<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">for</span> (LL i=Head[X];i;i=Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(End[i]==Fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(End[i],X);</span><br><span class="line">        Temp[X]+=Temp[End[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(LL From,LL To)</span> </span>&#123;</span><br><span class="line">    Next[++Cur]=Head[From];</span><br><span class="line">    Head[From]=Cur;</span><br><span class="line">    End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"at.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"at.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;N,&amp;K);</span><br><span class="line">	FOR(i,<span class="number">1</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        AddEdge(u,v); AddEdge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,N) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,Temp[i]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>构造+组合数学</strong></p>
<p>或<strong>矩阵快速幂+动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FEVoNZiWK3J1r7s.png" alt="T20200603 poker.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>其实我不怎么想分析，因为</p>
<p>1.这明明叫高二学堂，他跟题面有啥关系啊？！</p>
<p>2.这题解写的是嘛呀，看不懂（高二巨佬也没搞懂，只看懂了80分）</p>
<p>综上所述，我就直接上solution了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>输出$n$，不解释。。。</p>
<p><strong>期望得分：10</strong></p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>利用上式对$Ai$和$Xi$进行搜索，同样不解释。。。</p>
<p><strong>期望得分：20</strong></p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>把牌按数值大小编号，数值相同的编上4个不同号码。</p>
<p>用$ f[i][j][k] $表示现在处理完前i张牌，一共用了$j$张，构成和为$k$的方案数。转移只要使用类似背包的方法即可。</p>
<p>方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f’[i][j][k]=f[i][j][k]+Σf[i<span class="number">-1</span>][j<span class="number">-1</span>][k-w(i)]。</span><br></pre></td></tr></table></figure>
<p>其中$ w(i) $为$i$的牌面。</p>
<p>为免MLE，可把第一维省去。</p>
<p><strong>期望得分：40</strong></p>
<h4 id="【算法四】"><a href="#【算法四】" class="headerlink" title="【算法四】"></a>【算法四】</h4><p>这是Symbol提出来的方法。</p>
<p>如果现在所有的牌面都大于1，假设有$k$’张，那么把所有牌面都减小1，总和减少$k’$之后，问题显然是等价的；而如果有牌面等于1，那么只要把这几张牌去掉，剩下的牌面就又都是大于1的了。</p>
<p>所以可以使用$ f[i][j] $表示用j张牌构成和为$i$的方案数，转移的时候分情况：</p>
<p>1）所有牌面大于1，则$ f[i][j]+=f[i-j][j] $；</p>
<p>2）有牌面等于1，那么我们可以枚举这些牌的数量$ t（\leq 4） $，则$ f[i][j]+=f[i-j][j-t] $。</p>
<p>最后答案就是$ f[n][1 \rightarrow k] $的最小值。</p>
<p><strong>时间复杂度为$ O(nk) </strong>$</p>
<p><strong>期望得分：60</strong></p>
<h4 id="【算法五】"><a href="#【算法五】" class="headerlink" title="【算法五】"></a>【算法五】</h4><p>对算法4进行优化，考虑到$k$比较小，而转移只需要用到前$k$层的值。</p>
<p>我们可以把连续$k$层的f压在一个矩阵内，并按一维编号，最多不超过$k^2$个。然后我们每次转移1层的$f$，也就是如果现在矩阵记录的是$f[1 \rightarrow k][]$的值，那么转移一次，矩阵记录的就变成了$f[2 \rightarrow k+1][]$的值。然后填矩阵就是了。</p>
<p><strong>时间复杂度为$ O(logn \times k^6) $</strong>，多组数据下，这个方法会由于常数大被卡掉。</p>
<p><strong>期望得分：80</strong></p>
<h4 id="【算法六】"><a href="#【算法六】" class="headerlink" title="【算法六】"></a>【算法六】</h4><p>首先，假设牌面的集合为$ {xi} $，集合中的每个元素对应一个$ ai（\leq 4）$，表示这个牌面用了多少张。那么问题就转化成了求$ Σai \times xi=n $的正整数解个数，其中$ x1&lt;x2&lt;…&lt;xm，Σai≤k $。由于ai和k都比较小，我们可以暴力枚举所有情况，再去解方程。而现在约束还是比较多的，我们得想办法除去约束。</p>
<p>设$ yi=xi-x_{i-1} $，换元后方程变为$ Σbi \times yi=n $的形式，其中$ bi \leq k $。至此，我们成功把未知数单调这个棘手的约束解决了。</p>
<p>接下来，我们发现$bi$比较小$(≤10)$，那么可以把$bi$的lcm算出来，最多为<strong>2520</strong>。然后把$bi \times yi$表示成$ pi \times lcm+qi $的形式，其中$qi$必须能被$bi$整除。</p>
<p>现在方程转化为</p>
<script type="math/tex; mode=display">
lcm \times Σpi+Σqi=n。</script><p>考虑到$ Σqi $还是比较小的$(≤3W)$，可以枚举$ Σqi $的每个可能值，那么$pi$的方案数就可以用经典的隔板法来计算。而对于$ Σqi $的计算，我们可以用背包来实现。背包的时候要注意各种细节，而且注意复杂度的把握。</p>
<p><strong>期望得分：100</strong></p>
<p>（由于这道题我是实在不知道题解和代码的意思，所以就只能用std的代码了。。。我太CHAI了 害~~~）</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poker Hewr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fo(i,a,b) for (int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,a,b) for (int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn=<span class="number">11</span>,mm=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> a[mn],d[mn],Rev[mn],f[mm],F[mm];</span><br><span class="line"><span class="keyword">int</span> n,k,m,L,Ans,NowS,N,A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> (c=(a%b)) a=b,b=c;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=Rev[b];</span><br><span class="line">	fo (i,a-b+<span class="number">1</span>,a) ret=(LL)ret*i%mo;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=(LL)ret*a%mo;</span><br><span class="line">		a=(LL)a*a%mo,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS) F[i]=f[i];</span><br><span class="line">	<span class="keyword">int</span> l=L/x*x;</span><br><span class="line">	fo (i,NowS+<span class="number">1</span>,<span class="built_in">min</span>(n,NowS+l)) F[i]=<span class="number">0</span>;</span><br><span class="line">	NowS=<span class="built_in">min</span>(n,NowS+l);</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS)&#123;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=x)&#123;</span><br><span class="line">			F[i]=(F[i]+(f[i]=F[i-x]))%mo;</span><br><span class="line">			<span class="keyword">if</span> (i&gt;=l+x) f[i]=(f[i]-F[i-l-x]+mo)%mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	d[m]=a[m];</span><br><span class="line">	fd (i,m<span class="number">-1</span>,<span class="number">1</span>) d[i]=d[i+<span class="number">1</span>]+a[i];</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,NowS=<span class="number">0</span>,L=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,m) L=L*d[i]/gcd(L,d[i]);</span><br><span class="line">	fo (i,<span class="number">1</span>,m) dp(d[i]);</span><br><span class="line">	fo (nn,m,NowS) <span class="keyword">if</span> (!((N=n-nn)%L) &amp;&amp; (A=f[nn]))&#123;</span><br><span class="line">		B=C(N/L+m<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">		Ans=((LL)A*B+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> M,<span class="keyword">int</span> K,<span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (M&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		m=M<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp=work();</span><br><span class="line">		Ans=((LL)tmp*W+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!K) <span class="keyword">return</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> (i&lt;=K)&#123;</span><br><span class="line">		a[M]=i;</span><br><span class="line">		dfs(M+<span class="number">1</span>,K-i,(LL)W*C(<span class="number">4</span>,i)%mo);</span><br><span class="line">		a[M]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Rev[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,mn<span class="number">-1</span>) Rev[i]=(LL)Rev[i<span class="number">-1</span>]*Pow(i,mo<span class="number">-2</span>)%mo;</span><br><span class="line">	freopen(<span class="string">"poker.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"poker.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n+k)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,k,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200607赛后总结</title>
    <url>/articles/T20200607%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200607赛后总结"><a href="#T20200607赛后总结" class="headerlink" title="T20200607赛后总结"></a>T20200607赛后总结</h1><h2 id="成绩排行：T20200607成绩"><a href="#成绩排行：T20200607成绩" class="headerlink" title="成绩排行：T20200607成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200607/result2019.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200607/result2019.html">T20200607成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试总体偏简单，主要是在T3上，最初的代码量高达150+行，我是真的懵逼了。。。虽然我知道绝对是错误的思路引起的，但我还是毅然决然的交了上去（<del>其实就是因为想着争取混一点分QwQ</del>），结果取得了5分的好成绩（此处应该有Big Hand！=&gt;至少证明我还是有潜能的吧。。。[<del>口胡</del>]）。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/LJIZiPxKV8WCSF7.png" alt="T20200607 exam.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题作为NOIP2016模拟题Day2T1，自然是有点神奇的。。。</p>
<p>不知道为什么最后测试来是90分，而不是满分。。。（听欧巨说是需要一个特判？？？QwQ）</p>
<p>首先看完题之后，第一个想到的就是贪心的抽屉原理（鸽巢原理），即：使得不正确的题将每$ k-1 $个正确的题隔开，那么绝对是最优的结果。</p>
<p>但思考片刻，发现情况可能复杂的多。上边的情况只是在保证不正确的题目个数$ s \leq \frac{Cor}{k-1} $的情况下成立。而对于$ s &gt; \frac{Cor}{k-1} $的情况就只能另当别论了。</p>
<p>在一番冥思苦想之后，发现！</p>
<p>在正确的题目数确定的情况下，将$s$个$ k-1 $的正确题目组合放在最后边是这种情况下最优的，即：先将所有的$Cor$放在最后边，每$k-1$个就用一个错误的隔开，最后在不正确的题目不够用时，就可以直接统计剩余的正确题目的数量了，又由于发现剩余题目的贡献是一个等差数列</p>
<script type="math/tex; mode=display">
Ans_{remain}+=\frac{a_1 \times (r^{remain}-1)}{r-1}</script><p>这鸭子之后这个题就被秒了！</p>
<p><strong>温馨提示</strong>：注意$ k=1 $时需要特判！</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Cor,Limit,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"exam.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"exam.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>,Step=A%MOD;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*Step)%MOD;</span><br><span class="line">		Step=(Step*Step)%MOD;</span><br><span class="line">		B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Cor,&amp;Limit);</span><br><span class="line">	LL Mine=Total-Cor;</span><br><span class="line">	<span class="keyword">if</span>((Cor<span class="number">-1</span>)/(Limit<span class="number">-1</span>)+<span class="number">1</span>&lt;=Mine) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Cor); &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL Remain=Total-(Limit)*Mine;</span><br><span class="line">		LL New=Remain/Limit;</span><br><span class="line">		Ans=(((<span class="number">2</span>*Limit)%MOD)*(((Fast(<span class="number">2</span>,New)%MOD)<span class="number">-1</span>+MOD)%MOD));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Ans+(Remain-New*Limit)%MOD)%MOD+Mine*(Limit<span class="number">-1</span>))%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>前缀和+单调队列</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/YPx7CHwbp5zdijl.png" alt="T20200607 genes.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>怎么说呢，考试的时候脑阔出问题了，考后直接打了一遍。</p>
<p>=&gt;一次编译成功=&gt;一次提交成功=&gt;直接AC=&gt;害~~~</p>
<p>首先可以想到改环成链。</p>
<p>然后发现这就是一个滑动窗口，每一个窗口如果不是优质基因序列，那么绝对存在这个窗口的某一个前缀&lt;0，因此可以想到维护一个单调队列来记录和更新当前窗口中前缀和的最小值。所以这道题就AC了。。。<del>汗</del></p>
<p>废话不多说，直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//genes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Queue[MAXn],Head=<span class="number">1</span>,Tail,New;</span><br><span class="line">LL Total,Ans,Num[MAXn],Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"genes.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"genes.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,Total+<span class="number">1</span>,<span class="number">2</span>*Total) &#123;</span><br><span class="line">		Num[i]=Num[i-Total] ;</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">2</span>*Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Queue[Head]&lt;i-Total) Head++;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Pre[i]&lt;Pre[Queue[Tail]]) Tail--;</span><br><span class="line">		Queue[++Tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total &amp;&amp; Pre[Queue[Head]]-New&gt;=<span class="number">0</span>) Ans++;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total) New=Pre[i-Total+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">   fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/uBVn153NlwzhSTa.png" alt="T20200607 paths.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这道题一看到，第一个想到的就是凸包！</p>
<p>内心活动：终于可以有施展拳脚的时候了。</p>
<p>但现实总是会给我一脚。。。每个点都要走？！</p>
<p>那直接记录其中一条线路啊，$ DP[n][4] $。直接4中状态转移，<del>它不香吗</del>，但是当我写完之后定睛一看，wo GIAO，为啥是150行？？？</p>
<p>所以我取得了5分的好成绩！</p>
<p>由于正解是真的ZZ，所以我就直接上正解了。</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>由于每个点要么在去的路上，要么在回来的路上，所以用二进制数表示$N$个点的状态，对于特殊的点特判一下，然后从所有状态中取最优的</p>
<p><strong>期望得分：20分</strong></p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>考虑到每个点只能走一次，且从终点往回走和从起点再走一遍到终点没有区别，所以这道题可以转化为求两条不相交路径和的最小值。</p>
<p>于是考虑用动态规划求解。</p>
<p>用$ F[i][j] $表示第一个点走到i,第二个点(回去的那个点)走到j的最优值。</p>
<p>为了保证更新时不会更新出$ F[i][i] $(即一个点走了两次)，而且每个点都会在路径上，我们每次用$ F[i][j] $去更新点$ max(i,j)+1 $，所以转移方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; k=<span class="built_in">max</span>(i,j)+<span class="number">1</span>，</span><br><span class="line">F[k][j]=<span class="built_in">max</span>(F[k][j],F[i][j]+Dis(i,k));</span><br><span class="line">F[i][k]=<span class="built_in">max</span>(F[i][k],F[i][j]+Dis(j,k));</span><br></pre></td></tr></table></figure>
<p>$ Dis(i,j) $为从i直接走到j点的距离.</p>
<p>对于两个特殊点和$ max(i,j)=N $的情况特判处理即可。</p>
<p><strong>期望得分：100</strong></p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>同时上面的DP也可以用记忆化搜索实现，对于$ |x-y|&gt;1 $的情况，说明当前情况只能从$ max(x,y)-1 $转移过来，当$ |x-y|=1 $时，则能从$ 1 \rightarrow min(x,y) $中的任意一点转移过来，于是用记忆化搜索完成上面的步骤，加上适当剪枝即可。</p>
<p><strong>期望得分：60~100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//paths</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> DP[MAXn][MAXn];</span><br><span class="line"><span class="keyword">int</span> Total,A,B;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> X,Y;</span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"paths.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"paths.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node F,Node T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((F.X-T.X)*(F.X-T.X)+(F.Y-T.Y)*(F.Y-T.Y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Total,&amp;A,&amp;B);</span><br><span class="line">	A++; B++;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Num[i].X,&amp;Num[i].Y);</span><br><span class="line">	Cl(DP,<span class="number">0x7f</span>);</span><br><span class="line">	DP[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0.0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) </span><br><span class="line">		FOR(j,<span class="number">1</span>,Total) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==Total &amp;&amp; j==Total) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> k=<span class="built_in">max</span>(i,j);</span><br><span class="line">			<span class="keyword">if</span>(k==Total) &#123;</span><br><span class="line">				<span class="keyword">if</span>(k!=A &amp;&amp; j!=Total) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B &amp;&amp; i!=Total) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k]));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				k++;</span><br><span class="line">				<span class="keyword">if</span>(k!=A) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k])); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,DP[Total][Total]);</span><br><span class="line"> fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图扩展概念</title>
    <url>/articles/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%89%A9%E5%B1%95%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分图扩展概念"><a href="#二分图扩展概念" class="headerlink" title="二分图扩展概念"></a>二分图扩展概念</h1><h2 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h2><p>在二分图中寻找一个尽量小的点集，使图中每一条边至少有一个点在该点集中。<br><strong>最小顶点覆盖 = 最大匹配</strong></p>
<h3 id="证明（反证法）"><a href="#证明（反证法）" class="headerlink" title="证明（反证法）"></a>证明（反证法）</h3><p>假设当前存在一条两个端点都不在最小顶点覆盖点集中，那么这么光芒四射的边定可以增大最大匹配边集，与最大匹配矛盾，所以得证。</p>
<h2 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h2><p>在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。<br><strong>最小路径覆盖 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>因为一条边最多可以包含两个顶点，所以我们选边的时候让这样的边尽量多，也就是说最大匹配的边集数目咯。剩下的点就只能一个边连上一个点到集合里啦。</p>
<h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。<br><strong>最大独立集 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>因为去掉最大匹配两端的顶点去掉以后，剩下的点肯定是独立集。我们再从每个匹配里面挑选出来一个点加入到独立集中，也是不会破坏原有独立集的独立性的。</p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>快速乘 &amp; 龟速乘</title>
    <url>/articles/%E5%BF%AB%E9%80%9F%E4%B9%98-%E9%BE%9F%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>就是用来解决LL $ \times $ LL%MOD时LL会爆掉但%MOD之后不会爆掉的运算</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Slow</span><span class="params">(LL L,LL R,LL M)</span> </span>&#123;</span><br><span class="line">    L=(L%M+M)%M; </span><br><span class="line">    R=(R%M+M)%M;<span class="comment">//我也不知道为什么 </span></span><br><span class="line">	LL Res=L*R-(LL)((LD)L/M*R+<span class="number">1e-8</span>)*M;</span><br><span class="line">	<span class="keyword">return</span> Res&lt;<span class="number">0</span> ? Res+M : Res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>与龟速乘同理，只是改变了一下形式，用类似快速幂的方式完成QwQ</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick_mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span> == <span class="number">1</span>)ans+=x,ans%=mod;</span><br><span class="line">        x=x+x,x%=mod;</span><br><span class="line">    	y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>树上三点最短路</title>
    <url>/articles/%E6%A0%91%E4%B8%8A%E4%B8%89%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树上三点最短路"><a href="#树上三点最短路" class="headerlink" title="树上三点最短路"></a>树上三点最短路</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>若这三个点为$u$,$v$,$w$<br>首先通<strong>瞪眼法</strong>可以发现</p>
<h3 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h3><p>a=LCA(u,v),b=LCA(u,w),c=LCA(v,w)中一定有两个是相等的，即u,v,w中绝对有两个的最近公共祖先是同一个点<br>同样的，通过<strong>信仰模拟法</strong>可以发现</p>
<h3 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h3><p>三点之间的最短路=Dep[u]+Dep[v]+Dep[w]-Dep[a]-Dep[b]-Dep[c];</p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200529赛后总结</title>
    <url>/articles/T20200529%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200529赛后总结"><a href="#T20200529赛后总结" class="headerlink" title="T20200529赛后总结"></a>T20200529赛后总结</h1><h2 id="成绩排行：T20200529成绩"><a href="#成绩排行：T20200529成绩" class="headerlink" title="成绩排行：T20200529成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200529/result20200529.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200529/result20200529.html">T20200529成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是集训的第一套题。。。可谓是<strong>开门黑</strong>。</p>
<p>在此膜拜 stO 欧巨 Orz。</p>
<p>总的来说，这一套题除了第二题外没有什么难搞的，好吧，T3的代码量有点大。。。</p>
<p>本以为T1瞬秒之后准备AK了。。。结果T3我成功反驳了我的正确思路QwQ</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FyraMX3N4cH6GgY.png" alt="T20200529 words.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>定睛手膜一下样例可以知道，若我分析到$tr$了，下一个是$e$，如果直接算下一个$tre$个数量的话，会有一部分重复，而这部分的重复个数刚好就是$tr$之后的这个字母在$heap$里边的出现次数，因此，在手摸几个样例发现，这个思路确实是毫无破绽，那么正解不就出来了吗。。。</p>
<p>温馨提示：我就是因为没有判首尾是否需要算入答案的情况，使得我的100=&gt;0wonderful!</p>
<p><strong>时间复杂度：$ O(2n) $</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//words</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[MAXn],B[MAXn];</span><br><span class="line">LL Cnt[<span class="number">30</span>],DP,Ans,Lena,Lenb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"words.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"words.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+<span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">"%s"</span>,B+<span class="number">1</span>);</span><br><span class="line">	Lena=<span class="built_in">strlen</span>(A+<span class="number">1</span>); Lenb=<span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Lenb<span class="number">-1</span>) Cnt[B[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Lena) &#123;</span><br><span class="line">		DP=Lenb-Cnt[A[i]-<span class="string">'a'</span>+<span class="number">1</span>],Ans+=DP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans+Lenb);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+斜率优化</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/NTXyKD1ALVrlOou.png" alt="T20200529 distance.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当我看到$ n \leq 1,000 $，然后又看到是一个矩阵时，我就知道了这道题100%是一个<strong>$ O(n^2) $</strong>的时间复杂度。</p>
<p>继而就没什么思路了。</p>
<p>（我发现我口胡这道题好像不太行，那就直接上题解？）</p>
<blockquote>
<p>分别从左上，右上，左下，右下四个方向做一次斜率DP取最优值即可。</p>
</blockquote>
<p>没错，这个就是solution里边写的东西，你看，这是人说的话吗？！</p>
<p>$ \approx $没说。。。所以，最后还是需要我来口胡一哈。。。</p>
<p>相当于就是记录每一行的一个单调队列，因为对于同一行，他们的纵坐标是一定的，那么横坐标又是单调递增的，所以可以直接推出转移式，记录并转移（<del>口胡完毕</del>）</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//distance</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Row,Line,DP[MAXn][MAXn],Dis[MAXn];</span><br><span class="line"><span class="keyword">char</span> Sta[MAXn][MAXn];</span><br><span class="line">LL Cube[MAXn][MAXn],F[MAXn][MAXn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL X,Y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Node <span class="keyword">operator</span> - (Node A,Node B) &#123;</span><br><span class="line">		Node Temp;</span><br><span class="line">		Temp.X=A.X-B.X; </span><br><span class="line">		Temp.Y=A.Y-B.Y;</span><br><span class="line">		<span class="keyword">return</span> Temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;Queue[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.X*B.Y-A.Y*B.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B,Node C)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Cross(B-A,C-A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"distance.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"distance.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Calc</span><span class="params">(Node A,LL Loc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.Y<span class="number">-2</span>*Loc*A.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		LL Head=<span class="number">0</span>,Tail=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Sta[i][j]==<span class="string">'1'</span>) Dis[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> ++Dis[i];</span><br><span class="line">			Node New;</span><br><span class="line">			New.X=j; New.Y=j*j+Dis[j]*Dis[j];</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Cross(Queue[Tail<span class="number">-1</span>],Queue[Tail],New)&lt;=<span class="number">0</span>) Tail--;</span><br><span class="line">			Queue[++Tail]=New;</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Calc(Queue[Head+<span class="number">1</span>],j)&gt;Calc(Queue[Head+<span class="number">2</span>],j)) Head++;</span><br><span class="line">			DP[i][j]=Calc(Queue[Head+<span class="number">1</span>],j)+j*j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>(); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Row,&amp;Line);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,Sta[i]+<span class="number">1</span>);</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) Cube[i][j]=Sta[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = DP[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[i][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j) </span><br><span class="line">			Sta[i][j] = Cube[Row - i + <span class="number">1</span>][j];</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, F[i][j], j == Line ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P6122" target="_blank" rel="noopener">P6122 Mole Tunnels</a></p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>模拟最大流+贪心</strong></p>
<p>但是我觉得（<strong>树链剖分+贪心</strong>）也是可以的</p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/KUHBTmeN9fWcDGY.png" alt="T20200529 tree.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先观察到，这道题的树非常的特殊，是一颗完美二叉树，这就不免是我们想到这道题一定不简单，没错我就是被这种思想禁锢了。。。使得我最后用手摸样例推翻了我自己的思路。。。害~~~</p>
<p><img src="https://i.loli.net/2020/06/24/B4NpU8E1OMaKS2z.png" alt="T20200529 tree 草稿1.png"></p>
<p>可以发现这个时候有两条边被重复走了。那么我们肯定可以找出更优解，即：</p>
<p><img src="https://i.loli.net/2020/06/24/GkIDg3u4ytUbP8R.png" alt="T20200529 tree 草稿2.png"></p>
<p>这个时候，我们发现这两条被来回走过的边，<strong>他们无了！！！</strong>。</p>
<p>脑洞瞬间打开（而我不一样，我不知道为啥举了一个假样例，否定了我的想法。。。）</p>
<p>所以我们可以维护每一条边的使用次数，记向上走的为$+1$，向下走的为$-1$，那么就可以用（树链剖分）模拟最大流来通过这道题。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P6122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Dis[MAXn],Loc[MAXn],Flow[MAXn];</span><br><span class="line">LL Hole,Total,Food[MAXn],New,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_down</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&gt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_up</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">    Dis[X]=INF; Loc[X]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Food[X]) Dis[X]=<span class="number">0</span>,Loc[X]=X;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Lson]+Len_down(Lson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Lson]+Len_down(Lson);</span><br><span class="line">        Loc[X]=Loc[Lson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Rson]+Len_down(Rson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Rson]+Len_down(Rson);</span><br><span class="line">        Loc[X]=Loc[Rson];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Hole,&amp;Total);</span><br><span class="line">    Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Hole) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Food[i]);</span><br><span class="line">    BOR(i,Hole,<span class="number">1</span>) Update(i);</span><br><span class="line">    <span class="keyword">while</span>(Total--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;New);</span><br><span class="line">        LL Tag=<span class="number">0</span>,Cost=INF,Temp=<span class="number">0</span>,LCA=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Cost&gt;Temp+Dis[X]) Tag=Loc[X],LCA=X,Cost=Temp+Dis[X];</span><br><span class="line">            Temp+=Len_up(X);</span><br><span class="line">        &#125;</span><br><span class="line">        Ans+=Cost;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]++;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]--;</span><br><span class="line">        Food[Tag]--;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Maker</title>
    <url>/articles/%E6%95%B0%E6%8D%AE%E5%88%B6%E9%80%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据制造"><a href="#数据制造" class="headerlink" title="数据制造"></a>数据制造</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>最近突然来了兴趣，出了一场比赛，有了一些心得吧，也学到了很多。</p>
<p>所以这里来说一下<strong>批量制造数据</strong></p>
<p><img src="https://i.loli.net/2020/07/13/ZUVmd4ew2figDxI.png" alt="数据制造-1.png"></p>
<p>所以，其实原理简单的一批，<strong>困难的主要是如何设计好的data</strong>，这个真的是体验之后感悟颇深（<del>感觉出数据比写程序还难。。。</del>）</p>
<h2 id="rand-和srand-产生随机数"><a href="#rand-和srand-产生随机数" class="headerlink" title="rand()和srand()产生随机数"></a>rand()和srand()产生随机数</h2><p><strong>rand()​</strong>函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个<strong>伪随机数</strong>，是根据一个数，我们可以称它为种子，为基准以某个递推公式推算出来的一系数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统，为了改变这个种子的值，C提供了 <strong>srand()​</strong>函数，它的原形是<strong>void srand( int a)​</strong><br>   初始化随机产生器既rand()函数的初始值，即使把种子的值改成a; 从这你可以看到通过sand()函数，我们是可以产生可以预见的随机序列,那我们如何才能产生不可预见的随机序列呢？我们可能常常需要这样的随机序列，是吧。利用<strong>srand((unsigned)time(NULL))​</strong>是一种方法，因为每一次运行程序的时间是不同的.</p>
<p>$rand()$会返回一随机数值，范围在<strong>0至RAND_MAX​</strong> 间。返回0至RAND_MAX之间的随机数值，RAND_MAX定义在<strong>stdlib.h</strong>，(其值至少为32767)，运算的结果是一个不定的数，要看你定义的变量类型，int整形的话就是32767。 在调用此函数产生随机数前，必须先利用$srand()$设好随机数种子，如果未设随机数种子，$rand()$在调用时会自动设随机数种子为<strong>1</strong>。一般用for语句来设置种子的个数。</p>
<p><strong>random（）产生随机数为0或1；</strong></p>
<p><strong>random（n）产生随机数为0到n之间的一个随机数；</strong></p>
<p><strong>rand（）产生0到32768之间的一个随机数。</strong></p>
<h3 id="产生指定范围的随机数"><a href="#产生指定范围的随机数" class="headerlink" title="产生指定范围的随机数"></a>产生指定范围的随机数</h3><p>由于$rand$产生的随机数从0到$rand_max$，而$rand_max$是一个很大的数，那么如何产生从$X \rightarrow Y$的数呢？</p>
<p>  从$X$到$Y$，有$Y-X+1$个数，所以要产生从$X$到$Y$的数，只需要这样写：</p>
<script type="math/tex; mode=display">
k=rand()\%(Y-X+1)+X</script><p>  这样，就可以产生你想要的任何范围内的随机数了。</p>
<h3 id="32bits随机数"><a href="#32bits随机数" class="headerlink" title="32bits随机数"></a>32bits随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generate a random 32 bits integer number </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((rand()&lt;&lt;<span class="number">16</span>)+(rand()&lt;&lt;<span class="number">1</span>)+rand()%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了32bits的随机数生成方法，就可以构造32bits范围内的随机整数区间了，方法和之前16bits的情况一样。</p>
<h3 id="32bits范围内的随机整数区间"><a href="#32bits范围内的随机整数区间" class="headerlink" title="32bits范围内的随机整数区间"></a>32bits范围内的随机整数区间</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generate a random 32bits integer number in [start,end)</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">uniform_integer_32</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> base=rand32();</span><br><span class="line">    <span class="keyword">if</span>(base==RAND32_MAX)</span><br><span class="line">        <span class="keyword">return</span> uniform_integer_32(start,<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">int</span> range=<span class="built_in">end</span>-start;</span><br><span class="line">    <span class="keyword">int</span> remainder=RAND32_MAX%range;</span><br><span class="line">    <span class="keyword">int</span> bucket=RAND32_MAX/range;</span><br><span class="line">    <span class="keyword">if</span>(base&lt;RAND32_MAX-remainder)</span><br><span class="line">        <span class="keyword">return</span> start+base/bucket;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> uniform_integer_32(start,<span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Awesome TEST</title>
    <url>/articles/TEST/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Nothing Here</strong></p>
<p><strong>Just A Test</strong></p>
]]></content>
      <tags>
        <tag>Awesome TEST</tag>
      </tags>
  </entry>
  <entry>
    <title>期末理综专项复习信心赛-题解</title>
    <url>/articles/%E6%9C%9F%E6%9C%AB%E7%90%86%E7%BB%BC%E4%B8%93%E9%A1%B9%E5%A4%8D%E4%B9%A0%E4%BF%A1%E5%BF%83%E8%B5%9B-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>Personal Program</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11中vector的N种遍历方式</title>
    <url>/articles/C-11%E4%B8%ADvector%E7%9A%84N%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-11中vector的N种遍历方式"><a href="#C-11中vector的N种遍历方式" class="headerlink" title="C++11中vector的N种遍历方式"></a>C++11中vector的N种遍历方式</h1><h2 id="1-老式遍历"><a href="#1-老式遍历" class="headerlink" title="1.老式遍历"></a>1.老式遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Count=New.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Count;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;New[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-for循环迭代器遍历"><a href="#2-for循环迭代器遍历" class="headerlink" title="2.for循环迭代器遍历"></a>2.for循环迭代器遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator Iter=New.vbegin();Iter!=New.cend();Iter++) </span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;*Iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-auto迭代器遍历"><a href="#3-auto迭代器遍历" class="headerlink" title="3.auto迭代器遍历"></a>3.auto迭代器遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> Iter=New.cbegin();Iter!=New.cend();Iter++) </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*Iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-for-each函数遍历"><a href="#4-for-each函数遍历" class="headerlink" title="4.for_each函数遍历"></a>4.for_each函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; Val)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">	for_each(New.cbegin(),New.cend(),Print&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-for-each-仿函数遍历"><a href="#5-for-each-仿函数遍历" class="headerlink" title="5.for_each+仿函数遍历"></a>5.for_each+仿函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; Obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">cout</span>&gt;&gt;Obj&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">	for_each(New.cbegin(),New.cend(),Functor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-for-each-Lambda函数遍历"><a href="#6-for-each-Lambda函数遍历" class="headerlink" title="6.for_each+Lambda函数遍历"></a>6.for_each+Lambda函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    for_each(New.cbegin(),New.cend(),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; Val)-&gt;<span class="keyword">void</span>&#123; <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-for区间遍历"><a href="#7-for区间遍历" class="headerlink" title="7.for区间遍历"></a>7.for区间遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> Val : New) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-ETC"><a href="#8-ETC" class="headerlink" title="8.ETC."></a>8.ETC.</h2>]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基操</title>
    <url>/articles/Markdown%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown基操"><a href="#Markdown基操" class="headerlink" title="Markdown基操"></a>Markdown基操</h1><h2 id="一-基础格式"><a href="#一-基础格式" class="headerlink" title="一.基础格式"></a>一.基础格式</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span># 这是一级标题</span><br><span class="line"><span class="symbol">2 </span>## 这是二级标题</span><br><span class="line"><span class="symbol">3 </span>### 这是三级标题</span><br><span class="line"><span class="symbol">4 </span>#### 这是四级标题</span><br><span class="line"><span class="symbol">5 </span>##### 这是五级标题</span><br><span class="line"><span class="symbol">6 </span>###### 这是六级标题</span><br></pre></td></tr></table></figure>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>**这是加粗的文字**</span><br><span class="line"><span class="symbol">2 </span>*这是倾斜的文字*`</span><br><span class="line"><span class="symbol">3 </span>***这是斜体加粗的文字***</span><br><span class="line"><span class="symbol">4 </span>~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字\</em></strong><br><del>这是加删除线的文字</del></p>
<h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>&gt;这是引用的内容</span><br><span class="line"><span class="symbol">2 </span>&gt;&gt;这是引用的内容</span><br><span class="line"><span class="symbol">3 </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<p>效果如下：（。。。博客园的格式有点不一样鹅。。。）</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h3><p>（三个或者三个以上的 - 或者 * 都可以。）</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>---</span><br><span class="line"><span class="symbol">2 </span>----</span><br><span class="line"><span class="symbol">3 </span>***</span><br><span class="line"><span class="symbol">4 </span>*****</span><br></pre></td></tr></table></figure>
<p>（好像展示效果也没啥用。。。）</p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>（好吧 我太懒了 [好像各个地方都可以在写Markdown的时候直接插入图片，链接，代码和列表吧] 逃 QwQ）</p>
<p>（当然还是有一个基础的，换行：2<em>Space+1</em>Enter）</p>
<h2 id="二-数学公式语法"><a href="#二-数学公式语法" class="headerlink" title="二.数学公式语法"></a>二.数学公式语法</h2><h3 id="1-行内和独行"><a href="#1-行内和独行" class="headerlink" title="1.行内和独行"></a>1.行内和独行</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>行内公式：将公式插入到本行内，符号：$公式内容$，如：$ xyz $</span><br><span class="line"><span class="symbol">2 </span>独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$ xyz $$</span><br></pre></td></tr></table></figure>
<h3 id="2-上标，下标和组合"><a href="#2-上标，下标和组合" class="headerlink" title="2.上标，下标和组合"></a>2.上标，下标和组合</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>上标符号，符号：^，如：$x^<span class="number">4</span>$</span><br><span class="line"><span class="symbol">2 </span>下标符号，符号：_，如：$x_1$</span><br><span class="line"><span class="symbol">3 </span>组合符号，符号：&#123;&#125;，如：$&#123;<span class="number">16</span>&#125;_&#123;<span class="number">8</span>&#125;O&#123;<span class="number">2</span>+&#125;_&#123;<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="3-字体格式"><a href="#3-字体格式" class="headerlink" title="3.字体格式"></a>3.字体格式</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>字体控制，符号：\displaystyle，如：$\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;$</span><br><span class="line"><span class="symbol">2 </span>下划线符号，符号：\underline，如：$\underline&#123;x+y&#125;$</span><br><span class="line"><span class="symbol">3 </span>上大括号，符号：\overbrace&#123;算式&#125;，如：$\overbrace&#123;a+b+c+d&#125;^&#123;<span class="number">2.0</span>&#125;$</span><br><span class="line"><span class="symbol">4 </span>下大括号，符号：\underbrace&#123;算式&#125;，如：$a+\underbrace&#123;b+c&#125;_&#123;<span class="number">1.0</span>&#125;+d$</span><br><span class="line"><span class="symbol">5 </span>上位符号，符号：\stacrel&#123;上位符号&#125;&#123;基位符号&#125;，如：$\vec&#123;x&#125;\stackrel&#123;\mathrm&#123;<span class="keyword">def</span>&#125;&#125;&#123;=&#125;&#123;x_1,\dots,x_n&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="4-占位符"><a href="#4-占位符" class="headerlink" title="4.占位符"></a>4.占位符</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>紧贴，符号\!，如：$x \! y$  </span><br><span class="line"><span class="symbol">2 </span>没有空格，符号``，如：$xy$  </span><br><span class="line"><span class="symbol">3 </span>小空格，符号\,，如：$x \, y$  </span><br><span class="line"><span class="symbol">4 </span>中空格，符号\:，如：$x \: y$  </span><br><span class="line"><span class="symbol">5 </span>大空格，符号\，如：$x \ y$  </span><br><span class="line"><span class="symbol">6 </span>quad空格，符号：\quad，如：$x \quad y$</span><br><span class="line"><span class="symbol">7 </span>两个quad空格，符号：\qquad，如：$x \qquad y$</span><br></pre></td></tr></table></figure>
<h3 id="5-定界符"><a href="#5-定界符" class="headerlink" title="5.定界符"></a>5.定界符</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>小括号，符号：（），如：$ (x+y) $</span><br><span class="line"><span class="symbol">2 </span>中括号，符号： []，如：$ [x+y] $</span><br><span class="line"><span class="symbol">3 </span>各种大小的括号，符号：\big  \Big  \bigg  \Bigg</span><br><span class="line"><span class="symbol">4 </span>自适应括号，符号：\left \right，如：$\left(x\right)$，$\left(x&#123;yz&#125;\right)$</span><br><span class="line"><span class="number">5</span>大括号，符号：\lbrace \rbrace，如：$\lbrace x \rbrace$</span><br></pre></td></tr></table></figure>
<h3 id="6-组合"><a href="#6-组合" class="headerlink" title="6.组合"></a>6.组合</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>组合公式，符号：&#123;上位公式 \choose 下位公式&#125;，如：$&#123;n+<span class="number">1</span> \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-<span class="number">1</span>&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="7-四则运算"><a href="#7-四则运算" class="headerlink" title="7.四则运算"></a>7.四则运算</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> 加法运算，符号：+，如：$<span class="symbol">x</span>+<span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">2</span> 减法运算，符号：-，如：$<span class="symbol">x</span>-<span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">3</span> 加减运算，符号：\pm，如：$<span class="symbol">x</span> \pm <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">4</span> 减甲运算，符号：\mp，如：$<span class="symbol">x</span> \mp <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">5</span> 乘法运算，符号：\times，如：$<span class="symbol">x</span> \times <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">6</span> 点乘运算，符号：\cdot，如：$<span class="symbol">x</span> \cdot <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">7</span> 星乘运算，符号：\ast，如：$<span class="symbol">x</span> \ast <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">8</span> 除法运算，符号：\<span class="keyword">div</span>，如：$<span class="symbol">x</span> \<span class="keyword">div</span> <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">9</span> 斜法运算，符号：/，如：$<span class="symbol">x</span>/<span class="symbol">y</span>=z$</span><br><span class="line"><span class="number">10</span> 分式表示，符号：\<span class="built_in">frac</span>&#123;分子&#125;&#123;分母&#125;，如：$\<span class="built_in">frac</span>&#123;<span class="symbol">x</span>+<span class="symbol">y</span>&#125;&#123;<span class="symbol">y</span>+z&#125;$</span><br><span class="line"><span class="number">11</span> 分式表示，符号：&#123;分子&#125; \voer &#123;分母&#125;，如：$&#123;<span class="symbol">x</span>+<span class="symbol">y</span>&#125; \over &#123;<span class="symbol">y</span>+z&#125;$</span><br><span class="line"><span class="number">12</span> 绝对值表示，符号：||，如：$|<span class="symbol">x</span>+<span class="symbol">y</span>|$</span><br></pre></td></tr></table></figure>
<h3 id="8-高级运算"><a href="#8-高级运算" class="headerlink" title="8.高级运算"></a>8.高级运算</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>平均数运算，符号：\overline&#123;算式&#125;，如：$\overline&#123;xyz&#125;$</span><br><span class="line"><span class="symbol">2 </span>开二次方运算，符号：\sqrt，如：$\sqrt x$</span><br><span class="line"><span class="symbol">3 </span>开方运算，符号：\sqrt[开方数]&#123;被开方数&#125;，如：$\sqrt[<span class="number">3</span>]&#123;x+y&#125;$</span><br><span class="line"><span class="symbol">4 </span>对数运算，符号：\<span class="keyword">log</span>，如：$\<span class="keyword">log</span>(x)$</span><br><span class="line"><span class="symbol">5 </span>极限运算，符号：\lim，如：$\lim^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">6 </span>极限运算，符号：\displaystyle \lim，如：$\displaystyle \lim^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">7 </span>求和运算，符号：\sum，如：$\sum^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">8 </span>求和运算，符号：\displaystyle \sum，如：$\displaystyle \sum^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">9 </span>异或运算，符号：\bigoplus，如：$x \bigoplus y$</span><br></pre></td></tr></table></figure>
<p>（好吧，蒟蒻我由于没用过积分符号，所以就。。。逃）（矩阵Markdown不知道怎么搞，所以。。。）</p>
<h3 id="9-逻辑运算"><a href="#9-逻辑运算" class="headerlink" title="9.逻辑运算"></a>9.逻辑运算</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>等于运算，符号：=，如：$x+y=z$</span><br><span class="line"><span class="symbol">2 </span>大于运算，符号：&gt;，如：$x+y&gt;z$</span><br><span class="line"><span class="symbol">3 </span>小于运算，符号：&lt;，如：$x+y&lt;z$</span><br><span class="line"><span class="symbol">4 </span>大于等于运算，符号：\geq，如：$x+y \geq z$</span><br><span class="line"><span class="symbol">5 </span>小于等于运算，符号：\leq，如：$x+y \leq z$</span><br><span class="line"><span class="symbol">6 </span>不等于运算，符号：\neq，如：$x+y \neq z$</span><br><span class="line"><span class="symbol">7 </span>约等于运算，符号：\approx，如：$x+y \approx z$</span><br><span class="line"><span class="symbol">8 </span>恒定等于运算，符号：\equiv，如：$x+y \equiv z$</span><br></pre></td></tr></table></figure>
<h3 id="10-集合运算"><a href="#10-集合运算" class="headerlink" title="10.集合运算"></a>10.集合运算</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> 1 属于运算，符号：<span class="tag">\<span class="name">in</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">in</span></span> y$</span></span><br><span class="line"> 2 不属于运算，符号：<span class="tag">\<span class="name">notin</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">notin</span></span> y$</span></span><br><span class="line"> 3 不属于运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">in</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">in</span></span> y$</span></span><br><span class="line"> 4 子集运算，符号：<span class="tag">\<span class="name">subset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subset</span></span> y$</span></span><br><span class="line"> 5 子集运算，符号：<span class="tag">\<span class="name">supset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supset</span></span> y$</span></span><br><span class="line"> 6 真子集运算，符号：<span class="tag">\<span class="name">subseteq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subseteq</span></span> y$</span></span><br><span class="line"> 7 非真子集运算，符号：<span class="tag">\<span class="name">subsetneq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subsetneq</span></span> y$</span></span><br><span class="line"> 8 真子集运算，符号：<span class="tag">\<span class="name">supseteq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supseteq</span></span> y$</span></span><br><span class="line"> 9 非真子集运算，符号：<span class="tag">\<span class="name">supsetneq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supsetneq</span></span> y$</span></span><br><span class="line">10 非子集运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">subset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">subset</span></span> y$</span></span><br><span class="line">11 非子集运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">supset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">supset</span></span> y$</span></span><br><span class="line">12 并集运算，符号：<span class="tag">\<span class="name">cup</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">cup</span></span> y$</span></span><br><span class="line">13 交集运算，符号：<span class="tag">\<span class="name">cap</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">cap</span></span> y$</span></span><br><span class="line">14 实数集合，符号：<span class="tag">\<span class="name">mathbb</span><span class="string">&#123;R&#125;</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;R&#125;</span></span> $</span></span><br><span class="line">15 自然数集合，符号：<span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Z&#125;</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Z&#125;</span></span> $</span></span><br><span class="line">16 空集，符号：<span class="tag">\<span class="name">emptyset</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">emptyset</span></span> $</span></span><br></pre></td></tr></table></figure>
<p>（至于差集那些的没听说过。。。）</p>
<h3 id="11-数学符号"><a href="#11-数学符号" class="headerlink" title="11.数学符号"></a>11.数学符号</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> 1 无穷，符号：<span class="tag">\<span class="name">infty</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">infty</span></span>$</span></span><br><span class="line"> 2 虚数，符号：<span class="tag">\<span class="name">imath</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">imath</span></span>$</span></span><br><span class="line"> 3 虚数，符号：<span class="tag">\<span class="name">jmath</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">jmath</span></span>$</span></span><br><span class="line"> 4 矢量符号，符号<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span>$</span></span><br><span class="line"> 5 上箭头，符号：<span class="tag">\<span class="name">uparrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">uparrow</span></span>$</span></span><br><span class="line"> 6 上箭头，符号：<span class="tag">\<span class="name">Uparrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Uparrow</span></span>$</span></span><br><span class="line"> 7 下箭头，符号：<span class="tag">\<span class="name">downarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">downarrow</span></span>$</span></span><br><span class="line"> 8 下箭头，符号：<span class="tag">\<span class="name">Downarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Downarrow</span></span>$</span></span><br><span class="line"> 9 左箭头，符号：<span class="tag">\<span class="name">leftarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span></span><br><span class="line">10 左箭头，符号：<span class="tag">\<span class="name">Leftarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Leftarrow</span></span>$</span></span><br><span class="line">11 右箭头，符号：<span class="tag">\<span class="name">rightarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">rightarrow</span></span>$</span></span><br><span class="line">12 右箭头，符号：<span class="tag">\<span class="name">Rightarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Rightarrow</span></span>$</span></span><br><span class="line">13 底端对齐的省略号，符号：<span class="tag">\<span class="name">ldots</span></span>，如：<span class="formula">$1,2,<span class="tag">\<span class="name">ldots</span></span>,n$</span></span><br><span class="line">14 中线对齐的省略号，符号：<span class="tag">\<span class="name">cdots</span></span>，如：<span class="formula">$x_1^2 + x_2^2 + <span class="tag">\<span class="name">cdots</span></span> + x_n^2$</span></span><br><span class="line">15 竖直对齐的省略号，符号：<span class="tag">\<span class="name">vdots</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">vdots</span></span>$</span></span><br><span class="line">16 斜对齐的省略号，符号：<span class="tag">\<span class="name">ddots</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">ddots</span></span>$</span></span><br></pre></td></tr></table></figure>
<h3 id="12-希腊字母"><a href="#12-希腊字母" class="headerlink" title="12.希腊字母"></a>12.希腊字母</h3><p><img src="https://img2020.cnblogs.com/blog/1878283/202005/1878283-20200501152621630-307438483.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">HERE</a></p>
<p>2.<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">HERE</a></p>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>memset处理</title>
    <url>/articles/memset%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="memset处理"><a href="#memset处理" class="headerlink" title="memset处理"></a>memset处理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇主要是方便到时候忘了<strong>memset初始化赋值形式</strong>时参考一下</p>
<h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><p>memset赋值时时赋的<strong>ASCLL码</strong>转化为的<strong>二进制</strong></p>
<p>比如：memset(,0xff,sizeof())，0xff转化为二进制为11111111，int为4Byte所以最后为11111111111111111111111111111111为-1。(化为<strong>二进制补位</strong>，然后再赋值)。</p>
<h2 id="部分常用"><a href="#部分常用" class="headerlink" title="部分常用"></a>部分常用</h2><h3 id="int-amp-long-long"><a href="#int-amp-long-long" class="headerlink" title="int &amp; long long"></a>int &amp; long long</h3><p><strong>最大值</strong>：memset(New,0x7F,sizeof(New)) //将New中的值全部赋为<strong>2139062143</strong></p>
<p><strong>较大值</strong>：memset(New,0x3F,sizeof(New)) //这种赋值可以进行加操作并<strong>不会溢出</strong></p>
<p><strong>最小值</strong>：memest(New,0x80,sizeof(New)) //设置New为<strong>-2139062144</strong></p>
<h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p><strong>最大值</strong>：memset(New,0x7F,sizeof(New)) //全部赋值为<strong>1.38242e+306</strong></p>
<p><strong>最小值</strong>：memset(New,0xFE,sizeof(New)) //全部赋值为<strong>-5.31401e+303</strong></p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>几何反演</title>
    <url>/articles/%E5%87%A0%E4%BD%95%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="几何反演"><a href="#几何反演" class="headerlink" title="几何反演"></a>几何反演</h1><p>吐槽一句：<strong>几何反演</strong>比<strong>莫比乌斯反演</strong>简单多了，只是比较<strong>巧妙</strong>，一般会想不到。。。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>反演变换适用于题目中存在多个<strong>圆/直线</strong>之间的<strong>相切关系</strong>的情况。利用反演变换的性质，在反演空间求解问题，可以大幅<strong>简化计算</strong>。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定<strong>反演中心</strong>$O$和<strong>反演半径</strong>$R$</p>
<p>若平面上$P$和$P^{‘}$满足：</p>
<ul>
<li><p>点$P^{‘}$在<strong>射线</strong>$ \vec{OP} $上</p>
</li>
<li><p>$ |OP| \cdot |OP^{‘}|=R^2 $    </p>
</li>
</ul>
<p>那么称点$P$和点$P^{‘}$互为<strong>反演点</strong></p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/08/13/mlxR6uPQkOBjCgf.png" alt="几何反演-1.png"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>温馨提示</strong>:为了方便您的阅读,以下内容我们规定:</p>
<p>$\color{red}红色$代表<strong>原图形</strong></p>
<p>$ \color{orange}橙色$代表<strong>反演图形</strong></p>
<p>$ \color{blue}蓝色$代表<strong>反演中心以及反演半径所组成的圆</strong></p>
<p><em>　在<strong>圆上</strong>的点反演点为<em>*自身</em></em>(<del>颜色不好标…问题不大</del>)</p>
<p><img src="https://i.loli.net/2020/08/13/Cyk2QnKVrLZO5MS.png" alt="几何反演-2.png"></p>
<p><em>　<strong>圆$O$外</strong>的点的反演点在<strong>圆内</strong>，<em>*反之亦然</em></em> </p>
<p><img src="https://i.loli.net/2020/08/13/9WTNOsxf4kIdSn2.png" alt="几何反演-3.png"></p>
<ul>
<li><strong>过点$O$</strong>的圆$A$,<strong>反演图形</strong>为过其<strong>交点</strong>的<strong>不过$O$</strong>的<strong>直线</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/08/13/NaienwoscM81xyC.png" alt="几何反演-4.png"></p>
<p><em>　两个图形<strong>相切</strong>，那么他们的<strong>反演图形</strong>也<em>*相切</em></em></p>
<p><img src="https://i.loli.net/2020/08/13/UijqXEP15Y47Rwk.png" alt="几何反演-5.png"></p>
<p><img src="https://i.loli.net/2020/08/13/5EvMpfJUzOnlcqS.png" alt="几何反演-6.png"></p>
<p><img src="https://i.loli.net/2020/08/13/kTQpE3qIvsHcBAZ.png" alt="几何反演-7.png"></p>
<h2 id="二级结论"><a href="#二级结论" class="headerlink" title="二级结论"></a>二级结论</h2><ul>
<li>记圆$A$半径为$r_1$,其反演图形圆$B$半径为$r_2$,则有:</li>
</ul>
<script type="math/tex; mode=display">
r_2= \frac{1}{2} \left( \frac{1}{|OA|-r_1}- \frac{1}{|OA|+r_1} \right)  R_2 \\
\Rightarrow r_2= \frac{r_1}{|OA|^2-r^2_1}R^2</script><p>当然证明的话…真的就是有手就行(<del>口胡</del>)</p>
<p>*　记$O$坐标为$(x_0,y_0)$,点$A$坐标为$ (x_1,y_1 )$,点$B$坐标为$ (x_2,y_2) $,则有:</p>
<script type="math/tex; mode=display">
x_2=x_0+ \frac{|OB|}{|OA|} (x_1-x_0)\\
y_2=y_0+ \frac{|OB|}{|OA|} (y_1-y_0)</script>]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>复数基操</title>
    <url>/articles/%E5%A4%8D%E6%95%B0%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复数基操"><a href="#复数基操" class="headerlink" title="复数基操"></a>复数基操</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们在解<strong>多次方程</strong>时，总会遇到类似$ x^2+1=0 $的情况，我们会说这个方程<strong>没有实数解</strong>，那么，既然只是没有实数解，有的是什么解呢。。。</p>
<p>这个时候我们可以强行给他来一个解—$i$，那么这个方程就有一个解$x=i$了</p>
<p>但光有这个解没有什么用，所以我们需要给他找<strong>一些性质和是加一些运算</strong></p>
<p>类似于实数的表示方式，我们可以将这种形式的数表示为$ a+bi $，当然$a$和$b$都是<strong>实数</strong>，那么他是否满足运算性质呢？</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>因为我们将复数定义的<strong>代数形式</strong>为$ a+bi\,\,\,a,b \in \real $，其中$i$为虚数单位，<strong>全体复数</strong>的集合为<strong>复数集</strong>，其中$a$为复数$z$的<strong>实部</strong>，$b$为$z$的<strong>虚部</strong></p>
<p>我们发现，当$b=0$时，$ z \in \real $，当$b \neq 0$时，$ z \notin \real $</p>
<p>那么我们可以发一张图来表示<strong>所有数的关系</strong></p>
<p><img src="https://i.loli.net/2020/08/14/weq5AgtzWcysBDi.png" alt="复数基操-1.png"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><strong>几何意义</strong>：实数与$x$轴上的点一一对应，复数与<strong>坐标系</strong>上的点一一对应，比如：$ z=a+bi $表示为$ (a,b) $</li>
<li><strong>复数相等</strong>：对于$z_1=a_1+b_1i,z_2=a_2+b_2i<strong>$当且仅当</strong>$ a_1=a_2,b_1=b_2 $</li>
<li><p><strong>几何意义</strong>：复数集与复平面内的<strong>向量集合</strong>一一对应(实数<strong>0与零向量</strong>对应)，$ z=a+bi \Leftrightarrow (a,b) \Leftrightarrow \vec{OZ}  $</p>
</li>
<li><p><strong>复数的模</strong>：对于复数$ z=a+bi $的<strong>模</strong>$ |z|= \sqrt{a^2+b^2} $</p>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h3><p>很明显对于$ z_1=a_1+b_1i,z_2=a_2+b_2i $满足$ z_1+z_2=a_1+a_2+(b_1+b_2)i $同样可以验证出满足<strong>加法和减法的交换律和结合律</strong></p>
<script type="math/tex; mode=display">
z_1+z_2=z_2+z_1 \\
(z_1+z_2)+z_3=z_1+(z_2+z_3)</script><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>和<strong>向量</strong>一样</p>
<p><img src="https://i.loli.net/2020/08/14/aiuIlQA6XchZWUS.png" alt="复数基操-2.png"></p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>首先由常识可以知道满足<strong>交换律，结合律以及分配律</strong>，且由于其和实数的表示有关，复数域也满足所有<strong>乘法公式</strong></p>
<script type="math/tex; mode=display">
z_1z_2=z_2z_1 \\
(z_1z_2)z_3=z_1(z_2z_3) \\
z_1(z_2+z_3)=z_1z_2+z_1z_3</script><h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p>两个复数<strong>相乘</strong>，在复平面上表示为两个向量<strong>模长相乘</strong>，<strong>辐角相加</strong></p>
<p><img src="https://i.loli.net/2020/08/14/r9Zzhgp1mijykJe.png" alt="复数基操-3.png"></p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>乘法和除法可以<strong>互相转化</strong>，对于$ z_1=a_1+b_1i,z_2=a_2+b_2i $</p>
<script type="math/tex; mode=display">
\frac{a_1+b_1i}{a_1+b_2i}= \frac{(a_1+b_1i)(a_2-b_2i)}{(a_2+b_2i)(a_2-b_2i)}= \frac{a_1a_2+b_1b_2}{a_2^2+b_2^2}+ \frac{b_1a_2-a_1b_2}{a_2^2+b_2^2}(a_2+b_2i \neq 0)</script><h3 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h3><p>我们定义，当两个虚数<strong>实部相等</strong>，<strong>虚部互为相反数</strong>时，这两个复数互为<strong>共轭复数</strong> 。通常记$ z=a+bi $的共轭复数为$ \bar{z}=a-bi $。我们可以发现，两个复数<strong>互为共轭复数</strong>，那么它们 关于<strong>实轴对称</strong>,如图$z_1$和$z_2$互为共轭</p>
<h4 id="几何意义-2"><a href="#几何意义-2" class="headerlink" title="几何意义"></a>几何意义</h4><p><img src="https://i.loli.net/2020/08/14/BTWUp3gPy4Svti2.png" alt="复数基操-4.png"></p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>吉司机线段树</title>
    <url>/articles/%E5%90%89%E5%8F%B8%E6%9C%BA%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="吉司机线段树"><a href="#吉司机线段树" class="headerlink" title="吉司机线段树"></a>吉司机线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>吉老师niubility！！！</strong></p>
<p>关于<strong>吉司机线段树</strong>是吉老师在<strong>2016年国家集训队论文</strong>中提到的一种处理方式—<strong>区间最值操作 &amp; 历史区间最值</strong></p>
<h2 id="区间最值操作"><a href="#区间最值操作" class="headerlink" title="区间最值操作"></a>区间最值操作</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>将$ [l,r] $的数全部对$x$取<strong>max或min</strong>，即$a_i=max(a_i,x)$或者$ a_i=min(a_i,x) $</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们以区间取min为一个示例</p>
<p>区间取min以为着大于$t$的数需要被更改，因此这个操作不是整个区间，而是区间中<strong>大于$t$的数</strong></p>
<p>于是，我们可以维护<strong>区间最大值</strong>$Max$，<strong>次大值</strong>$Sec$，<strong>区间和</strong>$Sum$以及<strong>最大值的个数</strong>$Cnt$</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li>如果$ Max \leq t $，显然这个$t$是没有意义的，<strong>直接返回</strong>；</li>
<li>如果$ Sec &lt; t \leq Max $ ，那么这个$t$就能更新当前<strong>区间中的最大值</strong>。于是我们让区间和加上$ Cnt(t-Max) $，然后更新$Max$为$t$ ，并打一个标记。</li>
<li>如果$ t \leq Sec $，那么这时你发现你不知道有多少个数涉及到更新的问题。于是我们的策略就是，<strong>暴力递归</strong>向下操作。然后上传信息。</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>使用<strong>势能分析</strong>可以得到复杂度为$ O(mlogn) $</p>
<p>我也不知道咋整，具体分析过程见<strong>论文</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306" target="_blank" rel="noopener">HDU5306 Gorgeous Sequence</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HDU 5306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Max[MAXN&lt;&lt;<span class="number">2</span>],Sum[MAXN&lt;&lt;<span class="number">2</span>],Tag[MAXN&lt;&lt;<span class="number">2</span>],Sec[MAXN&lt;&lt;<span class="number">2</span>],Cnt[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">LL Test,Total,<span class="built_in">Task</span>,Opt,u,v,w;</span><br><span class="line">LL Num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Sum[X]=Sum[Lson]+Sum[Rson];</span><br><span class="line">    <span class="keyword">if</span>(Max[Lson]==Max[Rson]) &#123;</span><br><span class="line">        Max[X]=Max[Lson];</span><br><span class="line">        Cnt[X]=Cnt[Lson]+Cnt[Rson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Lson],Sec[Rson]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Max[Lson]&gt;Max[Rson]) &#123;</span><br><span class="line">        Max[X]=Max[Lson];</span><br><span class="line">        Cnt[X]=Cnt[Lson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Lson],Max[Rson]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Max[X]=Max[Rson];</span><br><span class="line">        Cnt[X]=Cnt[Rson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Rson],Max[Lson]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Tag[X]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123; </span><br><span class="line">        Max[X]=Sum[X]=Num[L]; </span><br><span class="line">        Cnt[X]=<span class="number">1</span>; Sec[X]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tag[X]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Max[Lson]&gt;Tag[X]) &#123; Tag[Lson]=Tag[X]; Sum[Lson]-=Cnt[Lson]*(Max[Lson]-Tag[X]); Max[Lson]=Tag[X]; &#125;</span><br><span class="line">        <span class="keyword">if</span>(Max[Rson]&gt;Tag[X]) &#123; Tag[Rson]=Tag[X]; Sum[Rson]-=Cnt[Rson]*(Max[Rson]-Tag[X]); Max[Rson]=Tag[X]; &#125;</span><br><span class="line">        Tag[X]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Max[X]&lt;=Temp) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To &amp;&amp; Sec[X]&lt;Temp) &#123;</span><br><span class="line">        Tag[X]=Temp; </span><br><span class="line">        Sum[X]-=Cnt[X]*(Max[X]-Temp);</span><br><span class="line">        Max[X]=Temp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Update(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Update(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_MAX</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Max[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_SUM</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Sum[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res+=Get_SUM(Lson,L,Mid,From,To); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res+=Get_SUM(Rson,Mid+<span class="number">1</span>,R,From,To); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;<span class="built_in">Task</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Task</span>--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Test);</span><br><span class="line">        FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]); &#125;</span><br><span class="line">        Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">        <span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Opt,&amp;u,&amp;v);</span><br><span class="line">            <span class="keyword">if</span>(Opt==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;w);</span><br><span class="line">                Update(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_MAX(<span class="number">1</span>,<span class="number">1</span>,Total,u,v));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_SUM(<span class="number">1</span>,<span class="number">1</span>,Total,u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">  <span class="comment">//  system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="历史最值问题"><a href="#历史最值问题" class="headerlink" title="历史最值问题"></a>历史最值问题</h2><h3 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h3><p>历史最值<strong>不等于可持久化</strong></p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>我们这次以最大值max来举例</p>
<p>简单地说，一个位置的历史最大值就是当前位置下<strong>曾经出现过的数的最大值</strong>。形式化地定义，我们定义一个辅助数组$B$，一开始与$A$完全相同。在$A$的每次操作后，我们对整个数组取max：</p>
<script type="math/tex; mode=display">
\forall i \in [1,n],B_i=max(B_i,A_i)</script><p>这时我们将$B_i$称为这个位置的<strong>历史最大值</strong></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><a href="https://www.luogu.com.cn/problem/P4314" target="_blank" rel="noopener">P4314 CPU监控</a></p>
<p>可能会想，不就是一个历史最大值吗，直接每次Tag标记加上去的时候取一个max就可以了，然而并不是这样的，有一个问题需要一些技巧</p>
<p>若果你像我上边所说的做了，并且实现了代码，这儿有一个<strong>Hack数据</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">P <span class="number">1</span> <span class="number">8</span> <span class="number">100</span></span><br><span class="line">P <span class="number">1</span> <span class="number">8</span> <span class="number">-10</span></span><br><span class="line">A <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>显然答案是110，而你会输出100，这是因为标记在减小之前没有取一个最大值，所以会错</p>
<p>所以，我们还需要给每一个节点记录<strong>历史最大Tag标记</strong></p>
<p>同理，还要记录<strong>历史最大覆盖标记</strong></p>
<p>所以重要的就是如何<strong>push_down</strong></p>
<h3 id="重点分析"><a href="#重点分析" class="headerlink" title="重点分析"></a>重点分析</h3><p>pushdown的时候重点是要<strong>分类讨论</strong>：之前是否被覆盖过，即由 Cov 标记决定</p>
<p>先讲覆盖的时候：（要传 d 和 hd ,表示用于更新的当前覆盖值和用于更新的历史覆盖最大值）</p>
<ul>
<li>如果Cov为<strong>true</strong>：用Hd更新Hcov，取max</li>
<li>如果Cov为<strong>false</strong>：Cov变为true，Hcov变为hd</li>
</ul>
<p>此外还要更新<strong>历史最大值Hmx</strong>，(和Hd取max)</p>
<p>加法的时候更复杂一些：d 和 Hd 的含义同理</p>
<ul>
<li>如果Cov为<strong>true</strong>：说明之前被覆盖过了，此时相当于用d+Cov进行Cover即可</li>
<li>如果Cov为<strong>false</strong>：此时只有加法，用Max+Hd和add+Hd<strong>分别更新</strong>Hmx和Had,并更新Max和add标记 (把Max和add加上d)</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Tag1[MAXN&lt;&lt;<span class="number">2</span>],Tag2[MAXN&lt;&lt;<span class="number">2</span>],Max[MAXN&lt;&lt;<span class="number">2</span>],Pre[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">LL Total,Test,u,v,w,Num[MAXN];</span><br><span class="line"><span class="keyword">char</span> Opt;</span><br><span class="line">LL HTag1[MAXN&lt;&lt;<span class="number">2</span>],HTag2[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL Temp=<span class="number">0</span>,Fac=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> Ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(Ch&lt;<span class="string">'0'</span> || Ch&gt;<span class="string">'9'</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span>(Ch==<span class="string">'-'</span>) &#123; Fac=<span class="number">-1</span>; &#125; </span><br><span class="line">		Ch=getchar(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(Ch&gt;=<span class="string">'0'</span> &amp;&amp; Ch&lt;=<span class="string">'9'</span>) &#123; </span><br><span class="line">		Temp=(Temp&lt;&lt;<span class="number">1</span>)+(Temp&lt;&lt;<span class="number">3</span>)+Ch-<span class="string">'0'</span>; </span><br><span class="line">		Ch=getchar(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> Fac*Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Max[X]=<span class="built_in">max</span>(Max[Lson],Max[Rson]);</span><br><span class="line">    Pre[X]=<span class="built_in">max</span>(Pre[Lson],Pre[Rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chg</span><span class="params">(LL X,LL v,LL hv)</span> </span>&#123;</span><br><span class="line">	Max[X]=v;</span><br><span class="line">	Pre[X]=<span class="built_in">max</span>(Pre[X],hv);</span><br><span class="line">	Tag2[X]=v;</span><br><span class="line">	HTag2[X]=<span class="built_in">max</span>(HTag2[X],hv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL X,LL v,LL hv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Tag2[X]!=INF) <span class="keyword">return</span> chg(X,Tag2[X]+v,Tag2[X]+hv);</span><br><span class="line">	HTag1[X]=<span class="built_in">max</span>(HTag1[X],hv+Tag1[X]);</span><br><span class="line">	Tag1[X]+=v;</span><br><span class="line">	Max[X]+=v;</span><br><span class="line">	Pre[X]=<span class="built_in">max</span>(Pre[X],Max[X]-Tag1[X]+HTag1[X]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X)</span></span>&#123;</span><br><span class="line">	add(Lson,Tag1[X],HTag1[X]);</span><br><span class="line">	add(Rson,Tag1[X],HTag1[X]);</span><br><span class="line">	Tag1[X]=HTag1[X]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Tag2[X]!=INF)&#123;</span><br><span class="line">		chg(Lson,Tag2[X],HTag2[X]);</span><br><span class="line">		chg(Rson,Tag2[X],HTag2[X]);</span><br><span class="line">		Tag2[X]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	Tag2[X]=INF;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123;</span><br><span class="line">        Pre[X]=Max[X]=Num[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(Tag2[X]!=INF) &#123;</span><br><span class="line">    		Max[X]=Tag2[X]+Temp;</span><br><span class="line">			Pre[X]=<span class="built_in">max</span>(Pre[X],<span class="built_in">max</span>(Tag2[X]+Temp,Tag2[X]));</span><br><span class="line">			Tag2[X]+=Temp;</span><br><span class="line">			HTag2[X]=<span class="built_in">max</span>(HTag2[X],<span class="built_in">max</span>(Tag2[X],Tag2[X]+Temp));</span><br><span class="line">    		<span class="keyword">return</span>;	</span><br><span class="line">    	&#125;</span><br><span class="line">    	HTag1[X]=<span class="built_in">max</span>(HTag1[X],<span class="built_in">max</span>(Tag1[X],Tag1[X]+Temp));</span><br><span class="line">    	Tag1[X]+=Temp;</span><br><span class="line">    	Max[X]+=Temp;</span><br><span class="line">    	Pre[X]=<span class="built_in">max</span>(Pre[X],Max[X]-Tag1[X]+HTag1[X]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Add(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Add(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">        Max[X]=Temp;</span><br><span class="line">        Pre[X]=<span class="built_in">max</span>(Pre[X],Temp);</span><br><span class="line">        Tag2[X]=Temp;</span><br><span class="line">        HTag2[X]=<span class="built_in">max</span>(HTag2[X],Temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Change(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Change(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_MAX</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp;  R&lt;=To) &#123; <span class="keyword">return</span> Max[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=-INF;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_PRE</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Pre[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=-INF;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_PRE(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_PRE(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Debug</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"X:"</span>&lt;&lt;X&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"L:"</span>&lt;&lt;L&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"R:"</span>&lt;&lt;R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Tag1:"</span>&lt;&lt;Tag1[X]&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"Tag2:"</span>&lt;&lt;Tag2[X]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Max:"</span>&lt;&lt;Max[X]&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"Pre:"</span>&lt;&lt;Pre[X]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Debug(Lson,L,Mid); Debug(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    Total=Read();</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; Num[i]=Read(); &#125;</span><br><span class="line">    Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">    Test=Read();</span><br><span class="line">    <span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		Opt=getchar();</span><br><span class="line">        u=Read(); v=Read();</span><br><span class="line"><span class="comment">//    	printf("%c %lld %lld\n",Opt,u,v);</span></span><br><span class="line">        <span class="keyword">if</span>(Opt==<span class="string">'Q'</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_MAX(<span class="number">1</span>,<span class="number">1</span>,Total,u,v)); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'A'</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_PRE(<span class="number">1</span>,<span class="number">1</span>,Total,u,v)); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'P'</span>) &#123; w=Read(); Add(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'C'</span>) &#123; w=Read(); Change(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w); &#125;</span><br><span class="line"><span class="comment">//        Debug(1,1,Total);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/articles/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><script type="math/tex; mode=display">
T(n)= \begin{cases} \Theta(n^{log_b a}) & f(n)=O(n^{log_b a- \epsilon}) \\
\Theta(f(n)) & f(n)= \Omega(n^{log_b a+ \epsilon}) \\
\Theta(n^{log_b a}log^{k+1} n) & f(n)= \Theta(n^{log_b a}log^k n),k \geq 0 \end{cases}</script><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>势能分析</strong>，是一种求<strong>均摊复杂度下界</strong>的方法。 求均摊复杂度，关键是表达出<strong>先前操作</strong>对<strong>当前操作</strong>的影响。势能分析用一个<strong>函数</strong>来表达此种影响。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>定义“状态”$S$：即<strong>某一时刻</strong>的<strong>所有数据</strong>。在快排的例子中，一个“状态”就是当前过程需要排序的下标区间</p>
<p>定义“初始状态”$S_0$：即<strong>未进行任何操作</strong>时的状态。在快排的例子中，“初始状态”就是整个数组</p>
<p>假设存在<strong>从状态到数</strong>的函数$F$，且对于<strong>任何状态</strong>$S$，$F(S) \geq F(S_0)$ ，则有以下推论：</p>
<p>设$ S_1,S_2, \cdots ,S_m $为从$S_0$开始连续做$m$次操作所得的状态序列，$c_i$为第$i$次操作的时间开销。</p>
<p>记$ p<em>i=c_i+F(S_i)-F(S</em>{i-1}) $，则$m$次操作的<strong>总时间花销</strong>为</p>
<script type="math/tex; mode=display">
\sum^m_{i=1}p_i+F(S_0)-F(S_m)</script><p>又因为$ F(S) \geq F(S_0) $，所以有</p>
<script type="math/tex; mode=display">
\sum^m_{i=1}p_i \geq \sum^m_{i=1}c_i</script><p>因此，若$ p_i=O(T(n)) $，则$ O(T(n)) $时<strong>均摊复杂度的一个上界</strong></p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>字符及字符串的处理</title>
    <url>/articles/%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符及字符串的处理"><a href="#字符及字符串的处理" class="headerlink" title="字符及字符串的处理"></a>字符及字符串的处理</h1><h3 id="By-DeNeRATe—2020-08-04"><a href="#By-DeNeRATe—2020-08-04" class="headerlink" title="By DeNeRATe—2020.08.04"></a>By DeNeRATe—2020.08.04</h3><h3 id="前言简介"><a href="#前言简介" class="headerlink" title="前言简介"></a>前言简介</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>字符串</strong>，就是由<strong>字符</strong>连接而成的<strong>序列</strong>。  </p>
<h4 id="程序定义"><a href="#程序定义" class="headerlink" title="程序定义"></a>程序定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>‘a’ 和 “a”的区别（对于字符单引号和双引号的区别）</p>
<p>单引号’a’表示单个字符，在其中必须且只能有一个字符。<br>双引号”a”表示字符串，字符串是由若干个字符组成的。<br>字符是组成字符串的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"DC is extremely niubility"</span><span class="comment">//这个双引号之间的就是一个字符串，以一个整体</span></span><br><span class="line"><span class="string">'W'</span><span class="comment">//单引号之间的就只是一个字符，不可包含多个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="常见的字符串问题"><a href="#常见的字符串问题" class="headerlink" title="常见的字符串问题"></a>常见的字符串问题</h4><h5 id="1-字符串匹配问题"><a href="#1-字符串匹配问题" class="headerlink" title="1.字符串匹配问题"></a>1.字符串匹配问题</h5><h5 id="2-子串相关问题"><a href="#2-子串相关问题" class="headerlink" title="2.子串相关问题"></a>2.子串相关问题</h5><h5 id="3-前缀-后缀相关问题"><a href="#3-前缀-后缀相关问题" class="headerlink" title="3.前缀/后缀相关问题"></a>3.前缀/后缀相关问题</h5><h5 id="4-回文串相关问题"><a href="#4-回文串相关问题" class="headerlink" title="4.回文串相关问题"></a>4.回文串相关问题</h5><h5 id="5-子序列相关问题"><a href="#5-子序列相关问题" class="headerlink" title="5.子序列相关问题"></a>5.子序列相关问题</h5><h5 id="6-ELSE"><a href="#6-ELSE" class="headerlink" title="6.ELSE"></a>6.ELSE</h5><h3 id="关于字符—ASCLL码"><a href="#关于字符—ASCLL码" class="headerlink" title="关于字符—ASCLL码"></a>关于字符—ASCLL码</h3><blockquote>
<p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于<a href="https://baike.baidu.com/item/拉丁字母/1936851" target="_blank" rel="noopener">拉丁字母</a>的一套电脑<a href="https://baike.baidu.com/item/编码/80092" target="_blank" rel="noopener">编码</a>系统，主要用于显示现代<a href="https://baike.baidu.com/item/英语/109997" target="_blank" rel="noopener">英语</a>和其他<a href="https://baike.baidu.com/item/西欧/3028649" target="_blank" rel="noopener">西欧</a>语言。它是最通用的信息交换标准，并等同于<a href="https://baike.baidu.com/item/国际" target="_blank" rel="noopener">国际</a>标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符</p>
<p>ASCII 码使用指定的7 位或8 位<a href="https://baike.baidu.com/item/二进制数" target="_blank" rel="noopener">二进制数</a>组合来表示128 或256 种可能的<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>。标准ASCII 码也叫基础ASCII码，使用7 位<a href="https://baike.baidu.com/item/二进制数" target="_blank" rel="noopener">二进制数</a>（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊<a href="https://baike.baidu.com/item/控制字符" target="_blank" rel="noopener">控制字符</a>  。其中：</p>
<p><strong>0～31及127(共33个)是<a href="https://baike.baidu.com/item/控制字符" target="_blank" rel="noopener">控制字符</a>或通信专用字符（其余为可显示字符），</strong>如控制符：LF（换行）、CR（<a href="https://baike.baidu.com/item/回车" target="_blank" rel="noopener">回车</a>）、FF（换页）、DEL（<a href="https://baike.baidu.com/item/删除/13020275" target="_blank" rel="noopener">删除</a>）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为<a href="https://baike.baidu.com/item/退格" target="_blank" rel="noopener">退格</a>、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对<a href="https://baike.baidu.com/item/文本" target="_blank" rel="noopener">文本</a>显示有不同的影响 。</p>
<p>32～126(共95个)是<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>(32是空格），其中48～57为0到9十个阿拉伯数字。</p>
<p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p>同时还要注意，在标准ASCII中，其最高位(b7)用作<a href="https://baike.baidu.com/item/奇偶校验位" target="_blank" rel="noopener">奇偶校验位</a>。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分<a href="https://baike.baidu.com/item/奇校验" target="_blank" rel="noopener">奇校验</a>和偶校验两种。<a href="https://baike.baidu.com/item/奇校验" target="_blank" rel="noopener">奇校验</a>规定：正确的代码一个<a href="https://baike.baidu.com/item/字节" target="_blank" rel="noopener">字节</a>中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是<a href="https://baike.baidu.com/item/偶数" target="_blank" rel="noopener">偶数</a>，若非偶数，则在最高位b7添1 。</p>
<p>后128个称为<a href="https://baike.baidu.com/item/扩展ASCII" target="_blank" rel="noopener">扩展ASCII</a>码。许多基于<a href="https://baike.baidu.com/item/x86" target="_blank" rel="noopener">x86</a>的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号</p>
</blockquote>
<h4 id="如何打印ASCLL码"><a href="#如何打印ASCLL码" class="headerlink" title="如何打印ASCLL码"></a>如何打印ASCLL码</h4><h4 id="1-gt-直接查表-HERE-I-AM"><a href="#1-gt-直接查表-HERE-I-AM" class="headerlink" title="1&gt; 直接查表 HERE I AM"></a>1&gt; 直接查表 <a href="http://ascii.911cha.com/" target="_blank" rel="noopener">HERE I AM</a></h4><h4 id="2-gt-使用强制转换将int型转换为char型"><a href="#2-gt-使用强制转换将int型转换为char型" class="headerlink" title="2&gt; 使用强制转换将int型转换为char型"></a>2&gt; 使用强制转换将int型转换为char型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">128</span>;i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d的ASCLL码为:%c\n"</span>,(<span class="keyword">char</span>)i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h3><h4 id="1-流输入输出—cin-cout"><a href="#1-流输入输出—cin-cout" class="headerlink" title="1.流输入输出—cin,cout"></a>1.流输入输出—cin,cout</h4><p>cin会从流中取数据，<strong>遇到空格或者换行符都会停止所以不适合读数据串</strong>。一般用来取单个变量的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;//所需头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="comment">//空格或换行停止一个字符的输入</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="string">"b"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-gt-输入1"><a href="#1-gt-输入1" class="headerlink" title="1&gt;输入1"></a>1&gt;输入1</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span>(回车)</span><br></pre></td></tr></table></figure>
<p>第一种输入会把换行符之前，即“<strong>2+空格+3+\n</strong>”的数据都存入缓冲区。程序执行到cin&gt;&gt;a，去缓冲区取数据，碰到空格停止，所以就取走了一个2赋给了a，然后继续执行cin&gt;&gt;b，此时<strong>缓冲区如果还残留数据，程序会从缓冲区取数据而不是要求用户输入</strong>，所以重复相同的步骤取走了剩余的3。最后，<strong>留下一个换行符在缓冲区内</strong>。</p>
<h5 id="2-gt-输入2"><a href="#2-gt-输入2" class="headerlink" title="2&gt;输入2"></a>2&gt;输入2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>(回车)</span><br><span class="line"><span class="number">3</span>(回车)</span><br></pre></td></tr></table></figure>
<p>此类即可类比推理</p>
<h4 id="2-getchar-putchar的输入输出"><a href="#2-getchar-putchar的输入输出" class="headerlink" title="2.getchar,putchar的输入输出"></a>2.getchar,putchar的输入输出</h4><p>getchar()与putchar(）<strong>不会忽略任何一个字符</strong>，包括换行 ，tab，enter在内。</p>
<p>这就使得我们在写程序时，可以使用这一性质，比如：快读，快写等常规操作</p>
<p>若我输入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">abcd efgh</span><br></pre></td></tr></table></figure>
<p>则：</p>
<p>我们分别接收到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">' '</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span></span><br></pre></td></tr></table></figure>
<h4 id="3-scanf-printf格式化输入输出"><a href="#3-scanf-printf格式化输入输出" class="headerlink" title="3.scanf,printf格式化输入输出"></a>3.scanf,printf格式化输入输出</h4><p>一般会用到的：”%\c”,”%\s”此两种方式</p>
<h5 id="1-gt-”-c”"><a href="#1-gt-”-c”" class="headerlink" title="1&gt;”%\c”"></a>1&gt;”%\c”</h5><p>类似于getchar()，不会跳过任何一个字符，包括空格，tab，‘\n’等。<strong>但是，要注意：空格的作用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a,b,c;</span><br><span class="line">    <span class="comment">//a = getchar();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %c %c %c"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %c %c"</span>, a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-”-s”"><a href="#2-gt-”-s”" class="headerlink" title="2&gt;”%\s”"></a>2&gt;”%\s”</h5><p>相对于%c，%s简单许多:</p>
<p>scanf()以<strong>非空白符</strong>开始，<strong>空白符</strong>结束，完成一个%s的录入;<br>printf()从<strong>当前位置</strong>打印到‘\0’结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-ELSE"><a href="#4-ELSE" class="headerlink" title="4.ELSE"></a>4.ELSE</h4><p>当然，对于字符以及字符串的输入输出方式还有很多，比如：</p>
<h5 id="1-gt-使用string类型的getline输入"><a href="#1-gt-使用string类型的getline输入" class="headerlink" title="1&gt;使用string类型的getline输入"></a>1&gt;使用string类型的getline输入</h5><p>(虽然一般不用，但它的骚操作真的非灰常优秀)</p>
<h5 id="2-gt-gets-和puts-输入输出"><a href="#2-gt-gets-和puts-输入输出" class="headerlink" title="2&gt;gets()和puts()输入输出"></a>2&gt;gets()和puts()输入输出</h5><h5 id="3-gt-意念输入输出（纯属口胡QwQ）"><a href="#3-gt-意念输入输出（纯属口胡QwQ）" class="headerlink" title="3&gt;意念输入输出（纯属口胡QwQ）"></a>3&gt;<del>意念输入输出（纯属口胡QwQ）</del></h5><p>但我们做题的时候能用到的，基本就是这些了。</p>
<h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h4 id="1-P1307-数字反转"><a href="#1-P1307-数字反转" class="headerlink" title="1.P1307 数字反转"></a>1.<a href="https://www.luogu.com.cn/problem/P1307" target="_blank" rel="noopener">P1307 数字反转</a></h4><h4 id="2-P5660-数字游戏"><a href="#2-P5660-数字游戏" class="headerlink" title="2.P5660 数字游戏"></a>2.<a href="https://www.luogu.com.cn/problem/P5660" target="_blank" rel="noopener">P5660 数字游戏</a></h4><h4 id="3-输入一幅-n-times-m-的矩阵"><a href="#3-输入一幅-n-times-m-的矩阵" class="headerlink" title="3.输入一幅$ n \times m $的矩阵"></a>3.输入一幅$ n \times m $的矩阵</h4><p><strong>Input Sample </strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">...###..</span><br><span class="line">####....</span><br><span class="line">#..##..#</span><br><span class="line">.##.#..#</span><br></pre></td></tr></table></figure>
<h3 id="程序的调试"><a href="#程序的调试" class="headerlink" title="程序的调试"></a>程序的调试</h3><p>通常我们在做完一道题后，60%(意思就是很多时候，不要当真)</p>
<p>所以此时的我们，需要<strong>调试</strong>。</p>
<h4 id="1-调试的简介"><a href="#1-调试的简介" class="headerlink" title="1.调试的简介"></a>1.调试的简介</h4><blockquote>
<p>编好程序后，用各种手段进行查错和排错的过程。作为程序的正确性不仅仅表现在正常功能的完成上，更重要的是对意外情况的正确处理。从心理学的角度考虑，开发人员和调试人员不应该是同一个人。</p>
</blockquote>
<h4 id="2-调试的一般方法"><a href="#2-调试的一般方法" class="headerlink" title="2.调试的一般方法"></a>2.调试的一般方法</h4><h5 id="1-gt-信仰模拟法"><a href="#1-gt-信仰模拟法" class="headerlink" title="1&gt; 信仰模拟法"></a>1&gt; 信仰模拟法</h5><h5 id="2-gt-直接输出法"><a href="#2-gt-直接输出法" class="headerlink" title="2&gt; 直接输出法"></a>2&gt; 直接输出法</h5><h5 id="3-gt-Dev-C-C-自带调试"><a href="#3-gt-Dev-C-C-自带调试" class="headerlink" title="3&gt; Dev-C/C++自带调试"></a>3&gt; Dev-C/C++自带调试</h5><h4 id="3-Dev-C-C-功能介绍"><a href="#3-Dev-C-C-功能介绍" class="headerlink" title="3.Dev-C/C++功能介绍"></a>3.Dev-C/C++功能介绍</h4><h4 id="4-Dev-C-C-实战演示"><a href="#4-Dev-C-C-实战演示" class="headerlink" title="4.Dev-C/C++实战演示"></a>4.Dev-C/C++实战演示</h4><p>我们先来一份代码</p>
<h5 id="1-gt-法一：略"><a href="#1-gt-法一：略" class="headerlink" title="1&gt;法一：略"></a>1&gt;法一：略</h5><h5 id="2-gt-法二：P2178-NOI2015-品酒大会"><a href="#2-gt-法二：P2178-NOI2015-品酒大会" class="headerlink" title="2&gt;法二：P2178 [NOI2015]品酒大会"></a>2&gt;法二：<a href="https://www.luogu.com.cn/problem/P2178" target="_blank" rel="noopener">P2178 [NOI2015]品酒大会</a></h5><h5 id="3-gt-法三：P2503-HAOI2006-均分数据"><a href="#3-gt-法三：P2503-HAOI2006-均分数据" class="headerlink" title="3&gt;法三：P2503 [HAOI2006]均分数据"></a>3&gt;法三：<a href="https://www.luogu.com.cn/problem/P2503" target="_blank" rel="noopener">P2503 [HAOI2006]均分数据</a></h5><h3 id="字符串的定义扩展"><a href="#字符串的定义扩展" class="headerlink" title="字符串的定义扩展"></a>字符串的定义扩展</h3><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>一个 <strong>字符集</strong>$ \sum $是一个建立了全序关系的集合，也就是说,$ \sum $中的任意两个不同的元素$\alpha$和$\beta$都可以比较大小，要么$ \alpha &gt; \beta $，要么$ \alpha &lt; \beta $ 。字符集$ \sum $中的元素称为字符。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一个 <strong>字符串</strong>$S$是将$n$个字符顺次排列形成的序列，$n$称为$S$的长度，表示为$ |S| $ .$S$的第$i$个字符表示为$S[i]$。（在有的地方，也会用$S[i-1]$表示第$i$个字符。）</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>字符串$S$的 <strong>子串</strong>$S[i \cdots j]$，$ i \leq j $ ，表示$S$串中从$i$到$j$这一段，也就是<strong>顺次排列</strong>$ S[i],S[i+1],\cdots,S[j] $形成的字符串。</p>
<p>有时也会用 $ S[i \cdots j],i&gt;j $, 来表示空串。</p>
<h4 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h4><p>字符串$S$的 <strong>子序列</strong> 是从$S$中将若干元素提取出来并不改变相对位置形成的序列，即$ S[p_1],S[p_2],\cdots,S[p_k],1 \leq p_1 &lt; p_2 &lt; \cdots &lt;p_k \leq |S| $</p>
<h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><p><strong>后缀</strong> 是指从某个位置$i$开始到整个串末尾结束的一个特殊子串。字符串$S$的从$i$开头的后缀表示为$Suffix(S,i)$，也就是$ Suffix(S,i)=S[i \cdots |S|-1] $。</p>
<p><strong>真后缀</strong> 指除了$S$本身的$S$的后缀。</p>
<p>举例来说，字符串 <code>abcabcd</code> 的所有后缀为 <code>{d, cd, bcd, abcd, cabcd, bcabcd, abcabcd}</code> ，而它的真后缀为 <code>{d, cd, bcd, abcd, cabcd, bcabcd}</code> 。</p>
<h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p><strong>后缀</strong> 是指从串首开始到某个位置 结束的一个特殊子串。字符串$S$的从$i$开头的后缀表示为$Preffix(S,i)$，也就是$ Preffix(S,i)=S[i \cdots |S|-1] $。</p>
<p><strong>真前缀</strong> 指除了$S$本身的$S$的前缀。</p>
<p>举例来说，字符串 <code>abcabcd</code> 的所有前缀为 <code>{a, ab, abc, abca, abcab, abcabc, abcabcd}</code> , 而它的真前缀为 <code>{a, ab, abc, abca, abcab, abcabc}</code> 。</p>
<h4 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h4><p>以第$i$个字符作为第$i$关键字进行大小比较，空字符小于字符集内任何字符（即:$ a&lt;aa $）。</p>
<h4 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h4><p><strong>回文串</strong> 是正着写和倒着写相同的字符串，即满$ \forall 1 \leq i \leq |s|,s[i]=s[|s|+1-i] $ 的$s$。</p>
<h3 id="C-C-标准库中的字符串部分函数使用"><a href="#C-C-标准库中的字符串部分函数使用" class="headerlink" title="C/C++标准库中的字符串部分函数使用"></a>C/C++标准库中的字符串部分函数使用</h3><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><p><code>int strlen(const char *str)</code> ：返回从 <code>str[0]</code> 开始直到 <code>&#39;\0&#39;</code> 的字符数。注意，未开启 O2 优化时，该操作写在循环条件中复杂度是$ O(N) $的。</p>
<h4 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf"></a>sscanf</h4><p><code>sscanf(const char *__source, const char *__format, ...)</code> ：从字符串 <code>__source</code> 里读取变量，比如 <code>sscanf(str,&quot;%d&quot;,&amp;a)</code> </p>
<h4 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h4><p><code>sprintf(char *__stream, const char *__format, ...)</code> ：将 <code>__format</code> 字符串里的内容输出到 <code>__stream</code> 中，比如 <code>sprintf(str,&quot;%d&quot;,i)</code> 。</p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><p><code>int strcmp(const char *str1, const char *str2)</code> ：按照字典序比较 <code>str1 str2</code> 若 <code>str1</code> 字典序小返回负值，一样返回 0，大返回正值 请注意，不要简单的认为只有 <code>0, 1, -1</code> 三种，在不同平台下的返回值都遵循正负，但并非都是 <code>0, 1, -1</code></p>
<h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h4><p><code>char *strcpy(char *str, const char *src)</code> : 把 <code>src</code> 中的字符复制到 <code>str</code> 中， <code>str</code> <code>src</code> 均为字符数组头指针，返回值为 <code>str</code> 包含空终止符号 <code>&#39;\0&#39;</code> 。</p>
<h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h4><p><code>char *strcat(char *str1, const char *str2)</code> : 将 <code>str2</code> 接到 <code>str1</code> 的结尾，用 <code>*str2</code> 替换 <code>str1</code> 末尾的 <code>&#39;\0&#39;</code> 返回 <code>str1</code> 。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><center><font size="6"> Good Luck And Have Fun</font></center>

]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>常数优化火车头</title>
    <url>/articles/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96%E7%81%AB%E8%BD%A6%E5%A4%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常数优化火车头"><a href="#常数优化火车头" class="headerlink" title="常数优化火车头"></a>常数优化火车头</h1><p>虽然感觉用处不大,但还是记录一下,万一某次就有用起来了呢…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"Ofast"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fgcse"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fgcse-lm")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fipa-sra"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-pre")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-ftree-vrp"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fpeephole2")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-ffast-math"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fsched-spec")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"unroll-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-falign-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-labels")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fdevirtualize"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fcaller-saves")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fcrossjumping"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fthread-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-funroll-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fwhole-program")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-freorder-blocks"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fschedule-insns")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"inline-functions"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-tail-merge")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fschedule-insns2"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fstrict-aliasing")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fstrict-overflow"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fcse-skip-blocks"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fcse-follow-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fsched-interblock"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fpartial-inlining")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"no-stack-protector"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-freorder-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-findirect-inlining"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fhoist-adjacent-loads")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-frerun-cse-after-loop"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline-small-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-finline-small-functions"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-switch-conversion")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-foptimize-sibling-calls"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fexpensive-optimizations")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-funsafe-loop-optimizations"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline-functions-called-once")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fdelete-null-pointer-checks"</span>)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡三进制</title>
    <url>/articles/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平衡三进制"><a href="#平衡三进制" class="headerlink" title="平衡三进制"></a>平衡三进制</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=12917&amp;rd=15837" target="_blank" rel="noopener"><strong>PowerOfThree</strong></a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个<strong>二维平面</strong>上的点$ (x,y) $，一个Robot第$i$次可以向<strong>一个方向</strong>走$ 3^i $步（<strong>$i$从0开始</strong>），判断<strong>是否存在</strong>一种方式使得最后Robot走到$ (x,y) $</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p> 首先可以想到是和3有关，但发现和3有关的算法很少。。。</p>
<p>所以肯定可以想到<strong>3进制</strong>，但发现使用0，1，2表示的话，无法表示出所有的情况，且无法判断。</p>
<p>所以引入<strong>平衡三进制</strong> </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>平衡三进制</strong>，也称为<strong>对称三进制</strong>。这是一个不太标准的<strong>计数体系</strong> 。正规的三进制的数字都是由 <code>0</code> , <code>1</code> , <code>2</code> 构成的，而平衡三进制的数字是由 <code>-1</code> , <code>0</code> , <code>1</code> 构成的。它的<strong>基数</strong>也是 <code>3</code> （因为有三个可能的值）。由于将 <code>-1</code> 写成数字不方便，我们将使用字母 $Z$来代替 <code>-1</code> ，并且这个计数体系可以很轻松的表示出负数。</p>
<p>比如：$ 6 \Rightarrow 1Z0 $，$ -5 \Rightarrow Z11 $</p>
<h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>在平衡三进制的转转换法中，需要先写出一个给定的数 $x$在标准三进制中的表示。当 $x$ 是用标准三进制表示时，其数字的每一位都是 <code>0</code> 、 <code>1</code> 或 <code>2</code> 。从最低的数字开始迭代，我们可以先跳过任何的 <code>0</code> 和 <code>1</code> ，但是如果遇到 <code>2</code> 就应该先将其变成$Z$，下一位数字再加上 <code>1</code> 。而遇到数字 <code>3</code> 则应该转换为 <code>0</code> 下一位数字再加上 <code>1</code> 。</p>
<p><strong>温馨提示</strong>：一个10进制数对应一个三进制数对应一个平衡三进制数</p>
<p>比如：</p>
<script type="math/tex; mode=display">
237_{10} \Rightarrow 22210_3</script><ul>
<li><code>0</code> 和 <code>1</code> 被跳过（因为在平衡三进制中允许 <code>0</code> 和 <code>1</code> )；</li>
</ul>
<ul>
<li><code>2</code> 变成 $Z$ ，左边的数字加 <code>1</code> ，得到 $23Z10$ ；</li>
<li><code>3</code> 变成 <code>0</code> ，左边的数字加 <code>1</code> ，得到 $30Z10$；</li>
<li><code>3</code> 变成 <code>0</code> ，左边的数字（默认是 <code>0</code> ）加 <code>1</code> ，得到 $100Z10$；</li>
<li><code>1</code> 被跳过，得到 $100Z10$。</li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>手动吸氧</title>
    <url>/articles/%E6%89%8B%E5%8A%A8%E5%90%B8%E6%B0%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手动开启O2优化—以及-O-O1-O2-O3优化的知识点"><a href="#手动开启O2优化—以及-O-O1-O2-O3优化的知识点" class="headerlink" title="手动开启O2优化—以及-O -O1 -O2 -O3优化的知识点"></a>手动开启O2优化—以及-O -O1 -O2 -O3优化的知识点</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。 </p>
<p>O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。 </p>
<p>O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 </p>
<p>Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。 </p>
</li>
<li><p>-O0： 不做任何优化，这是默认的编译选项。</p>
</li>
<li><p>-O和-O1： 对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。</p>
</li>
<li>O2优化能使程序的编译效率大大提升。从而减少程序的运行时间，达到优化的效果。</li>
</ul>
<h2 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h2><h3 id="O2"><a href="#O2" class="headerlink" title="O2"></a>O2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure>
<h3 id="O3"><a href="#O3" class="headerlink" title="O3"></a>O3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3,<span class="meta-string">"Ofast"</span>,<span class="meta-string">"inline"</span>)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶逆变换</title>
    <url>/articles/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E9%80%86%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>IDFT（傅里叶逆变换）</strong>是把目标多项式的<strong>点值形式</strong>转换成<strong>系数形式</strong></p>
<p>即：由$n$维点值$ (A(x<em>0),A(x_1), \cdots ,A(X</em>{n-1})) $，推出$n$维系数向量$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>设$ (d<em>0,d_1, \cdots ,d</em>{n-1}) $为$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $得到的<strong>离散傅里叶变换</strong>的结果</p>
<p>我们<strong>构造</strong>一个多项式$ F(x)=d<em>0+d_1 \cdot x+d_2 \cdot x^2 + \cdots + d</em>{n-1} \cdot x^{n-1} $</p>
<p>设向量$ (c<em>0,c_1, \cdots ,c</em>{n-1}) $中</p>
<p>$c_k$为$ F(x) $在$ x= \omega^{-k}_n $的<strong>点值表示</strong></p>
<p>即$ c<em>k= \sum^{n-1}</em>{i=0} d_i \cdot ( \omega^{-k}_n)^i $</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>我们考虑对$d_i$进行<strong>还原</strong></p>
<p>于是</p>
<script type="math/tex; mode=display">
c_k= \sum^{n-1}_{i=0} [ \sum^{n-1}_{i=0}a_j \cdot ( \omega^i_n)^j] \cdot ( \omega^{-k}_n)^i \\
\Rightarrow \sum^{n-1}_{j=0} a_j \sum^{n-1}_{i=0} ( \omega^i_n)^j \cdot ( \omega ^{-k}_n)^i \\
\Rightarrow \sum^{n-1}_{j=0} a_j \sum^{n-1}_{i=0} ( \omega^i_n)^{j-k}</script><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>我们令$ S(j,k)= \sum^{n-1}_{i=0} ( \omega^i_n)^{j-k} $</p>
<p>对其进行<strong>化简</strong></p>
<p>设$ j-k= \delta $</p>
<p>则$ S(j,k)= \omega_n^{0}+ \omega^{ \delta}_n+ \omega^{2 \delta}_n+ \cdots + \omega^{(n-1) \delta}_n $</p>
<p>其<strong>公比</strong>为$ \omega^{ \delta}_n $</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><strong>当$ \omega^{ \delta}_n=1 $即$ \delta=0 $时</strong></p>
<script type="math/tex; mode=display">
S(j,k)=n \Rightarrow \delta=0 \Rightarrow j-k=0 \Rightarrow j=k</script><p><strong>当$ \omega^{ \delta}_n \neq 1 $即$ \delta \neq 0 $时</strong></p>
<script type="math/tex; mode=display">
S(j,k)= \frac{ \omega^0_n[( \omega^{ \delta}_n)^n -1]}{ \omega ^{ \delta}_n -1}= \frac{1[( \omega^n_n)^{ \delta}-1]}{ \omega^{ \delta}_n -1}= \frac{[1^{ \delta} -1]}{ \omega^{ \delta}_n -1}= \frac{0}{ \omega ^{ \delta}_n -1}=0 \Rightarrow j \neq k​</script><p>所以$ S(j,k)=[j=k] \cdot n $</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>将$ S(j,k) $<strong>代入原式</strong></p>
<script type="math/tex; mode=display">
c_k= \sum ^{n-1}_{j=0} a_j \cdot S(j,k) = \sum^{n-1}_{j=0} a_j \cdot [j=k] \cdot n=a_k \cdot n</script><p>所以$ a_k= \frac{c_k}{n} $</p>
<p>其中$ a_k $为原多项式$ A(x) $的<strong>系数向量</strong>$ (a_0,a_1, \cdots ,a_n) $中的$ a_k $</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>由此可得</p>
<p>我们将$ ( \omega^0<em>n, \omega^{-1}_n, \omega^{-2}_n, \cdots , \omega^{-(n-1)}_n) $作为<strong>插值节点</strong>$ (d_0,d_1, \cdots ,d</em>{n-1}) $作为系数向量，做一次<strong>离散傅里叶变换</strong>得到的向量的每一项都<strong>除以$n$</strong>得到$ ( \frac{c<em>0}{n}, \frac{c_1}{n}, \cdots , \frac{c</em>{n-1}}{n}) $就是多项式的<strong>系数向量</strong>$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $</p>
<p>注意，$ \omega^{-k}_n $是$ \omega^k_n $的<strong>共轭复数</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plurality</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line"></span><br><span class="line">    Plurality (<span class="keyword">double</span> A=<span class="number">0.0</span>,<span class="keyword">double</span> B=<span class="number">0.0</span>) &#123; X=A; Y=B; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> + (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X+B.X,A.Y+B.Y); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> - (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X-B.X,A.Y-B.Y); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> * (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X*B.X-A.Y*B.Y,A.X*B.Y+A.Y*B.X); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> * (Plurality A,<span class="keyword">double</span> B) &#123; <span class="keyword">return</span> Plurality(A.X*B,A.Y*B); &#125;</span><br><span class="line">&#125;F[MAXN],G[MAXN];</span><br><span class="line"><span class="keyword">int</span> N,M,Rev[MAXN],Limit=<span class="number">1</span>,Loc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(Plurality *New)</span> </span>&#123; </span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) Rev[i]=(Rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i &amp; <span class="number">1</span>)&lt;&lt;(Loc<span class="number">-1</span>));</span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;Rev[i]) swap(New[i],New[Rev[i]]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Plurality *New,<span class="keyword">int</span> Tag)</span> </span>&#123;</span><br><span class="line">    Change(New);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> Mid=<span class="number">1</span>;Mid&lt;Limit;Mid&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Plurality <span class="title">Step</span><span class="params">(<span class="built_in">cos</span>(PI/Mid),Tag*<span class="built_in">sin</span>(PI/Mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> K=<span class="number">0</span>;K&lt;Limit;K+=(Mid&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">Plurality <span class="title">I</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Mid;i++,I=I*Step) &#123;</span><br><span class="line">               Plurality A=New[K+i],B=I*New[K+i+Mid];</span><br><span class="line">               New[K+i]=A+B;</span><br><span class="line">               New[K+i+Mid]=A-B; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) &#123; New[i]/=(<span class="keyword">double</span>)Limit; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>指针 &amp; 函数基础应用</title>
    <url>/articles/%E6%8C%87%E9%92%88-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指针-amp-函数基础应用"><a href="#指针-amp-函数基础应用" class="headerlink" title="指针 &amp; 函数基础应用"></a>指针 &amp; 函数基础应用</h1><h3 id="By-DeNeRATe—2020-8-6"><a href="#By-DeNeRATe—2020-8-6" class="headerlink" title="By DeNeRATe—2020.8.6"></a>By DeNeRATe—2020.8.6</h3><p>为了更好地理解和应用指针，我们先来简介一下内存空间。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>指针是我们必须了解的一个板块，但它在竞赛范围内的应用开始逐渐呈下降态，在实现算法时对于指针的使用一般会去回避，因为一不小心，指针就会指偏，而且不容易调试。$ \cdots \cdots $</p>
<p>但指针的作用是无可替代的，那此时该怎么办呢—<strong>迭代器</strong>$ \cdots \cdots $</p>
<p>所以，我们就来先讲一下这神奇的东西—<strong>指针</strong></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>○<strong>内存栈区</strong>： 存放局部变量名；</p>
<p>○<strong>内存堆区</strong>： 存放new或者malloc出来的对象；</p>
<p>○<strong>常数区</strong>： 存放局部变量或者全局变量的值；</p>
<p>○<strong>静态区</strong>： 用于存放全局变量或者静态变量；</p>
<p>○<strong>代码区</strong>：二进制代码。</p>
<h4 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h4><p>○<strong>栈区（stack）</strong>— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </p>
<p>○<strong>堆区（heap） </strong>— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</p>
<p>○<strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（RW）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（ZI）。 - 程序结束后有系统释放 </p>
<p>○<strong>文字常量区 </strong>—常量字符串就是放在这里的。 程序结束后由系统释放 （RO）</p>
<p>○<strong>程序代码区</strong>—存放函数体的二进制代码。 （RO）</p>
<h4 id="图解内存"><a href="#图解内存" class="headerlink" title="图解内存"></a>图解内存</h4><p>在 sw-at 的博客上扒了一张图，这张图中所示内存空间，地址由下往上增长，分别标示了 .text、.data、.bss、stack和heap的内存分部情况。</p>
<p><img src="https://i.loli.net/2020/08/06/5NCGkj2tbfzA1FY.png" alt="程序内存分配.png"></p>
<p>text、data(gvar)、bss 在内存中地址较低低的位置（low level address），而堆栈则在相对较搞的位置。<br>堆(Heap)往高地址方向生长，栈(Stack)往低地址方向生长。</p>
<h4 id="不同内存的特点"><a href="#不同内存的特点" class="headerlink" title="不同内存的特点"></a>不同内存的特点</h4><p>○<strong>栈</strong></p>
<p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，用于在函数作用域内创建，在离开作用域后自动销毁的变量的存储区。通常是局部变量，函数参数等的存储区。他的存储空间是连续的，两个紧密挨着定义的局部变量，他们的存储空间也是紧挨着的。栈的大小是有限的，通常Visual C++编译器的默认栈的大小为<strong>1MB</strong>，所以不要定义int a[1000000]这样的超大数组。</p>
<p>○<strong>堆</strong></p>
<p>通常是用于那些在编译期间不能确定存储大小的变量的存储区，它的存储空间是不连续的，一般由malloc（或new）函数来分配内存块，并且需要用free（delete）函数释放内存。如果程序员没有释放掉，那么就会出现常说的内存泄漏问题。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。另外需要注意的一点是，堆的大小几乎不受限制，理论上每个程序最大可达<strong>4GB</strong>。</p>
<p>○<strong>全局/静态存储区</strong></p>
<p> 和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p>
<p>○<strong>常量存储区</strong></p>
<p> 和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内的常量是全局可见的。这是一块比较特殊的存储去，他们里面存放的是常量，不允许被修改。</p>
<p><img src="https://i.loli.net/2020/08/06/qiws5oZ7BVlgz3m.png" alt="栈和堆对比 _ 全局存储器和常量存储区的对比.png"></p>
<h4 id="程序变量分配内存"><a href="#程序变量分配内存" class="headerlink" title="程序变量分配内存"></a>程序变量分配内存</h4><h5 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1.预备知识"></a>1.预备知识</h5><p>byte:字节           bit:位</p>
<p>$ \Rightarrow $<strong>1 byte = 8 bit</strong></p>
<h5 id="2-程序变量"><a href="#2-程序变量" class="headerlink" title="2.程序变量"></a>2.程序变量</h5><p>○<strong>短整型short</strong></p>
<p>  所占内存大小：<strong>2byte=16bit</strong>；</p>
<p>  所能表示范围：$ -32768 \rightarrow 32767$ 即$ -2^{15} \rightarrow 2^{15}-1 $</p>
<p>○<strong>整型int</strong>：</p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ -2147483648 \rightarrow 2147483647 $ 即$ -2^{31} \rightarrow 2^{31}-1 $</p>
<p>  <strong>unsigned int: </strong> </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 4294967295 $ 即$ 0 \rightarrow 2^{32}-1 $</p>
<p>○<strong>长整型long</strong>：</p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ -2147483648 \rightarrow 2147483647 $ 即$ -2^{31} \rightarrow 2^{31}-1 $</p>
<p><strong>unsigned long:</strong>  </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 4294967295 $即$ 0 \rightarrow 2^{32}-1 $</p>
<p>○<strong>4. long long:</strong></p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示范围：$ -9223372036854775808 \rightarrow 9223372036854775807 $ 即$ -2^{63} \rightarrow 2^{63}-1 $$</p>
<p>  <strong>unsigned long: </strong> </p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 1844674407370955161 $ 即$ 0 \rightarrow 2^{64}-1 $</p>
<p>○<strong>字符型char</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：不确定……；</p>
<p>  <strong>unsigned char</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 255 $ 即$ 0 \rightarrow 2^8-1 $$</p>
<p>   <strong>singned char:</strong>  </p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：$ -128 \rightarrow127 $ 即$  -2^7 \rightarrow 2^7-1 $</p>
<p><strong>温馨提示：</strong>  char的默认类型不确定有可能是unsigned，也有可能是signed，主要更具编译器而定，可以自己测试一下编译器的默认char的符号类型。</p>
<p>○<strong>布尔类型bool</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示的范围：只能取两个值<strong>false</strong>或者<strong>true</strong>；</p>
<p>  所以最小值就是：<strong>0</strong>， 最大值：<strong>1</strong>.</p>
<p>○<strong>单精度float</strong>：   </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示的范围：$ 1.17549e-038 \rightarrow 3.40282e+038 $</p>
<p>  <strong>温馨提示：</strong>浮点数在 内存中都是按科学计数法来存储的，浮点数的精度是由尾数的位数决定的，大家记住即可不必深究；</p>
<p> ○<strong>双精度double</strong>：</p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示的范围：$ 2.22507e-308 \rightarrow 1.79769e+308 $</p>
<p>  <strong>温馨提示：</strong>如何区分和使用这两个浮点类型呢，首先float和double的精度不同， float保留到小数点后面7位，而double保留到小数点后面16位，float能保证6 位有效数字，而double能保证15位有效数字，如果在不追求精度的的情况下当然用 float比较好，节省内存，如果需要很高的精度的情况下，最好还是用 double，平时我们定义浮点型变量一般都用double，毕竟精度高，<strong>一般精度的损失是不能忽略的</strong></p>
<h4 id="关于做题时内存的作用"><a href="#关于做题时内存的作用" class="headerlink" title="关于做题时内存的作用"></a>关于做题时内存的作用</h4><p><del>（此处口胡）</del></p>
<p>比如：<a href="https://www.luogu.com.cn/problem/P6561" target="_blank" rel="noopener">P6561 [SBCOI2020] 人</a></p>
<h3 id="指针-编程语言中的一个对象"><a href="#指针-编程语言中的一个对象" class="headerlink" title="指针(编程语言中的一个对象)"></a>指针(编程语言中的一个对象)</h3><p>刚才扯得有点远了，但一些重要的关于内存的只是也是很重要的</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>指针，是C语言中的一个重要<a href="https://baike.baidu.com/item/概念/829047" target="_blank" rel="noopener">概念</a>及其<a href="https://baike.baidu.com/item/特点/10931917" target="_blank" rel="noopener">特点</a>，也是掌握C语言比较困难的部分。指针也就是<a href="https://baike.baidu.com/item/内存地址/7354236" target="_blank" rel="noopener">内存地址</a>，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的<a href="https://baike.baidu.com/item/存储空间/10657950" target="_blank" rel="noopener">存储空间</a>长度也不同。有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。</p>
</blockquote>
<p>为了更好的理解指针，我们先来康康变量。</p>
<h4 id="变量的实质"><a href="#变量的实质" class="headerlink" title="变量的实质"></a>变量的实质</h4><p>首先是一张内存空间图：</p>
<p><img src="https://i.loli.net/2020/08/06/fJxu89CaTGbpOyl.png" alt="变量的实质-1.png"></p>
<p>如图所示，内存只不过是一个存放数据的空间，现在我们把它想象成电影院的座位，电影院中的每个座位都要编号，而我们的内存要存放各种各样的数据，当然我们要知道我们的这些数据存放在什么位置吧！所以内存也要象座位一样进行编号了，这就是我们所说的<strong>内存编址（为内存进行地址编码）</strong>。座位可以是遵循“一个座位对应一个号码”的原则，从“第 1 号”开始编号。而内存则是按一个字节接着一个字节的次序进行编址，如上图所示。每个字节都有个编号，我们称之为<strong>内存地址</strong>。</p>
<p>内存编址：</p>
<p><img src="https://i.loli.net/2020/08/06/RnfPAMbpcJV7Ivz.png" alt="变量的实质-2.png"></p>
<p>当我们在程序中写下了这样的语言声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> a;</span><br></pre></td></tr></table></figure>
<p>它其实是内存中申请了一个名为 i 的整型变量宽度空间（DOS 下的 16 位编程中其宽度为 2 个字节），和一个名为 a 的字符型变量宽度的空间（占 1 个字节）。</p>
<p>此时，内存空间中的映像如图：</p>
<p><img src="https://i.loli.net/2020/08/06/cPNgrlBQFmekqn8.png" alt="变量的实质-3.png"></p>
<p>图中可看出，i 在内存起始地址为 6 上申请了两个字节的空间（我这里假设了 int 的宽度为 16 位，不同系统中 int 的宽度可能是不一样的，最常用的win32环境下为4个字节），并命名为 i。a 在内存地址为 8 上申请了一字节的空间，并命名为 a。</p>
<h4 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h4><p>但我们在赋值时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i=<span class="number">30</span>;</span><br><span class="line">a=<span class="string">'t'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/08/06/xehYDg7iWm94cVb.png" alt="变量的赋值.png"></p>
<p>我们将30存在了以地址6（真正的地址可不是这样子哦，真正的地址如：0016FD14）为起始地址的两个字节空间里，a 在内存地址为 8 上申请了一字节的空间存入了‘t’</p>
<h4 id="变量的位置"><a href="#变量的位置" class="headerlink" title="变量的位置"></a>变量的位置</h4><p>我们是怎么知道真正的地址的呢：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;i = "</span>&lt;&lt; &amp;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i =  "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的 &amp;i 的值 0016FD14就是我们图示中内存空间编码为6的内存地址。</p>
<h4 id="指针的实质"><a href="#指针的实质" class="headerlink" title="指针的实质"></a>指针的实质</h4><p>下面看一条声明一个指向整型变量的指针的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br></pre></td></tr></table></figure>
<p>pi 是一个指针，当然我们知道啦，但是这样说，你就以为 pi 一定是个多么特别的东西了。其实，它也只过是一个变量而已。与上一篇中说的变量并没有实质的区别。好了，这就是指针。仅此而已，就这么简单。</p>
<p><img src="https://i.loli.net/2020/08/06/trjsJTEXcHMoD3U.png" alt="指针的实质-1.png"></p>
<p>pi 也只不过是一个变量而已嘛！那么它又为什么会被称为“指针”？关键是我们要让这个变量所存储的内容是什么。现在我要让 pi 成为具有真正“指针”意义的变量。请接着看下面语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pi=&amp;i;</span><br></pre></td></tr></table></figure>
<p><strong>把 i 地址的编号赋值给 pi</strong>。并记下来。也就是你<strong>在 pi 里面写上 i 的地址编号</strong>。结果如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/06/IC4kUEV95AJqPi2.png" alt="指针的实质-2.png"></p>
<p>执行完 pi=&amp;i 后，在图示中的内存中，pi 的值是 6。这个 6 就是i 变量的地址编号，这样 pi 就指向了变量 i 了。pi 与那张纸条有什么区别？pi 不就是那张纸条嘛！因此，我们就把 pi 称为指针。</p>
<p>总结一句话：<strong>指针变量所存的内容就是内存的地址编号 ！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;i = "</span>&lt;&lt; &amp;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i =  "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pi = "</span> &lt;&lt; *pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么程序中pi 什么意思呢？<strong>pi 内容所指的地址的内容</strong></p>
<h4 id="MORE-INFORMATION"><a href="#MORE-INFORMATION" class="headerlink" title="MORE INFORMATION"></a>MORE INFORMATION</h4><p>当然，对于指针我们其实只需要了解即可，若大家有兴趣的话，可以康康这：<a href="https://blog.csdn.net/weixin_39951988/article/details/87773322" target="_blank" rel="noopener">指针详解</a>(但确实没必要，有生之年应该不会用到其他的)</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p>听说，暴力打不出来的时候，STL和迭代器更配哟 — 哲哥</p>
<p>迭代器（iterator）有时又称游标（cursor）是程序设计的<a href="https://baike.baidu.com/item/软件设计模式/2117635" target="_blank" rel="noopener">软件设计模式</a>，可在容器（container，例如<a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>或<a href="https://baike.baidu.com/item/阵列/2644035" target="_blank" rel="noopener">阵列</a>）上遍访的接口，设计人员无需关心容器的内容。</p>
</blockquote>
<p>(此处展开$ [\,\,\,] + $)</p>
<h3 id="基础函数的访问"><a href="#基础函数的访问" class="headerlink" title="基础函数的访问"></a>基础函数的访问</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p> ○C/C++自带函数</p>
<p>比如：swap()  reverse()  strcat()  sort() $ \cdots \cdots $</p>
<p> ○STL函数</p>
<p>比如：lower_bound()  upper_bound()  assign() $ \cdots \cdots $</p>
<p> ○自定义函数</p>
<p>（当然我们需要重点掌握的就是自定义函数了，因为其他的是人应该都是直接上手的  <del>口胡.JPG</del>）</p>
<h4 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h4><h5 id="1-gt"><a href="#1-gt" class="headerlink" title="1&gt;"></a>1&gt;</h5><p>简化代码量，对各个部分进行封装，使得问题变得简单和直观，提高了程序的易读性</p>
<h5 id="2-gt"><a href="#2-gt" class="headerlink" title="2&gt;"></a>2&gt;</h5><p>提升可维护性，把一些计算或操作编成通用的函数，以供随时调用，从而避免了代码的重复冗长</p>
<h5 id="3-gt"><a href="#3-gt" class="headerlink" title="3&gt;"></a>3&gt;</h5><p>但是运用函数，就需要传递参数，开辟缓存、堆栈等，相比较而言，会耗一些多余的效率</p>
<h4 id="自定义函数方式"><a href="#自定义函数方式" class="headerlink" title="自定义函数方式"></a>自定义函数方式</h4><ul>
<li>函数的返回类型分：</li>
</ul>
<h5 id="1-gt-void-型"><a href="#1-gt-void-型" class="headerlink" title="1&gt;void 型"></a>1&gt;void 型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>void类型是可以直接使用的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Update();</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-int-double-long-long-类型"><a href="#2-gt-int-double-long-long-类型" class="headerlink" title="2&gt;int(double)(long long)类型"></a>2&gt;int(double)(long long)类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Get</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>当然这种类型一般是需要一个变量来接收这个值的。例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> Res=Get();</span><br></pre></td></tr></table></figure>
<ul>
<li>传递的类型分：</li>
</ul>
<p>1&gt;值传递</p>
<p>2&gt;引传递</p>
<p>3&gt;指针传递</p>
<h4 id="传参操作"><a href="#传参操作" class="headerlink" title="传参操作"></a>传参操作</h4><h5 id="1-gt-值传递"><a href="#1-gt-值传递" class="headerlink" title="1&gt;值传递"></a>1&gt;值传递</h5><p>调用时，将实参的值传递对应的形参，即为值传递。函数中对任何形参值得修改都不会改变实参变量的值。<br>例如经典的交换x，y的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Temp=X;</span><br><span class="line">    X=Y; </span><br><span class="line">    Y=Temp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Change:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y:"</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    Change(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-引传递"><a href="#2-gt-引传递" class="headerlink" title="2&gt;引传递"></a>2&gt;引传递</h5><p>引用变量是变量的另一个<strong>别名</strong>，它<strong>没有自己的存储数据的内存位置</strong>，它访问的是另一个变量的内存位置。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Temp=X;</span><br><span class="line">    X=Y; </span><br><span class="line">    Y=Temp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Change:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y:"</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    Change(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现main函数中的a,b改变了。所以 $ \cdots \cdots $</p>
<h5 id="3-gt-指针传递"><a href="#3-gt-指针传递" class="headerlink" title="3&gt;指针传递"></a>3&gt;指针传递</h5><p>这当然就是我们最容易忽略，但需要用的时候灰常有用的传递方式了。主要用处就是对于函数如果要传递数组作为继承时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Num[MAXN],Total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ex_change</span><span class="params">(<span class="keyword">int</span> Temp[])</span><span class="comment">//方式1</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ex_change</span><span class="params">(<span class="keyword">int</span> *Temp)</span><span class="comment">//方式2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这两种方式若在其中进行变量的更改，那个由于是传递的地址</span></span><br><span class="line">    <span class="comment">//所以外边的Num数组也会发生改变</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Total;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Num[i]);</span><br><span class="line">    Ex_change(Num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><p><a href="https://www.luogu.com.cn/problem/P1035" target="_blank" rel="noopener">P1035 级数求和</a></p>
<p>(我们现在改一下这道题，有Q次询问)</p>
<h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><h5 id="1-gt-inline"><a href="#1-gt-inline" class="headerlink" title="1&gt;inline"></a>1&gt;inline</h5><p>作用：可写可不写 $ \cdots \cdots $</p>
<p>只是可以加快一下程序的速度，和register的作用差不多。</p>
<h5 id="2-gt-函数调用的位置"><a href="#2-gt-函数调用的位置" class="headerlink" title="2&gt;函数调用的位置"></a>2&gt;函数调用的位置</h5><p>初学函数时，若写多个函数，由于不注意，可能会出现神奇的错误—调用不了函数</p>
<p>因为函数和变量一样，只会在一定的区域内查找需要的函数。</p>
<p>而函数的作用范围是从这个函数所处的位置向下走的位置</p>
<p>比如如图：Paint()函数的作用范围只有红框，若果在DFS()函数中调用Paint()那么就会发现，编译器找不到Paint()函数在哪儿，就会报错</p>
<p><img src="https://i.loli.net/2020/08/06/LvPD6yxsealI4oO.png" alt="函数的作用范围.png"></p>
<h5 id="3-gt-函数名重复"><a href="#3-gt-函数名重复" class="headerlink" title="3&gt;函数名重复"></a>3&gt;函数名重复</h5><p>变量名在一定的区域内不可被重复定义。</p>
<p>但函数是可以重名的，但必须是变量调用数量不同，或者是变量类型不同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">inline void Init(int a) √</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">inline void Init(int b,int c) √</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">inline void Init(int a) √</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">inline void Init(double a) √</span><br></pre></td></tr></table></figure>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><center><font size="6"> Good Luck And Have Fun</font></center>]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列模意义下循环节</title>
    <url>/articles/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E5%BE%AA%E7%8E%AF%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="斐波那契数列模意义下循环节"><a href="#斐波那契数列模意义下循环节" class="headerlink" title="斐波那契数列模意义下循环节"></a>斐波那契数列模意义下循环节</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>对于函数$ f(n)=the\,\,\,nth\,\,\,number\,\,\,of\,\,\,the\,\,\,Fibonacci\,\,\,Sequence $ </p>
<p>求出$ f(f(n))\,\,\,n \leq 10^{100} $且对$ mod\,\,\,1e9+7 $</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>当然我这里只能将要证明一下（<del>口胡一下</del>）</p>
<p><strong>具体证明</strong>可见于<a href="http://gradprogram.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf" target="_blank" rel="noopener">Charles W. Campbell II. The Period of the Fibonacci Sequence Modulo j. 2007.</a></p>
<p>我们规定$ G(n) $表示$n$的<strong>最小循环节</strong>，且以下都是在$ mod\,\,\,p $意义下 </p>
<h3 id="引理一"><a href="#引理一" class="headerlink" title="引理一"></a>引理一</h3><p>$ n=p_1^{e_1} \times p_2^{e_2} \times \cdots \times p_m^{e_m} $ </p>
<p>那么$n$的循环节为$ lcm(G(p_1^{e_1}),G(p_2^{e_2}), \cdots ,G(p_m^{e_m})) $</p>
<h3 id="引理二"><a href="#引理二" class="headerlink" title="引理二"></a>引理二</h3><p>$ G(p_i^{e_i})=G(p_i) \times p_i^{e_i-1} $</p>
<h3 id="引理三"><a href="#引理三" class="headerlink" title="引理三"></a>引理三</h3><p>如果5是$ mod\,\,\,p $意义下的<strong>二次剩余</strong>，那么循环节长度为$p-1$的因子否则长为$2(p+1)$</p>
<p>且对于$ \leq 5 $得素数进行<strong>特殊判断</strong></p>
<p>$ loop(2)=3,loop(3)=8,loop(5)=20 $</p>
<p>可以求出所有的因子，然后一个<strong>矩阵快速幂</strong>一个一个判断</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">char</span> c = getchar(); </span><br><span class="line">	<span class="keyword">while</span>(c  &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar(); </span><br><span class="line">	<span class="keyword">while</span>(c  &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) x = x * <span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar(); </span><br><span class="line">	<span class="keyword">return</span> x *f ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m1 = <span class="number">1000000007</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m2 = m1 * <span class="number">2</span> + <span class="number">2</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m3 = m2 * <span class="number">3</span>; </span><br><span class="line"><span class="keyword">int</span> n ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]; </span><br><span class="line">	Matrix () &#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a); &#125;   	</span><br><span class="line">	Matrix  <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; p) <span class="keyword">const</span> &#123; </span><br><span class="line">		Matrix ret; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;++ i) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;++ j) </span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;++ k) </span><br><span class="line">					ret.a[i][j] = (ret.a[i][j] + a[i][k] * p.a[k][j]) % m1; </span><br><span class="line">		<span class="keyword">return</span> ret; </span><br><span class="line">	&#125; </span><br><span class="line">	Matrix  <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">		Matrix ret; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;++ i) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;++ j) </span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;++ k) </span><br><span class="line">					ret.a[i][j] =(ret.a[i][j] +  a[i][k] * p.a[k][j]) % m2; </span><br><span class="line">	 	<span class="keyword">return</span> ret; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	Matrix p,q; </span><br><span class="line">	p.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; p.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; p.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">	q.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//,q.a[1][1] = 1; </span></span><br><span class="line">	<span class="keyword">for</span>(;x;x &gt;&gt;= <span class="number">1</span>,p = p + p) </span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) q = q + p; </span><br><span class="line">	<span class="keyword">return</span> q.a[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	Matrix p,q; </span><br><span class="line">	p.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; p.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; p.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">	q.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">for</span>(;x;x &gt;&gt;= <span class="number">1</span>,p = p * p) </span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) q = q * p; </span><br><span class="line">	<span class="keyword">return</span> q.a[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100007</span>]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> z[<span class="number">100007</span>],l;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="keyword">sizeof</span>(z)); </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s + <span class="number">1</span>); </span><br><span class="line">		l = <span class="built_in">strlen</span>(s + <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l;i ++) </span><br><span class="line">			z[i] = s[l - i + <span class="number">1</span>] - <span class="string">'0'</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">operator</span> % (<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp; a) <span class="keyword">const</span> &#123; </span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &gt;= <span class="number">1</span>;i --) </span><br><span class="line">			b = (b * <span class="number">10</span> + z[i]) % a; </span><br><span class="line">		<span class="keyword">return</span> b; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;z;  </span><br><span class="line">main() &#123; </span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">read</span>(); </span><br><span class="line">	bign num; </span><br><span class="line">	<span class="keyword">while</span>(t --)  &#123; </span><br><span class="line">		num.init(); </span><br><span class="line">		n = num % m3; </span><br><span class="line">		n = get1(n); </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,get2(n));  </span><br><span class="line">	&#125; 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图与SG函数</title>
    <url>/articles/%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%8ESG%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有向图与SG函数"><a href="#有向图与SG函数" class="headerlink" title="有向图与SG函数"></a>有向图与SG函数</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>SG函数</strong>和<strong>有向图</strong>有着千丝万缕的联系，大部分<strong>公平组合游戏</strong>都可以转换为<strong>有向图游戏</strong></p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>在一个<strong>有向无环图</strong>中，只有<strong>一个起点</strong>，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，<strong>不能走的玩家</strong>判负。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义$mex$函数的值为不属于集合$S$中的<strong>最小非负整数</strong>，即：</p>
<script type="math/tex; mode=display">
mex(S)=min \lbrace x \rbrace \,\,\, ( x \notin S,x \in \mathbb{N})</script><p>例如：$ mex( \lbrace 0,2,4 \rbrace )=1,mex( \lbrace 1,2 \rbrace )=0 $</p>
<p>对于状态$x$和它的所有$k$个<strong>后继状态</strong>$ y_1,y_2, \cdots ,y_k $，定义<strong>SG函数</strong>：</p>
<script type="math/tex; mode=display">
SG(x)=mex \lbrace SG(y_1),SG(y_2), \cdots ,SG(y_k) \rbrace</script><p>而对于由$n$个有向图游戏组成的<strong>组合游戏</strong>，设他们的起点分别为$ s_1,s_2, \cdots ,s_n $，则有定理：<strong>当且仅当</strong>$ SG(s_1) \bigoplus SG(s_2) \bigoplus \cdots \bigoplus SG(s_n) \neq 0 $时，这个游戏的<strong>先手必胜</strong></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们可以将一个有$x$个物品的堆视为节点$x$，则当且仅当$ y &lt; x $时，节点$x$可以到达$y$。</p>
<p>那么，由$n$个堆组成的 <strong>Nim 游戏</strong>，就可以视为$n$个<strong>有向图游戏</strong>了。</p>
<p>根据上面的推论，可以得出$ SG(x)=x $。再根据 <strong>SG 定理</strong>，就可以得出 <strong>Nim 和的结论</strong>了。</p>
<p><img src="https://i.loli.net/2020/08/14/GSUxqWzHX8dPC4m.png" alt="有向图与SG函数-1.png"></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数操作的异常情况</title>
    <url>/articles/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浮点数操作的异常情况"><a href="#浮点数操作的异常情况" class="headerlink" title="浮点数操作的异常情况"></a>浮点数操作的异常情况</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们肯定逃不过使用<strong>double浮点型</strong>的时候,但是,如果一旦没有注意,常常会出现输出类似<strong>#IND #INF #NAN之类</strong>的奇怪输出(至少我是遇到了,贼难搞了)</p>
<h2 id="特殊浮点数的含义"><a href="#特殊浮点数的含义" class="headerlink" title="特殊浮点数的含义"></a>特殊浮点数的含义</h2><ul>
<li><p>#INF / inf：这个值表示“无穷大 (<strong>infinity</strong> 的缩写)”，即<strong>超出</strong>了计算机可以表示的<strong>浮点数的最大范围</strong>（或者说超过了 double 类型的最大值）。例如，当用 $0$ 除一个整数时便会得到一个1.#INF / inf值；相应的，如果用 $ 0 $  除一个负整数也会得到 -1.#INF / -inf 值。</p>
</li>
<li><p>#IND / nan：这个的情况更复杂，一般来说，它们来自于<strong>任何未定义结果</strong>（非法）的浮点数运算。”IND”是 <strong>indeterminate</strong> 的缩写，而”nan”是 <strong>not a number</strong> 的缩写。产生这个值的常见例子有：对负数开平方，对负数取对数，$ 0.0/0.0,0.0* \infin, \infin / \infin $ 等。</p>
</li>
</ul>
<p>简而言之，如果遇到 1.#INF / inf，就检查是否发生了运算结果溢出除零，而遇到 1.#IND / nan，就检查是否发生了非法的运算。</p>
<h2 id="特殊浮点数的判断"><a href="#特殊浮点数的判断" class="headerlink" title="特殊浮点数的判断"></a>特殊浮点数的判断</h2><p>很多 C 库都提供了一组函数用来判断一个浮点数是否是INF或 NAN。<strong>int _isnan(double x)</strong> 函数用来判断一个浮点数是否是 NAN，而 <strong>int _finite(double x)</strong> 用以判断一个浮点数是否是INF。</p>
<p>你可能已经注意到了，上面两个函数都是以下划线开头的，因此在可移植性上可能是存在问题的，那么如何实现一个通用的判断版本呢？</p>
<h3 id="对于NAN"><a href="#对于NAN" class="headerlink" title="对于NAN"></a>对于NAN</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Is_Number</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123; <span class="keyword">return</span> (X==X); &#125;</span><br></pre></td></tr></table></figure>
<p>这个操作看起来总会得到true,但神奇的是,对于<strong>IEEE 754浮点数NAN</strong>来说总是false</p>
<h3 id="对于INF"><a href="#对于INF" class="headerlink" title="对于INF"></a>对于INF</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Is_Finite_Number</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123; <span class="keyword">return</span> (X&lt;=DBL_MAX &amp;&amp; X&gt;=-DBL_MAX); &#125;</span><br></pre></td></tr></table></figure>
<p>其中,DBL_MAX是<strong>预定义的常量</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以,<strong>综合运用</strong>上面的<strong>两个函数</strong>,就可以实现浮点数<strong>是否是INF</strong>的判断了</p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/articles/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先这肯定是由<strong>Newton</strong>提出的。。。</p>
<p>这个算法主要是用来解决对于$ [a,b] $之间<strong>连续且单调</strong>的函数$ f(x) $</p>
<p>使得$ f(x)=0 $的<strong>近似解</strong>（当然这个近似需要自己<strong>手动设置</strong>）</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="1初始化近似解"><a href="#1初始化近似解" class="headerlink" title="1初始化近似解"></a>1初始化近似解</h3><p>我们任意取一个近似解为$ x_0 $</p>
<h3 id="2-画出-f-x0-的切线得更优解"><a href="#2-画出-f-x0-的切线得更优解" class="headerlink" title="2.画出$ f(x0) $的切线得更优解"></a>2.画出$ f(x0) $的切线得更优解</h3><p>假设我们目前的近似解是$ x<em>i $，我们画出与$ f(x) $切于点$ (x_i,f(x_i)) $的直线$ l $，将 与$ x $轴的交点横坐标记为$ x</em>{i+1} $，那么这就是一个<strong>更优的近似解</strong>。重复这个迭代的过程</p>
<p><img src="https://i.loli.net/2020/08/13/X1z5BFRpanJEeL4.png" alt="牛顿迭代法-1.png"></p>
<h3 id="3-得出更优解之间得关系"><a href="#3-得出更优解之间得关系" class="headerlink" title="3.得出更优解之间得关系"></a>3.得出更优解之间得关系</h3><p>我们重复这个迭代过程。</p>
<p>根据导数得<strong>几何意义</strong>，可得</p>
<script type="math/tex; mode=display">
f^{'}(x_i= \frac{f(x_i)}{x_i-x_{i+1}}</script><h3 id="4-得出递推式"><a href="#4-得出递推式" class="headerlink" title="4.得出递推式"></a>4.得出递推式</h3><p>因为我们知道$ f(x) $，所以可以直接化简写出<strong>递推式</strong>：</p>
<script type="math/tex; mode=display">
x_{i+1}=x_i- \frac{f(x_i)}{f^{'}(x_{i})}</script><p>因为$ f(x) $比较平滑，随着迭代次数得增多，$x_i$会<strong>越来越逼近方程的解</strong></p>
<p>至于证明，右手就行（<del>口胡</del>）</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>牛顿迭代法的<strong>收敛率</strong>是<strong>平方级别</strong>的，这意味着每次迭代后近似解的<strong>精确数位</strong>会<strong>翻倍</strong></p>
<p>关于其收敛性得证明可参考：<a href="http://en.citizendium.org/wiki/Newton&#39;s_method#Convergence_analysis" target="_blank" rel="noopener">citizendium - Newton method Convergence analysis</a></p>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><h3 id="求解非负实数平方根"><a href="#求解非负实数平方根" class="headerlink" title="求解非负实数平方根"></a>求解非负实数平方根</h3><p>即：求$ f(x)=x^2-n=0 $的<strong>非负实数根</strong>，就是$ \sqrt x $的近似根</p>
<p>于是由分析可得：</p>
<script type="math/tex; mode=display">
x_{i+1}=x_i- \frac{x^2_i-n}{2 \times x_i}=\frac{x_i+ \frac{n}{x_i}}{2}</script><p>所以在实现的时候可以由自定义的精度来调整出适合的近似解</p>
<p>一般会把初始化的$x_0$设置为1.0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-15</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Newton_sqrt</span><span class="params">(<span class="keyword">double</span> New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> X=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"> 		<span class="keyword">double</span> Xn=(X+New/X)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(X-Xn)&lt;Eps) <span class="keyword">break</span>;</span><br><span class="line">        X=Xn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求解整数平方根"><a href="#求解整数平方根" class="headerlink" title="求解整数平方根"></a>求解整数平方根</h3><p>即求出最接近$ x $的<strong>整数根</strong>使得$ x^2 \leq n \Rightarrow x^2-n \leq 0 $</p>
<p>这个与求解非负实数根唯一的不同就边界特判时需要稍作修改</p>
<p>即：如果$x$在迭代过程中上一次迭代值近似解变小，而这次的迭代值变大，那么我们就不进行迭代了，直接退出。（因为求的是整数解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Newton_int_sqrt</span><span class="params">(<span class="keyword">int</span> New)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> X=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> Jud=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"> 		<span class="keyword">int</span> Xn=(X+New/X)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(X==Xn || (Xn&gt;X &amp;&amp; Jud)) <span class="keyword">break</span>;</span><br><span class="line">        Jud=Xn&lt;X;</span><br><span class="line">        X=Xn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度平方根"><a href="#高精度平方根" class="headerlink" title="高精度平方根"></a>高精度平方根</h3><p>高精度的平方根和低精度唯一的不同就是：使用高精度那么答案一定很大，若果直接设$x_0=1$那么<strong>时间复杂度</strong>上边就<strong>得不到保证</strong></p>
<p>所以，很自然就可以想到取一个绝对正确的更近似解$ x_0=2^{ \frac{1}{2}\lfloor log_2n \rfloor } $</p>
<p>具体的代码实现就免了。。。</p>
<p>当$ n=10^{1000} $时，该算法可以达到<strong>60ms</strong>，而不优化时为<strong>120ms</strong></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载)写给OIer们的一些话</title>
    <url>/articles/%E8%BD%AC%E8%BD%BD-%E5%86%99%E7%BB%99OIer%E4%BB%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="转载-写给OIer们的一些话"><a href="#转载-写给OIer们的一些话" class="headerlink" title="(转载) 写给OIer们的一些话"></a>(转载) 写给OIer们的一些话</h1><p>我是一个高二的OIer，离我正式退役的日子已经不超过一年了。在这个时期，与其写一些回忆性的文字，不如跳出“自我”的范畴，以一种比较全局的角度和大家一起分享一些我对OI的认知和看法。目的是让初三高一的学弟学妹看清眼前的路，让高二高三的人了解自己走过的足迹。</p>
<h2 id="一-独特的模式"><a href="#一-独特的模式" class="headerlink" title="一.独特的模式"></a>一.独特的模式</h2><h3 id="知识的更新"><a href="#知识的更新" class="headerlink" title="知识的更新"></a>知识的更新</h3><p>我们先从OI的比赛日程谈起。选手获得NOIP一等奖后，可以报名参加WC（时间为1-2月）。而在5月，选手即使没有通过省选进入省队，也可以报名参加CTS(C)。其中WC和CTS(C)不仅是信息集训队的两轮选拔，也是非集训队选手得奖的机会。而每年的WC，都会安排集训队选手和前集训队选手进行授课。每年的CTS(C)，会安排候选队选手（去年是候选队前6）来进行英语自我介绍和论文答辩，这一项的分数是要按一定权重计入集训选拔分数的。对于一个集训队选手来说，他不仅需要完成题目，还必须写一篇关于集训队作业某些题的解题报告，甚至可能需要写命题报告。如果他进入候选队，那么他必须写一篇候选队论文。有时候选队15人会组成小组互相出题给对方做，这被称为候选队互测。</p>
<p>撇去“收钱”的原因，为什么CCF要这么安排？因为CCF明白<strong>OI的知识范围的更新只能靠水平较高的优秀选手来完成，之后服务OI的主力军也是他们</strong>，而WC和CTS正是新的知识点向各个选手普及的过程。例如：2008年陈丹琪论文中出现了cdq分治，WC2012的陈立杰的《后缀自动机》讲稿，在2013候选队论文《浅谈数据结构的几个非经典解法》中出现的二进制分组的思想，在2015集训队论文出现的多项式求逆、ln、exp等技巧，以及在2019年WC讲授的模拟费用流问题。硬性规定的解题报告、命题报告，是对他们之后出题工作的一个很好的训练。</p>
<p>那些新潮的知识点会借助互联网的平台逐步往下传。一开始在那些大佬们的博客中出现，然后是一些高层次的比赛的题目（比如WC，CTS），接着是很多强校的模拟赛，最后就是NOI、省选、NOIP的真题了。在传递过程中，这些idea会经历一定时间的考验和衡量。最后我们留下那些能简化代码量的、对某些问题非常适用的、具有考察价值的知识点，在1-5年的时间内成为我们必须要学习的内容。</p>
<p>这样的安排无疑带来了非常好的效果，给OI的知识体系增添了活力。唯一美中不足的是：缺少能看懂候选队论文的评委。每次答辩的时候，评委总是会问一些质量不高、无关紧要的问题。也许是因为CCF也知道这一点，除了一些极端情况外，候选队论文答辩的分数不影响最终国家队的名单。</p>
<h3 id="命题的故事"><a href="#命题的故事" class="headerlink" title="命题的故事"></a>命题的故事</h3><p>那些集训队选手毕业后一部分会加入清华或北大的算法协会，在1-5年后成为比赛出题人。命题的工作需要寻找一个“灵感”，就是这道题的核心想法。在那之后还要经历撰写题面，编写标程，设计部分分，验证数据正确性和强度等一系列步骤才能真正完成一道题目的命制过程。一般而言，为NOI系列赛事命题有数百至上千元的报酬，但这些费用只是一种“辛苦费”。<strong>如果单从功利的角度来说，讲课或者专心学术是更好的选择。他们这么做完全是出自于一种对于OI的情怀。</strong></p>
<p>但命题质量和数量的保障，甚至保密性都只能由他们自己来保证。如果在NOI附近正好处于出题人们idea的枯竭期，那么NOI的质量势必不高。如果出题人正好要准备大学的期中考试等事情，那么他很难全副身心地去做出题的工作。就算出题人很用心的出了一道题，但是这道题也有可能因为难度不合适等问题而不适合出现在比赛中。也可能是因为这些原因，OI历史上出现过很多设计不合理的比赛。ZJOI2018的难度过高、区分度过低，CTSC2018的题目出错，NOIP2018的原题现象，CTS2019的知识点分布不合理都是鲜活的例子。</p>
<p>改进质量的方法，很大程度上仰仗于OIer与命题人的反馈交流，迫使出题人做出调整。你会在知乎上看到“如何评价xxxx（某比赛）”问题，就是出题人与选手的互动。底下这些评论往往表达选手的做题体验和出题人的出题经历，例如 [1]。最近还出现一些选手在自己出模拟赛的过程中探讨出题的准则，比如 [2] 。 出题人了解某道题的得分情况和选手对这道题的评价后，他才能了解选手的普遍水平，才能了解哪些类型的题是对当下选手最具有考察价值的。在2017年某个出题人出过一道名为《挑战》的题，正解是使用底层优化（卡常）使理论复杂度很高的算法通过匪夷所思的范围$ (O(n^2) $跑$ 3e5,O(n) $跑$ 2e8) $。这场比赛当天该题被批判的声音就层出不穷了。之后这位出题人出的题，质量就有了很大的改观。</p>
<h3 id="学习的过程"><a href="#学习的过程" class="headerlink" title="学习的过程"></a>学习的过程</h3><p>作为一个选手，你最关心的可能是学习OI的过程。在NOIP提高组以下的层面，学习知识点可以通过看书，但是在这以上，尤其是针对较新的知识点的学习，就要依靠网上的博客了。博客一般是由现役的选手来完成的。但博客的质量鱼龙混杂，良莠不齐，你在百度上搜lct，10篇里面有6篇的findroot后没有splay。即使是水平较高的选手，他们写的题解也不一定能让别人容易看懂，很多时候简略到只有一句话。一个普遍的问题是讲解知识点或题目的时候单单着重于结论、算法过程，没有把这个结论为什么是正确的、这个算法为什么要想到这两个问题讲清楚。[3] 表达了和我类似的想法。你有时看到题解大呼”太巧妙了”，“太神仙了”，其实是因为没有体会到思考的全过程。为了解决博客质量的问题，我们建立了OI-wiki，shareOI，洛谷的题解拥有严格的审核机制。</p>
<p>洛谷、LOJ、UOJ上的学习资料是免费的，网上的博客是可以直接搜到的，是面对所有OIer的。在这个资源共享化的时代，你只要肯下功夫学，就有丰富的资料和题目可供学习。这一定程度上拉平了强校与弱校的差距。但是由于我上一段提到的原因，学习不能完全依靠于博客等资料，需要有选手来带，需要有优质的模拟题来增加比赛经验。往往只有强校能请的了上一届的优秀选手、教练来讲课，能拥有不对外公开的模拟题和OJ，所以强校与弱校的差距也将长期存在。</p>
<p>另一个重要的方面是讲课，这一工作也由高水平选手承担。讲课一种是在机构受聘讲课，另一种是在自己的母校讲课（这种包括现役选手和退役选手）。前者的特点是受惠面积广，能够让更多人学习。后者的特点是学生较少，容易通过调整自己的讲课方式来满足本校学生的需求。相比于前者，后者带有更多的自愿性。前者推动了OI资源的共享，而后者起到推动一个学校发展的作用。这并不是说前者优于后者或后者优于前者，事实上两者都是必不可少的。特别是对我们学校来说，让上一届去带下一届是向外省强校追赶的必不可少的环节。而一个小集体的发展与一个大集体的发展是相互联系的，有时一个学校的优秀选手可以带动一个省的崛起。</p>
<h3 id="一条从未走过的路"><a href="#一条从未走过的路" class="headerlink" title="一条从未走过的路"></a>一条从未走过的路</h3><p>OI的知识与我们小学中学所学的东西是无关的，甚至与大学所学的算法和主流的计算机科学界关系都不是很大，它是一个相对独立而封闭的体系。我们缺少完全理解OI知识体系的老师，我们缺少能够长期命题的出题人，我们缺少专业的研究者。我们面临了种种不利的客观条件，这些是其它四大竞赛所没有的困难。</p>
<p>但我们不曾放弃，我们不曾退缩。我们竭尽全力探索出一种符合OI竞赛特点的模式。这往大里说，是“计算机普及要从娃娃抓起”的践行；往小里说，是为适应时代做出的努力。</p>
<p>我们终究探索出了一条从未走过的路，那便是<strong>以OIer本身为主导的OI模式！</strong>我们用已经培养出来的OI选手去担任知识引入、命题、授课的工作，用上一届OIer带动下一届OIer，再让下一届带动更下一届。我们借助互联网的平台，发挥它传播信息迅速的优势，把所有的OI选手们连接成一个整体。把而竞赛教练的作用，更多的是去维持这种模式，带动这种模式。</p>
<p>这样的模式是偏向于“用爱发电”的，它的核心基础是<strong>OIer们对OI本身持久的情怀</strong>。它的优点是让OI界具有很强的活力，给选手学习很大的自由度，也对OI的过度商业化，功利化形成了很好的保护。它也使得”OIer群体“这个概念有了很大的地位。</p>
<p>不过也容易想到它是脆弱的、不成熟的，在前面你可以看到它的缺陷。一旦OIer们全都由于一些现实上的原因没有继续服务于OI，必然会使这个体系有崩塌的风险。但它具有很强的<strong>不可替代性</strong>，无论是知识引入还是出题、授课，都只有OIer能胜任。这种模式在现实条件下几乎是唯一的解，所以它是很难撼动的。所以我们应该想的是<strong>在方式方法层面上做一些改进</strong>，让OI的未来变得更好。</p>
<h2 id="二-OIer的价值"><a href="#二-OIer的价值" class="headerlink" title="二.OIer的价值"></a>二.OIer的价值</h2><h3 id="开拓者"><a href="#开拓者" class="headerlink" title="开拓者"></a>开拓者</h3><p>你打开OJ，思考一道题目。你满足于OJ页面的精致，你陶醉于算法世界的美妙。你可曾想过这些题目是谁出出来的，你可曾想过OJ的搭建和维护者是谁？他们是某一个特别的OIer的群体。他们中有洛谷的创办者kkksc03，LOJ的创办者menci和UOJ的创办者vfk。</p>
<p>你可以从 [4]、[5] 和 [6] 中窥探出当年他们创办UOJ、LOJ的一些理念。我们在第一篇文章中截取两段：</p>
<p>“不得不说今天是个伤感的夜晚。我们此时站在这里，连接过去和未来。曾以为我们的计划会成为我们的未来，却不知道大浪拍击沙滩的力量比飓风更有力。UOJ从哪里来？今晚的UOJ还是一年前发布时的那个UOJ吗？为什么我们慢慢忘了那最虔诚的最初，渐行渐远……于是我意识到，我们应该回去，回头看看那最初的原点。最初我是怀着对OI界题目的不满，最初我和业界毒瘤有很多比较难的脑洞想出给大家玩，最初的最初是那场引发我对OI比赛的思考的NOI2013……我们想建立的是，一个能自由评测各种类型题目的OJ，一个题题高质量的OJ，一个定期举办高质量的比赛的OJ —— 一个能带给OIer思考与收获的OJ。”</p>
<p>“我想起了我最初的一句’宁缺毋滥’，我想起了激励了我很长时间的洛克菲勒与协和医院的故事：我们要以最高标准建一所医院，成为中国医学界的一座标杆 —— 而我们清楚地知道，论题目的数量，世界上千万万OJ不缺我们UOJ一家，我们要做的就是聚集最优秀最热爱信息学的OIer，建立一个题目质量难以企及的OJ。”</p>
<p>500多道UOJ题目，上千道LOJ题目，数万个OIer……今天你会看到各个学校的OJ如雨后春笋般增长，就归功于他们用一行行代码缔造的平台。今天你会听到OIer对比赛、对题目的广泛讨论，而那些新潮的想法其实来源于vfk在那几篇博客上阐述的”好题“、“毒瘤题”的定义。今天我们从自己的成长之路向前追朔，也总能够追朔到他们的所创造的资源。</p>
<p>他们是灯塔，他们是引路人。他们开拓了一条OI资源共享化的道路，他们以数十人之力创造了数万人的价值。在之后的社会上，你很难看到像他们一样完全坚持自己的初心、梦想，无私地奉献自己的一切而不求任何回报的人了。我们希望他们的那些文字能够在OI的历史上熠熠生辉。</p>
<h3 id="不可或缺的角色"><a href="#不可或缺的角色" class="headerlink" title="不可或缺的角色"></a>不可或缺的角色</h3><p>诚然，我们很难像他们一样对整个OI界做出很大的贡献，对他们的态度也只是停留在“虽不能至，心向往之”的层面。那么我们的价值又在何处呢？</p>
<p>很多学校的教练都会在我们还是初三或高一时请高二的学长给我们来讲课。一年过后，我们欢送他们退役，但我们站在他们的肩膀上，经过各种比赛的磨练，使自己变得更强。当我们磨练得差不多时候，我们就成了学长，就被要求给下一届的学弟学妹们讲课。WC2018的两首改编歌词《我的一个OIer朋友》，《退役的你》（详见 [7] 、 [8] ）是这段时光的真实写照。我们从第一首里面截取一段：</p>
<blockquote>
<p>“他们说的退役太沉重，你在路上追着你的梦。                                     </p>
<p>​         前路会与过往不同，但精彩纷呈。                                    </p>
<p>而我深夜刷题至三更，大赛过后睡眼正惺忪。                                    </p>
<p>恍然之间终于看懂，当年你笑容，谈何轻松？                                    </p>
<p>不如将你镌刻在心中，以足迹为路以背影为灯。                                    </p>
<p>​       去年今日你的歌声，由我来传承……”</p>
</blockquote>
<p>在这一段OI的旅途中，我们送走了一批人，又迎接了新的一批人。 我们把从学长那里得到的东西，经过自己的再加工、再整理，传递给下一届，然后由知识的接受者变为了知识的传播者。我们成了手握接力棒的人，成了连接过去和未来的人。这段旅途中难免有送别的伤感，但薪火相传的使命与责任，才是主旋律。</p>
<p>如果我们中出现了一个优秀选手，那么就会产生更大的贡献。一是会吸引更多的OIer来这所学校学习，然后进一步提高下一届选手的水平。比如我在初三时选择进入华二而非上中，是因为看到2017年华二CMO进了5个集训队，而上中只进了一个。二是会使整个省的目标提高，进而带动整个省的水平。在2016年前，可能上海的目标是争取更多银牌选手。但因为像吕时清、何文阳之类的优秀选手出现，特派员开始朝着金牌这个目标努力了。他会亲自那些不错的OIer下发题目，亲自评测、会在NOIP/CSP前安排几次针对全市选手的模拟赛，会请外省的集训队选手来讲课。最终上海在CTS，APIO，NOI上实现了这一目标。</p>
<p>哪怕你只是初二、初三、高一的OIer，还没有达到给学弟学妹讲课的阶段，你也会不知不觉中影响很多人。在这个资源高度共享的时代，你不经意间说的话，写的东西就可能会被数百人看到，然后数百人传给更多人。就像我博客里面写的“JOISC 2020自闭记”，阅读量已经达到了530人，而我认识的OIer也不过100人。也许这530人还会传给他们的朋友、他们的下一届选手，说不定就有1000人直接或间接地看到了我写的题解了。</p>
<h3 id="另一种价值"><a href="#另一种价值" class="headerlink" title="另一种价值"></a>另一种价值</h3><p>由于OI竞赛本身这种独特的模式，OIer群体的概念与个体的概念，拥有同等的地位。所以一个OIer在他的生涯中，不仅存在个人价值（比如拿一等奖，进省队，进集训队），还存在着另一种价值，那便是个人对OIer群体的价值。</p>
<p>很多时候实现个人价值也是实现这种价值，这种价值是个人价值的延续，因为高水平选手给OI界可能创造的价值越多。但和个人价值不同的是，这种价值所影响的时间更长，所影响的范围更广。也许我们退役过后，我们所获得的奖项，只是OIerdb上那一条条数字了。<strong>个人价值是一个OIer退役后所带走的，但这种价值是一个OIer退役后留下的东西</strong>，它是不会过时的。你为你身边的OIer所做的事情，像是埋下一粒种子，它会在几年之内生根、发芽，长成一棵大树，甚至繁殖出更多的生命。vfk那一代的OIer很难想到他所创办的UOJ能使这么多人受益，王聿中、吕时清、王润泽那一代的OIer也没有想到他们的努力会使上海在NOI2019进入3个集训队。但这一切，都在不久的将来发生了。</p>
<p>所以我们在学习知识之余，也要想一想我能为我身边的OIer做些什么，我能为整个学校做些什么，我能为整个市做些什么，我能为整个OI界做些什么？知识层面上的贡献有：出题、讲课、写论文等。另一种贡献是文、史、哲层面上的，比如Tangenter写《整型溢出》一书整理2016-2019年的OI历史。即使我们还没有达到为别的OIer做事情的阶段，我们也要了解别人给OI界带来的贡献，我们也要对那些为我们付出过的前辈们怀以感激，怀以敬意。</p>
<h2 id="三-渺小而卑微的坚持"><a href="#三-渺小而卑微的坚持" class="headerlink" title="三.渺小而卑微的坚持"></a>三.渺小而卑微的坚持</h2><p>时间、运气、命运对OIer们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的OIer，也难以保证他在省选或NOI一定能够有和他的付出对等的回报。这是很多OIer心知肚明的事实，也是我们无力感的根源。</p>
<p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p>
<p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打cf，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100分与0分之差，一个部分分之差就可能是20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p>
<p>OIer之外的人对他们有两种极端的态度。一种是以竞赛的风险为理由，劝说（甚至逼迫）他们放弃OI竞赛而去搞高考。这些人否认OI给他们带来的意义，没有看到他们在OI方面的付出。也许从数学期望的角度，这是较优解，我们不必做过多的批判。但这种态度杀灭了他们的纯粹的梦想，给他们的青春留下无法抹去的遗憾，甚至伤痕。另一种是盲目地支持，为了走这条路而断绝他们的一切后路，放弃一切OI之外的事务。人不是机器，过度的、长时间的投入是否会产生和这种投入成正比的收获，是不好说的。即使成功了，它能否补偿他们所失去的东西，也是不好说的。这种态度产生的根源是没有客观地认识到OI的风险，把竞赛和高考的两套评价体系完全地割裂开来，甚至当成对立面。</p>
<p>我们应有的态度是怎样的呢？应该是一个朋友的角色。我们可以在他们考砸的时候予以安慰，可以在他们考好的时候予以鼓励。我们可以和他们一起讨论题目，一起学习算法，一起打模拟赛，甚至在空闲时刻聊一些游戏、漫画的内容。我们既要提供助力他们成功的实质性帮助，也要想方设法缓解他们的压力感和孤独感。当然，我个人认为，不必对他们的选择做过多的干预，因为我们很难完全理解他们的内心想法，很难影响也不应去影响他们的命运。至于决定他们是选择坚持还是放弃，应该是老师和家长所做的事情。</p>
<p>如果你觉得他们离你很遥远，<strong>请你不要像某些人一样用好坏利弊简单地评判他们的选择，请你不要抱着“与我无关”的态度。</strong></p>
<p><strong>如果你正好就是那些选择孤注一掷的OIer，请你相信有无数的OIer是支持你的，请你相信你的付出终将会在某个时刻回报你，请你相信无论怎样，你在这个过程中成长了、收获了。但也要告诉你，既然有勇气坚持走下去，也要有勇气承担它带来的一切结果。</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实我写这篇博客的想法，可以追溯到北大集训期间LCA给我们讲的一些话。在他的讲话过后，我了解到了OI diary，我了解到了OI survey。我看到了有一位前OIer去主动地查找资料，以一个选手的视角记录前几年OI界发生的事情，甚至有一个人想编撰一部完整的OI史。我发现OIer们做了很多学习知识之外的事情，例如对自身价值的探索，对学习竞赛的意义、乃至生命的意义的探讨。这种东西既体现在某一小群OIer所写的长篇的文章里面，又渗透到了很多OIer博客里的随感。于是我也对OI界的一些现状做了简单的思考，整理成了这篇博客。</p>
<p>如果从写文章的角度来说，第一、第二节可以构成一个完整的主题，而第三节显得有点画蛇添足。但是在我身边真的有很多选择孤注一掷地搞OI的人，其实在我的学校里就有，而他们面临的环境并不乐观。我特别想为他们说一些话，却不知道何时能说，却不知道从何说起。所以我就在这个机会为他们说出我的心里话。</p>
<p>最后，感谢你能够读完这篇博客，也希望这份思想的火炬永不熄灭！</p>
]]></content>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何选讲</title>
    <url>/articles/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算几何选讲"><a href="#计算几何选讲" class="headerlink" title="计算几何选讲"></a>计算几何选讲</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大家都已经<strong>很熟悉</strong>这些知识点了，我们就<strong>简要说明</strong>一下即可</p>
<p>对于计算几何，其实<strong>原理</strong>都<strong>很简单</strong>，只是比较难想。</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在平面上能<strong>包含所有给定点</strong>的<strong>最小凸多边形</strong>叫做<strong>凸包</strong>。</p>
<p>或：对于给定集合$X$，所有包含$ X $的<strong>凸集的交集</strong>$S$被称为$X$的 <strong>凸包</strong> 。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>常用算法为<strong>Graham扫描法</strong>和<strong>Andrew算法</strong>。</p>
<p>对Graham扫描法有兴趣的大佬可以自行了解一下</p>
<p><strong>蒟蒻</strong>我只学过Andrew算法。。。</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>凸包是一个凸多边形，证明显然</p>
<p><img src="https://i.loli.net/2020/08/15/HP1Kd9MoyOitrwq.png" alt="计算几何选讲-1.png"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>将所有的平面点<strong>按照</strong>$x$大小来排序</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>将$ p_1,p_2 $放入凸包，从$p_3$开始，若当前点在<strong>栈顶两点</strong>所在直线的左侧，则加进栈，否则弹出栈顶，接受新点</p>
<p>参考上边的图</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2742</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Top,Stack[MAXn],Ans;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXn];</span><br><span class="line"><span class="keyword">double</span> Res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> Fir,Sec;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) &#123; </span><br><span class="line">		<span class="keyword">if</span>(A.Fir==B.Fir) <span class="keyword">return</span> A.Sec&lt;B.Sec; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> A.Fir&lt;B.Fir;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Num[MAXn],Bag[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node X,Node Y)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)(X.Fir-Y.Fir)*(X.Fir-Y.Fir)+(<span class="keyword">double</span>)(X.Sec-Y.Sec)*(X.Sec-Y.Sec)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Node X,Node Y)</span> </span>&#123; <span class="keyword">return</span> X.Fir*Y.Sec-X.Sec*Y.Fir; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Side</span><span class="params">(Node X,Node Y,Node Z)</span> </span>&#123; </span><br><span class="line">    Node A=Node&#123;Y.Fir-X.Fir,Y.Sec-X.Sec&#125;;</span><br><span class="line">    Node B=Node&#123;Z.Fir-X.Fir,Z.Sec-X.Sec&#125;;</span><br><span class="line">    <span class="keyword">return</span> Cross(A,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Num[i].Fir,&amp;Num[i].Sec);</span><br><span class="line">    sort(Num+<span class="number">1</span>,Num+Total+<span class="number">1</span>); Top=<span class="number">0</span>;</span><br><span class="line">    Stack[++Top]=<span class="number">1</span>;</span><br><span class="line">    FOR(i,<span class="number">2</span>,Total) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Top&gt;=<span class="number">2</span> &amp;&amp; Side(Num[Stack[Top<span class="number">-1</span>]],Num[Stack[Top]],Num[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">        Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Temp=Top;</span><br><span class="line">    BOR(i,Total<span class="number">-1</span>,<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">if</span>(!Vis[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(Top&gt;Temp &amp;&amp; Side(Num[Stack[Top<span class="number">-1</span>]],Num[Stack[Top]],Num[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">            Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Top<span class="number">-1</span>) Res+=Distance(Num[Stack[i]],Num[Stack[i+<span class="number">1</span>]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,Res);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>旋转卡壳可以用于求<strong>凸包的直径、宽度，两个不相交凸包间的最大距离和最小距离等</strong></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><img src="https://i.loli.net/2020/08/15/zr5DjhAw3MWV1lN.gif" alt="计算几何选讲-2.gif"></p>
<p>被一对卡壳正好卡住的对应点对称为<strong>对踵点</strong></p>
<p>可以证明对踵点个数<strong>不会超过$ \frac{3}{2} N $个</strong>，也就是说对踵点个数是$O(N)$的</p>
<p>所以，我们可以模仿凸包的<strong>栈思想</strong></p>
<p>因为，每次最优解必然存在于对踵点对集合中</p>
<p><img src="https://i.loli.net/2020/08/15/LKQ6JRl9WjHU5X7.png" alt="计算几何选讲-4.png"></p>
<p>所以每次比较</p>
<p><img src="https://i.loli.net/2020/08/15/uP8v3ziGJnBfpQr.png" alt="计算几何选讲-3.png"></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1452 POJ 2187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sign</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(Temp)&lt;Eps ? <span class="number">0</span> : (Temp&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (Point A,Point B) &#123; Point Temp; Temp.X=A.X-B.X; Temp.Y=A.Y-B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> + (Point A,Point B) &#123; Point Temp; Temp.X=A.X+B.X; Temp.Y=A.Y+B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> * (<span class="keyword">double</span> A,Point B) &#123; Point Temp; Temp.X=A*B.X; Temp.Y=A*B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> * (Point A,Point B) &#123; <span class="keyword">return</span> A.X*B.X+A.Y*B.Y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> ^ (Point A,Point B) &#123; <span class="keyword">return</span> A.X*B.Y-A.Y*B.X; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point A,Point B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.X!=B.X ? A.X&lt;B.X : A.Y&lt;B.Y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Dot[MAXn];</span><br><span class="line"><span class="keyword">int</span> Total,Top,u,v,w,Cnt=<span class="number">2</span>,Stack[MAXn];</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXn];</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Point A,Point B,Point T)</span> </span>&#123; <span class="keyword">return</span> (B-A)^(T-A); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> Temp*Temp; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point A,Point B)</span> </span>&#123; <span class="keyword">return</span> (Power(A.X-B.X)+Power(A.Y-B.Y)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack[++Top]=<span class="number">1</span>;</span><br><span class="line">    FOR(i,<span class="number">2</span>,Total) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Top&gt;=<span class="number">2</span> &amp;&amp; Cross(Dot[Stack[Top<span class="number">-1</span>]],Dot[Stack[Top]],Dot[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">        Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Temp=Top;</span><br><span class="line">    BOR(i,Total<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Vis[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(Top&gt;Temp &amp;&amp; Cross(Dot[Stack[Top<span class="number">-1</span>]],Dot[Stack[Top]],Dot[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">            Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[i].X,&amp;Dot[i].Y);</span><br><span class="line">    sort(Dot+<span class="number">1</span>,Dot+Total+<span class="number">1</span>);</span><br><span class="line">    Andrew();</span><br><span class="line">    FOR(i,<span class="number">1</span>,Top<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Cross(Dot[Stack[i]],Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt]])&lt;Cross(Dot[Stack[i]],Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt+<span class="number">1</span>]])) &#123; Cnt++; <span class="keyword">if</span>(Cnt&gt;Top<span class="number">-1</span>) Cnt=<span class="number">1</span>; &#125;</span><br><span class="line">      Ans=<span class="built_in">max</span>(Ans,<span class="built_in">max</span>(Distance(Dot[Stack[i]],Dot[Stack[Cnt]]),Distance(Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一条直线和直线的一侧。半平面是一个<strong>点集</strong>，因此是一条直线和直线的一侧构成的点集。当包含直线时，称为<strong>闭半平面</strong>；当不包含直线时，称为<strong>开半平面</strong>。</p>
<p>解析式类似于<strong>线性规划</strong>$ \Rightarrow Ax+By+X \geq 0 $</p>
<p>通常会<strong>统一</strong>以向量的左侧或者右侧作为半平面</p>
<p><img src="https://i.loli.net/2020/08/15/eSgtrfZN4R6dbLx.gif" alt="计算几何选讲-5.gif"></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>我们维护每一条直线为一个向量，并利用函数<strong>atan2(double y,double x)</strong>，返回$ \theta \in (- \pi,\pi], \theta=arctan \frac{y}{x} $</p>
<p>进行<strong>极角排序</strong>，得到新的边集</p>
<p>温馨提示：</p>
<p>排序时，如果遇到<strong>共线向量</strong>（且方向相同），则取<strong>靠近可行域</strong>的一个。比如两个向量的极角相同，而我们要的是向量的左侧半平面，那么我们只需要保留左侧的向量。判断方法是取其中一个向量的起点或终点与另一个比较，检查是在左边还是在右边。</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>我们维护一个<strong>单调队列</strong></p>
<p>即维护一个凸壳，同理，进行队首队次首和新直线的对比</p>
<p>当然，我们维护一个<strong>交点数组</strong></p>
<p>对于当前向量，如果上一个交点在这条向量表示的半平面交的 <strong>异侧</strong> ，那么上一条边就没有意义了。</p>
<p><img src="https://i.loli.net/2020/08/15/W7bLrfyn2RgG1q9.png" alt="计算几何选讲-6.png"></p>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>当出现一个可以把队列里的点<strong>全部弹出去</strong>的向量（即所有队列里的点都在该向量的右侧），则我们 <strong>必须</strong> <strong>先处理队尾，再处理队首</strong>。因此在循环中，我们先枚举 <code>--r;</code> 的部分，再枚举 <code>++l;</code> 的部分，才不会错。原因如下。</p>
<p><img src="https://i.loli.net/2020/08/15/WjdGPueO41YngFk.png" alt="计算几何选讲-7.png"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Head=<span class="number">1</span>,Tail=<span class="number">0</span>,Cnt,Side,Tot;</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (Point A, Point B) &#123; Point Temp; Temp.X=A.X-B.X; Temp.Y=A.Y-B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> + (Point A, Point B) &#123; Point Temp; Temp.X=B.X+A.X; Temp.Y=B.Y+A.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> * (Point A, Point B) &#123; <span class="keyword">return</span> A.X*B.X+A.Y*B.Y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> ^ (Point A, Point B) &#123; <span class="keyword">return</span> A.X*B.Y-A.Y*B.X; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> * (<span class="keyword">double</span> K, Point B) &#123; Point Temp; Temp.X=B.X*K; Temp.Y=B.Y*K; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">&#125;Dot[MAXn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sign</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(Temp)&lt;=Eps ? <span class="number">0</span> : (Temp&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Point S,E;</span><br><span class="line">    <span class="keyword">double</span> Slope;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A, Node B) &#123;</span><br><span class="line">        <span class="keyword">return</span> Sign(A.Slope-B.Slope)==<span class="number">0</span> ? Sign((A.E-A.S)^(B.E-A.S))&gt;<span class="number">0</span> : Sign(A.Slope-B.Slope)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Line[MAXn],Mine[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Inter</span><span class="params">(Node A,Node B)</span> </span>&#123;</span><br><span class="line">    Point S1=A.S,S2=B.S,E1=A.E,E2=B.E;</span><br><span class="line">    E1=E1-S1,E2=E2-S2;</span><br><span class="line">    Point Temp=S2-S1;</span><br><span class="line">    <span class="keyword">return</span> S2+((Temp^E1)/(E1^E2))*E2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inline Point Inter(Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">    Point S1=A.S,S2=B.S,E1=A.E,E2=B.E;</span></span><br><span class="line"><span class="comment">    E1=E1-S1;E2=E2-S2;</span></span><br><span class="line"><span class="comment">    Point Temp=S2-S1;</span></span><br><span class="line"><span class="comment">    return S2+((Temp^E1)/(E1^E2))*E2;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(Node A,Node B,Node X)</span> </span>&#123;</span><br><span class="line">    Point Temp=Inter(A,B);</span><br><span class="line">    <span class="keyword">return</span> Sign((X.E-X.S)^(Temp-X.S))&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Half_Plane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(Line+<span class="number">1</span>,Line+Cnt+<span class="number">1</span>); </span><br><span class="line">    FOR(i,<span class="number">1</span>,Cnt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Sign(Line[i].Slope-Line[i<span class="number">-1</span>].Slope)!=<span class="number">0</span>) Tot++;</span><br><span class="line">        Line[Tot]=Line[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Mine[++Tail]=Line[<span class="number">1</span>];Mine[++Tail]=Line[<span class="number">2</span>];</span><br><span class="line">    FOR(i,<span class="number">3</span>,Tot) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Tail<span class="number">-1</span>],Mine[Tail],Line[i])) Tail--;</span><br><span class="line">        <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Head+<span class="number">1</span>],Mine[Head],Line[i])) Head++;</span><br><span class="line">        Mine[++Tail]=Line[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Tail<span class="number">-1</span>],Mine[Tail],Line[Head])) Tail--;</span><br><span class="line">    <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Head+<span class="number">1</span>],Mine[Head],Line[Tail])) Head++;</span><br><span class="line">    Mine[Tail+<span class="number">1</span>]=Mine[Head]; Cnt=<span class="number">0</span>;</span><br><span class="line">    FOR(i,Head,Tail) Dot[++Cnt]=Inter(Mine[i],Mine[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Side);</span><br><span class="line">        FOR(j,<span class="number">1</span>,Side) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[j].X,&amp;Dot[j].Y);</span><br><span class="line">        Dot[Side+<span class="number">1</span>]=Dot[<span class="number">1</span>];</span><br><span class="line">        FOR(j,<span class="number">1</span>,Side) Line[++Cnt]=Node&#123; Dot[j],Dot[j+<span class="number">1</span>] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Cnt) &#123; Line[i].Slope=<span class="built_in">atan2</span>(Line[i].E.Y-Line[i].S.Y,Line[i].E.X-Line[i].S.X); &#125;</span><br><span class="line">    Half_Plane();</span><br><span class="line">    Dot[Cnt+<span class="number">1</span>]=Dot[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(Cnt&gt;<span class="number">2</span>) FOR(i,<span class="number">1</span>,Cnt) Ans+=(Dot[i]^Dot[i+<span class="number">1</span>]);</span><br><span class="line">    Ans=<span class="built_in">fabs</span>(Ans)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>递归求逆元</title>
    <url>/articles/%E9%80%92%E5%BD%92%E6%B1%82%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个内容只是作为一个补充,所以就<strong>简要</strong>记录一下</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>如果对于每个数都进行<strong>单次求解逆元</strong>$ O(nlog(mod)) $,当$n$<strong>非常大</strong>的时候,当然就不行了,所以此时需要进行$ O(n) $<strong>快速求解</strong></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>１.首先很显然由<strong>费马小定理</strong>知$ 1^{-1} \equiv 1 (mod\,\,\,p) $</p>
<p>２.然后,设$ p=ki+j,j&lt;i,1&lt;i&lt;p $,再放到$ mod\,\,\,p $意义下就会得到:$ ki+j \equiv 0 (mod\,\,\,p) $</p>
<p>３.两边<strong>同时乘</strong> $ i^{-1},j^{-1} $</p>
<p>４.可得:</p>
<script type="math/tex; mode=display">
kj^{-1}+i^{-1} \equiv 0 (mod\,\,\,p) \\
i^{-1} \equiv -kj^{-1} (mod\,\,\,p) \\
i^{-1} \equiv -( \frac{p}{i}) (p\,\,\,mod\,\,\,i)^{-1}</script><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">FOR(i,<span class="number">2</span>,Limit) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;</span><br></pre></td></tr></table></figure>
<h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><ul>
<li><p>使用$ p- \frac{p}{i} $是为了<strong>防止出现负数</strong></p>
</li>
<li><p>根据线性求解逆元的方法的式子:$ i^{-1} \equiv -kj^{-1} (mod\,\,\,p) $ </p>
<p>可以<strong>递归</strong>求解就$ j^{-1} $,直到$ j=1 $<strong>直接返回1</strong></p>
<p>中间优化可以加入<strong>记忆化</strong>来避免多次递归导致重复,这样求解$ 1,2, \cdots,n $所有的数时间<strong>复杂度</strong>还是$ O(n) $</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>随机增量法</title>
    <url>/articles/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随机增量法"><a href="#随机增量法" class="headerlink" title="随机增量法"></a>随机增量法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>随机增量法</strong>是一个有手就行的算法,对<strong>理论知识的要求不高</strong>,且算法的<strong>时间复杂度低</strong>,<strong>应用范围广</strong></p>
<p><strong>增量法</strong>思想与<strong>数学归纳法</strong>相似,<strong>本质</strong>是将问题转化为规模<strong>正好小一层</strong>的<strong>子问题</strong>,<strong>递归</strong>解答</p>
<script type="math/tex; mode=display">
T(n)=T(n-1)+G(n)</script><p><strong>温馨提示</strong>:为了防止题目的<strong>毒瘤卡法</strong>,一般需要<strong>初始随机化</strong>,比如:random_shuffle()等</p>
<h2 id="经典回顾"><a href="#经典回顾" class="headerlink" title="经典回顾"></a>经典回顾</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P1742" target="_blank" rel="noopener">最小圆覆盖</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一个平面上有$n$个点，求一个<strong>半径最小</strong>的圆，能覆盖所有的点。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设圆$O$是前$i-1$个点得最小覆盖圆，加入第$i$个点，如果在圆内或边上则什么也不做。否，新得到的最小覆盖圆<strong>肯定经过第$i$个点</strong>。</p>
<p>然后以第$i$个点为基础（半径为0），重复以上过程依次加入第$j$个点，若第$j$个点在圆外，则最小覆盖圆<strong>必经过第$j$个点</strong>。</p>
<p>重复以上步骤。（因为最多需要三个点来确定这个最小覆盖圆，所以<strong>重复三次</strong>）</p>
<p>遍历完所有点之后，所得到的圆就是覆盖所有点得<strong>最小圆</strong>。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>时间复杂度</strong>:$O(n)$</p>
<p><strong>空间复杂度</strong>:$O(n)$</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>由于一堆点最多只有3个点确定了最小覆盖圆，因此$n$个点中每个点参与确定最小覆盖圆的概率<strong>不大于</strong>$ \frac{3}{n} $</p>
<p>所以，每一层循环在第$i$个点处调用下一层的概率<strong>不大于</strong>$ \frac{3}{i} $</p>
<p>那么设算法的三个循环的复杂度分别为$ T_1(n),T_2(n),T_3(n) $，则有</p>
<script type="math/tex; mode=display">
T_1(n)=O(n)+ \sum^{n}_{i=1} \frac{3}{i}T_2(i) \\
T_2(n)=O(n)+ \sum^{n}_{i=1} \frac{3}{i}T_3(i) \\
T_3(n)=O(n)</script><p>解得:$ T_1(n)=T_2(n)=T_3(n)=O(n) $</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1742</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">double</span> X,Y; &#125;Dot[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Round</span> &#123;</span> <span class="keyword">double</span> R,X,Y; &#125;Circle;</span><br><span class="line"><span class="keyword">int</span> Total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Round <span class="title">Get</span><span class="params">(Node A,Node B,Node C)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> X1=A.X,Y1=A.Y,X2=B.X,Y2=B.Y,X3=C.X,Y3=C.Y;</span><br><span class="line">    <span class="keyword">double</span> Dy=((X1*X1+Y1*Y1-X3*X3-Y3*Y3)*(X1-X2)-(X1*X1+Y1*Y1-X2*X2-Y2*Y2)*(X1-X3))/(<span class="number">2.0</span>*((Y1-Y3)*(X1-X2)-(Y1-Y2)*(X1-X3)));</span><br><span class="line">    <span class="keyword">double</span> Dx=(X1*X1+Y1*Y1-X2*X2-Y2*Y2<span class="number">-2.0</span>*Dy*(Y1-Y2))/(<span class="number">2.0</span>*(X1-X2));</span><br><span class="line">    <span class="keyword">double</span> Dr=<span class="built_in">sqrt</span>((Dx-X1)*(Dx-X1)+(Dy-Y1)*(Dy-Y1));</span><br><span class="line">	Round Res=&#123;Dr,Dx,Dy&#125;;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(Node A,Round New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Dist=<span class="built_in">sqrt</span>((A.X-New.X)*(A.X-New.X)+(A.Y-New.Y)*(A.Y-New.Y));</span><br><span class="line">    <span class="keyword">return</span> Dist&lt;=New.R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node A,Node B)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.X-B.X)*(A.X-B.X)+(A.Y-B.Y)*(A.Y-B.Y)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[i].X,&amp;Dot[i].Y); &#125;</span><br><span class="line">    random_shuffle(Dot+<span class="number">1</span>,Dot+Total+<span class="number">1</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="keyword">if</span>(!Check(Dot[i],Circle)) &#123;</span><br><span class="line">        Circle=Round&#123;<span class="number">0.0</span>,Dot[i].X,Dot[i].Y&#125;;</span><br><span class="line">        FOR(j,<span class="number">1</span>,i<span class="number">-1</span>) <span class="keyword">if</span>(!Check(Dot[j],Circle)) &#123;</span><br><span class="line">            Circle=Round&#123;Distance(Dot[i],Dot[j])/<span class="number">2.0</span>,(Dot[i].X+Dot[j].X)/<span class="number">2.0</span>,(Dot[i].Y+Dot[j].Y)/<span class="number">2.0</span>&#125;;</span><br><span class="line">            FOR(k,<span class="number">1</span>,j<span class="number">-1</span>) <span class="keyword">if</span>(!Check(Dot[k],Circle)) </span><br><span class="line">                Circle=Get(Dot[i],Dot[j],Dot[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n%.10lf %.10lf\n"</span>,Circle.R,Circle.X,Circle.Y);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>随机算法</title>
    <url>/articles/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h2 id="种子"><a href="#种子" class="headerlink" title="种子"></a>种子</h2><p>使用<strong>srand(seed)函数</strong>可以作为一个<strong>随机化种子</strong></p>
<p>当<strong>相同的seed</strong>两次运行<strong>同一程序</strong>生成的结果是<strong>相同</strong>的</p>
<p><strong>srand(time(NULL))</strong>使用<strong>当前系统时间</strong>作为随机种子</p>
<p>可以生成一个<strong>随机非负整数</strong></p>
<p><strong>温馨提示</strong>：<strong>Windows系统</strong>rand()返回值取值范围为$ [0,2^{15}) $，<strong>Linux系统</strong>范围为$ [0,2^{31}) $</p>
<p>当然，还有一些神奇的随机种子，比如：<strong>srand(19491001)，srand(19260817)，srand(114514) </strong>$ \cdots $</p>
<h2 id="随机函数"><a href="#随机函数" class="headerlink" title="随机函数"></a>随机函数</h2><p><strong>random_shuffle()</strong></p>
<p>用于<strong>打乱指定序列</strong>，使用时存入指定区间的<strong>首尾指针或迭代器</strong>即：random_shuffle(first,last)</p>
<p>还有一些，比如：<strong>shuffle(),random_device()</strong> $ \cdots $</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://loj.ac/problem/2100" target="_blank" rel="noopener">[TJOI2015]线性代数</a> </p>
<p>这是OI-Wiki上推荐的一道”水题”</p>
<p>由于<strong>数据比较水</strong>，我们每次<strong>随机一个位置</strong>，<strong>取反</strong>即可<strong>统计答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LOJ 2100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Ans,Cop[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN],C[MAXN],B[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct Node &#123;</span></span><br><span class="line"><span class="comment">//    int Squ[MAXN][MAXN];</span></span><br><span class="line"><span class="comment">//    int Row,Line;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//    inline void Clean(int X) &#123; FOR(i,1,Row) FOR(j,1,Line) Squ[i][j]=X; &#125;</span></span><br><span class="line"><span class="comment">//    inline void Transpose() &#123;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Row) FOR(j,1,Line) Cop[i][j]=Squ[i][j];</span></span><br><span class="line"><span class="comment">//        int Temp=Row; Row=Line; Line=Temp;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Row) FOR(j,1,Line) Squ[i][j]=Cop[j][i];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    friend Node operator * (Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">//        Node Temp;</span></span><br><span class="line"><span class="comment">//        Temp.Clean(0);</span></span><br><span class="line"><span class="comment">//        Temp.Row=A.Row; Temp.Line=B.Line;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Temp.Row) FOR(j,1,Temp.Line) FOR(k,1,A.Line)</span></span><br><span class="line"><span class="comment">//        Temp.Squ[i][j]+=A.Squ[i][k]*B.Squ[k][j];</span></span><br><span class="line"><span class="comment">//        return Temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    friend Node operator - (Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">//        Node Temp;</span></span><br><span class="line"><span class="comment">//        Temp.Clean(0);</span></span><br><span class="line"><span class="comment">//        Temp.Row=A.Row; Temp.Line=A.Line;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Temp.Row) FOR(j,1,Temp.Line)</span></span><br><span class="line"><span class="comment">//        Temp.Squ[i][j]=A.Squ[i][j]-B.Squ[i][j];</span></span><br><span class="line"><span class="comment">//        return Temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;A,B,C;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Cop,<span class="number">0</span>); <span class="keyword">int</span> Res=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) FOR(k,<span class="number">1</span>,Total) Cop[i]+=A[k]*B[k][i];</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Cop[i]-=C[i];</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Res+=Cop[i]*A[i];</span><br><span class="line">	Ans=<span class="built_in">max</span>(Ans,Res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) FOR(j,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;B[i][j]);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C[i]),A[i]=<span class="number">1</span>;</span><br><span class="line">    Find();</span><br><span class="line">    FOR(i,<span class="number">1</span>,<span class="number">500</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Temp=(rand()%Total)+<span class="number">1</span>;</span><br><span class="line">        A[Temp]^=<span class="number">1</span>;</span><br><span class="line">        Find();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p> 爬山算法是一个<strong>局部择优</strong>的方法，采用的是<strong>启发式仿函</strong>，对<strong>深度优先搜索</strong>的一种改进</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>爬山算法主要应用于<strong>单峰函数</strong>，<strong>收敛速度快</strong></p>
<p>无法应用于<strong>多峰函数</strong>，如图</p>
<p><img src="https://i.loli.net/2020/08/15/rgBkqUYLnHI1TdO.png" alt="随机算法-1.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>[转载] {</p>
<p>爬山算法一般会引入<strong>温度参数</strong>（类似模拟退火）。类比地说，爬山算法就像是一只兔子喝醉了在山上跳，它每次都会朝着它所认为的更    高的地方（这往往只是个不准确的趋势）跳，显然它有可能一次跳到山顶，也可能跳过头翻到对面去。不过没关系，兔子翻过去之后还    会跳回来。显然这个过程很没有用，兔子永远都找不到出路，所以在这个过程中兔子冷静下来并在每次跳的时候更加谨慎，少跳一点，    以到达合适的最优点。</p>
<p>兔子逐渐变得清醒的过程就是降温过程，即温度参数在爬山的时候会不断减小。</p>
<p>关于降温：降温参数是略小于1的常数，一般在<strong>[0.985,0,999]</strong>中选取。</p>
<p>}</p>
<p><strong>注</strong>：一般在调答案的时候，会用到<strong>向量的合并</strong>。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P4035" target="_blank" rel="noopener">[JSOI2008]球形空间产生器</a></p>
<p>由于绝对是<strong>单峰函数</strong>，所以直接由向量合并，逐次更新答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Dist[MAXN],Ave,Dot[MAXN][MAXN],Vec[MAXN],Round[MAXN];</span><br><span class="line"><span class="keyword">int</span> Base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Ave=<span class="number">0.0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) &#123;</span><br><span class="line">        Dist[i]=<span class="number">0.0</span>; Vec[i]=<span class="number">0.0</span>;</span><br><span class="line">        FOR(j,<span class="number">1</span>,Base) Dist[i]+=(Dot[i][j]-Round[j])*(Dot[i][j]-Round[j]);</span><br><span class="line">        Dist[i]=<span class="built_in">sqrt</span>(Dist[i]);</span><br><span class="line">        Ave+=Dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Ave/=(<span class="keyword">double</span>)(Base+<span class="number">1</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) FOR(j,<span class="number">1</span>,Base) </span><br><span class="line">        Vec[j]+=(Dot[i][j]-Round[j])*(Dist[i]-Ave)/Ave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Base);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) FOR(j,<span class="number">1</span>,Base) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;Dot[i][j]); Round[j]+=Dot[i][j]; &#125; </span><br><span class="line">    FOR(i,<span class="number">1</span>,Base) &#123; Round[i]/=(<span class="keyword">double</span>)(Base+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> Temp=<span class="number">1000</span>;Temp&gt;=<span class="number">0.0001</span>;Temp*=<span class="number">0.99995</span>) &#123;</span><br><span class="line">        Check();</span><br><span class="line">        FOR(i,<span class="number">1</span>,Base) &#123; Round[i]+=Vec[i]*Temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base) &#123; <span class="built_in">printf</span>(<span class="string">"%.3lf "</span>,Round[i]); &#125; </span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>百度百科</p>
<p><strong>什么是退火？</strong></p>
<p>退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。目的是降低硬度，改善切削加工性；消除残余应力，稳定尺寸，减少变形与裂纹倾向；细化晶粒，调整组织，消除组织缺陷。准确的说，退火是一种对材料的热处理工艺，包括金属材料、非金属材料。而且新材料的退火目的也与传统金属退火存在异同。</p>
<p>模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。</p>
</blockquote>
<p>因为退火算法引入了更多的<strong>随机因素</strong>，所以我们有<strong>更大的概率</strong>得到<strong>最优解</strong></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>如果新状态的解更优则修改答案，否则以<strong>一定概率</strong>接受新状态</p>
<p>[转载]</p>
<p><img src="https://i.loli.net/2020/08/15/BecCiVwvjRE8mhy.gif" alt="随机算法-2.gif"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>随机挑选</strong>一个单元$k$，并给他一个随机的位移，求出系统因此而产生的<strong>能量变化</strong>$ \Delta E_k $</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>若$ \Delta E_k \leq 0 $，该位移<strong>可接纳</strong>，而变化后的系统状态可作为<strong>下一次变化的起点</strong></p>
<p>若$ \Delta E_k &gt; 0 $，位移后的状态<strong>可采纳的概率</strong>为$ P_k= \frac{1}{1+e^{- \Delta E_k /T}} $</p>
<p>式子中的$T$为温度，然后从$ (0,1) $区间均匀分布的随机数中挑选一个数$R$，若$ R &lt; P_k $，则将变化后的状态作为下次的起点，否则，将变化前的状态作为下次的起点</p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>转第$(1)$步继续执行，直到达到<strong>平衡状态</strong>为止</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1337" target="_blank" rel="noopener">[BZOJ 3680]吊打 XXX</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Weight[MAXN];</span><br><span class="line"><span class="keyword">double</span> X[MAXN],Y[MAXN],Dist[MAXN],Ansx,Ansy,Vecx,Vecy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Power_D</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> Temp*Temp; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Ave=<span class="number">0.0</span>;</span><br><span class="line">    Vecx=<span class="number">0.0</span>; Vecy=<span class="number">0.0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        Dist[i]=<span class="built_in">sqrt</span>(Power_D(X[i]-Ansx)+Power_D(Y[i]-Ansy));</span><br><span class="line">        Vecx+=(<span class="keyword">double</span>)Weight[i]*(X[i]-Ansx)/Dist[i];</span><br><span class="line">        Vecy+=(<span class="keyword">double</span>)Weight[i]*(Y[i]-Ansy)/Dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf %d"</span>,&amp;X[i],&amp;Y[i],&amp;Weight[i]); Ansx+=X[i]; Ansy+=Y[i]; &#125;</span><br><span class="line">    <span class="keyword">if</span>(Total==<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf\n"</span>,X[<span class="number">1</span>],Y[<span class="number">1</span>]);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Ansx/=(<span class="keyword">double</span>)Total; Ansy/=(<span class="keyword">double</span>)Total;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> Temp=<span class="number">1000</span>;Temp&gt;=<span class="number">0.0000001</span>;Temp*=<span class="number">0.997</span>) &#123;</span><br><span class="line">        Check();</span><br><span class="line">        Ansx+=Vecx*Temp; Ansy+=Vecy*Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf\n"</span>,Ansx,Ansy);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">  <span class="comment">//  system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
</search>
