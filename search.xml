<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>T20200610赛后总结</title>
    <url>/articles/T20200610%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200610赛后总结："><a href="#T20200610赛后总结：" class="headerlink" title="T20200610赛后总结："></a>T20200610赛后总结：</h1><h2 id="成绩排行：T20200610成绩"><a href="#成绩排行：T20200610成绩" class="headerlink" title="成绩排行：T20200610成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200610/result20200610.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200610/result20200610.html">T20200610成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试题目比较中等，就是坑点太多，比如我们的LMK同学因为LL的问题从<strong>185=&gt;120</strong>.  </p>
<p>我也因为倒序的ZZ问题，从<strong>205=&gt;115</strong> (<del>表面笑嘻嘻，心里MMP</del>)</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞+构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/V8upjCZtH1XE6as.png" alt="T20200610 eat.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先通过数据范围$ n \leq 200,000 $ ，再加上这是T1，可以推测时间复杂度是$ O(n) $，那么就可以通过这个思路来想正解</p>
<p>可以知道如果现在有一种吃到没有人的情况，那么每个点应该会有一个深度，如果**想要吃掉这些城市，那么唯一的通用方法就是从深度最浅的开始吃，吃到深度极大的。</p>
<p>然后但对于这种情况来说，不一定可以把每一个城市都吃完，因为其中可能会有城市在吃它之前，他就无了，那么假设我们选出来的这些城市都可以吃完，那么最后的总值就是</p>
<script type="math/tex; mode=display">
\sum^{k}_{i=1} Val[i] -\frac {k \times (k-1)}{2}</script><p>同时，为了达到最大并且让最小的那个能够被吃掉，直接可以<strong>$ O(n) $</strong>枚举后缀位置，给$ Ans $附上最大值即可。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eat</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e5</span>+<span class="number">10</span>,MAXm=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Side,Val[MAXn],Ans;</span><br><span class="line">LL u,v,w,Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"eat.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"eat.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Val[i]);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">	sort(Val+<span class="number">1</span>,Val+Total+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Pre[i]=Pre[i<span class="number">-1</span>]+Val[i];</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Val[i]&lt;(Total-i+<span class="number">1</span>)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="built_in">max</span>(Ans,Pre[Total]-Pre[i<span class="number">-1</span>]-(Total-i)*(Total-i+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>质数+乱搞</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/iRHhlPDvWwFVxd4.png" alt="T20200610 division.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>（说实话，感觉这道题直接水是没问题的，<del>90分呀呀呀呀</del>）</p>
<p>分析数据范围，对于70%的数据，$ 2 \leq n \leq 1,000,000,000 \ , 1 \leq m \leq 200 $所以总的来说是算部分分中必须拿到的了。</p>
<p>因为我们可以想到，集合中的每一个数都有两种选择方式，所以集合中共有$ 2^{200} $种选择方式（<del>吓死宝宝了</del>），但是<del>定睛一看</del>（其实我看了几百年QwQ），可以发现，如果直接用map爆搜，那么map中只可能出现$ n $的约数，即设$ k $为map中的 数的个数，则据对有有$ k \leq \sqrt{n} $，<strong>时间复杂度$ O( \sqrt{n} \times m) $</strong>,那这个70分稳了！（其实考场上我用的就是这个，并且取得了90分的好成绩！。。。）但是定睛一看，打一个表，取出最小的k个质数乘一下！发现</p>
<script type="math/tex; mode=display">
\sum^{15}_{i=1,i \in prime} \geq 2^{64}(LL)</script><p>这下发现，对于100%的数据，$ 2 \leq 10^{18} \ ,1 \leq 500 $它就是个弟弟。</p>
<p><strong>总的时间复杂度：$ O(2^{15}M) </strong>$</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//division</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;LL,LL&gt;DP;</span><br><span class="line">priority_queue&lt;LL&gt;Mine;</span><br><span class="line">LL Total,Size,Res,New;</span><br><span class="line"><span class="keyword">bool</span> Jud=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">GCD</span><span class="params">(LL X,LL Y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (!Y) ? X : GCD(Y,X%Y);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"division.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"division.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Size);</span><br><span class="line"><span class="comment">//	cout&lt;&lt;Total&lt;&lt;endl&lt;&lt;Size&lt;&lt;endl;</span></span><br><span class="line">	FOR(i,<span class="number">1</span>,Size) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Res);</span><br><span class="line">		<span class="keyword">if</span>(Res!=<span class="number">1</span> &amp;&amp; Res&lt;=Total &amp;&amp; (GCD(Total,Res)==Res)) Mine.push(Res);</span><br><span class="line">		<span class="keyword">if</span>(Res==<span class="number">1</span>) Jud=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	while(!Mine.empty()) &#123;</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;Mine.top();</span></span><br><span class="line"><span class="comment">//		Mine.pop();</span></span><br><span class="line"><span class="comment">//		cout&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">	DP[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) &#123; </span><br><span class="line">		New=Mine.top();</span><br><span class="line">		Mine.pop();</span><br><span class="line">		<span class="built_in">map</span>&lt;LL,LL&gt;::iterator Iter=DP.<span class="built_in">begin</span>();</span><br><span class="line">		<span class="comment">//DP.size()&lt;=sqrt(Total)</span></span><br><span class="line">		<span class="comment">//M*sqrt(Total)</span></span><br><span class="line">		<span class="keyword">while</span>(Iter!=DP.<span class="built_in">end</span>()) &#123;</span><br><span class="line">			LL Next=(Iter-&gt;first)*New;</span><br><span class="line">			<span class="keyword">if</span>((GCD(Total,Next)==<span class="number">1</span>) || (Next&gt;Total) || (GCD(New,(Iter-&gt;first))!=<span class="number">1</span>)) &#123;</span><br><span class="line">				++Iter;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			DP[Next]+=(Iter-&gt;second);</span><br><span class="line">			++Iter;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Jud ? DP[Total]*<span class="number">2</span> : DP[Total]);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+拓扑排序+图的构建</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/fYNRp35G4rqiwX8.png" alt="T20200610 trip.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>作为本套试题的压轴题，不妙怎么行。。。（<del>口胡</del>）</p>
<p>首先本题是要求最长边权递增最长路，并统计路径条数。</p>
<p>我考场上直接暴力可还行。。。所以我直接上题解了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>把所有边按边权排序，暴力枚举选出的边集，然后判断该边集是否满足边权互不相同，且能依次组成一条路径。</p>
<p><strong>时间复杂度</strong>$ O(2^m \times m) $，<strong>期望得分10分</strong>。</p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>首先考虑有向图该怎么做，然后只需把无向图的边拆成两条有向边即可。</p>
<p>把边当做点构造一张新图。对于原图的每个点，把与它关联的边分成两类，一类是连向它的边，称其为“入边”；另一类是从它连出去的边，称为“出边”。对于一条入边$ i $和出边$ j $，如果$ w_i &lt; w_j $，则在新图中$ i $向$ j $连一条有向边。</p>
<p>这样得到一张点数为$ m $，边数为<strong>$ O(m^2) $</strong>的新图，问题转化为：求这张新图的最长路和最长路的方案数。</p>
<p>由于连边的时候总满足$ w_i &lt; w_j $，所以新图不可能出现环，于是新图就是一张有向无环图（DAG）。对于求 DAG 的最长路和最长路的方案数，只需拓扑排序后再做动态规划即可。</p>
<p><strong>时间复杂度$ O(n+m^2) $</strong>，<strong>期望得分 60 分</strong>。</p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>上述算法二的瓶颈在于构出新图，用上述算法得到的图边数是<strong>$ O(m^2) $</strong>显然不能承受。</p>
<p>枚举原图的每个点，然后把它的出边按边权从小到大排序。可以发现，对于一条入边$i$，如果它连向了出边$j$，则𝑖也会连向排在$j$之后的所有出边。</p>
<p>下面是构图方法：对每条出边$j$建立虚点$j’$，$j’$向$j$连权值为1的有向边。所有虚点按排好的顺序依次向下一个虚点连权值为0的有向边。对于每条入边$i$，找到出边中第一条边权大于它的边$j$，$i$向$j’$ 连权值为0的有向边。</p>
<p>这样得到的图还是 DAG，然后和算法二中一样，拓扑排序后再做动态规划即可。</p>
<p><strong>时间复杂度$ O(n+mlog_2m) $</strong>，<strong>期望得分 100 分</strong>。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trip</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Update(A,B,C,D)  <span class="meta-keyword">if</span>(A&gt;C) C=A,D=B; <span class="meta-keyword">else</span> <span class="meta-keyword">if</span>(A==C) (D+=B)%=MOD;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> Fir,Sec; </span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) &#123;  </span><br><span class="line">		<span class="keyword">if</span>(A.Fir==B.Fir) <span class="keyword">return</span> A.Sec&lt;B.Sec;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> A.Fir&lt;B.Fir;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Total,Side,Sum[MAXn],Len[MAXn];</span><br><span class="line"><span class="keyword">int</span> Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>],Head[MAXn],Cur,Val[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> In[MAXn],u,v,w,Dot,Queue[MAXn];</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	In[To]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trip.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"trip.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Dot=<span class="number">2</span>*Side+<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		sort(Num[i].<span class="built_in">begin</span>(),Num[i].<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">int</span> Loc=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,Num[i].<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">			Add_Edge(Dot+j+<span class="number">1</span>,Num[i][j].Sec,<span class="number">1</span>);</span><br><span class="line">			<span class="keyword">for</span>(;Loc&lt;Num[i].<span class="built_in">size</span>() &amp;&amp; Num[i][j].Fir == Num[i][Loc].Fir;Loc++) ;</span><br><span class="line">			<span class="keyword">if</span>(Loc&lt;Num[i].<span class="built_in">size</span>()) Add_Edge(Num[i][j].Sec^<span class="number">1</span>,Dot+Loc+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(j) Add_Edge(Dot+j,Dot+j+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">		&#125;<span class="comment">//将每一个点的边成立的互相连接</span></span><br><span class="line">		Dot+=Num[i].<span class="built_in">size</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> L=<span class="number">1</span>,R=<span class="number">0</span>;<span class="comment">//用队列来按顺序处理</span></span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) <span class="keyword">if</span>(!In[i]) Len[i]=<span class="number">0</span>,Sum[i]=<span class="number">1</span>,Queue[++R]=i;</span><br><span class="line">	<span class="keyword">for</span>(;L&lt;=R;L++) &#123;</span><br><span class="line">		<span class="keyword">int</span> New=Queue[L];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=Head[New];i;i=Next[i]) &#123;</span><br><span class="line">			Update(Len[New]+Val[i],Sum[New],Len[End[i]],Sum[End[i]]);</span><br><span class="line">			<span class="keyword">if</span>(!--In[End[i]]) Queue[++R]=End[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> A=<span class="number">0</span>,B=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) Update(Len[i],Sum[i],A,B);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>,A,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//  File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		Num[u].push_back(Node&#123; w,i*<span class="number">2</span> &#125;);</span><br><span class="line">		Num[v].push_back(Node&#123; w,i*<span class="number">2</span>+<span class="number">1</span> &#125;);</span><br><span class="line">	&#125;<span class="comment">//初始化联通每一点的边 方便中途连图的时候的排序</span></span><br><span class="line">	Build();<span class="comment">//重新建图</span></span><br><span class="line">	Solve();<span class="comment">//直接每个点更新答案</span></span><br><span class="line"><span class="comment">//  fclose(stdin); fclose(stdout);</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog Chore</title>
    <url>/articles/Blog%20Chore/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这篇博客主要来整理一些<strong>Blog搭建的配置</strong>比如说——-</p>
<p><strong>温馨提示</strong>：本文仅限于<strong>Markdown语法</strong>插入</p>
<h1 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h1><h2 id="1-登录网易云音乐（网页版-amp-客户端）"><a href="#1-登录网易云音乐（网页版-amp-客户端）" class="headerlink" title="1.登录网易云音乐（网页版 &amp; 客户端）"></a>1.登录网易云音乐（网页版 &amp; 客户端）</h2><h2 id="2-进入Chrome应用商场"><a href="#2-进入Chrome应用商场" class="headerlink" title="2.进入Chrome应用商场"></a>2.进入Chrome应用商场</h2><h2 id="3-搜素“网易云”"><a href="#3-搜素“网易云”" class="headerlink" title="3.搜素“网易云”"></a>3.搜素“网易云”</h2><p><img src="https://i.loli.net/2020/06/25/EJyXTwlLYmnHu79.png" alt="网易云插件-1.png"></p>
<h2 id="4-添加“网易云音乐下载插件”"><a href="#4-添加“网易云音乐下载插件”" class="headerlink" title="4.添加“网易云音乐下载插件”"></a>4.添加“网易云音乐下载插件”</h2><p><img src="https://i.loli.net/2020/06/25/dqMpW3GYRuSeH2D.png" alt="网易云插件-2.png"></p>
<p><strong>温馨提示：</strong>添加成功之后Chrome右上方会有小型图标，如果看他不爽可以右键+隐藏（<del>我这个强迫症患者是有点QwQ</del>）</p>
<p><strong>温馨提示：</strong>如果你发现你的网易云插件下载之后没有亮起，不要方张。他是需要进入客户端（网页版）之后才会亮起的。。。</p>
<h2 id="5-选取需要插入的歌曲"><a href="#5-选取需要插入的歌曲" class="headerlink" title="5.选取需要插入的歌曲"></a>5.选取需要插入的歌曲</h2><p><img src="https://i.loli.net/2020/06/25/jT6RvbKFZgsMweN.png" alt="网易云插件-3.png"></p>
<h2 id="6-点击“生成外链播放器”"><a href="#6-点击“生成外链播放器”" class="headerlink" title="6.点击“生成外链播放器”"></a>6.点击“生成外链播放器”</h2><p><img src="https://i.loli.net/2020/06/25/kmKjsO8ya7tZCYf.png" alt="网易云插件-4.png"></p>
<h2 id="7-获取歌曲代码"><a href="#7-获取歌曲代码" class="headerlink" title="7.获取歌曲代码"></a>7.获取歌曲代码</h2><p><img src="https://i.loli.net/2020/06/25/7YSA6NjIVcULKvZ.png" alt="网易云插件-5.png"></p>
<h2 id="8-将获取的Markdown代码插入到Typora中"><a href="#8-将获取的Markdown代码插入到Typora中" class="headerlink" title="8.将获取的Markdown代码插入到Typora中"></a>8.将获取的Markdown代码插入到Typora中</h2><p>插入效果展示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">marginwidth</span>=<span class="string">"0"</span> <span class="attr">marginheight</span>=<span class="string">"0"</span> <span class="attr">width</span>=<span class="string">440</span> <span class="attr">height</span>=<span class="string">86</span> <span class="attr">src</span>=<span class="string">"//music.163.com/outchain/player?type=2&amp;id=1374056689&amp;auto=1&amp;height=66"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1374056689&auto=1&height=66"></iframe>

<h1 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h1><h2 id="1-登录哔哩哔哩官网"><a href="#1-登录哔哩哔哩官网" class="headerlink" title="1.登录哔哩哔哩官网"></a>1.登录哔哩哔哩官网</h2><h2 id="2-选择你要插入的视频"><a href="#2-选择你要插入的视频" class="headerlink" title="2.选择你要插入的视频"></a>2.选择你要插入的视频</h2><h2 id="3-获取“嵌入代码”"><a href="#3-获取“嵌入代码”" class="headerlink" title="3.获取“嵌入代码”"></a>3.获取“嵌入代码”</h2><p><img src="https://i.loli.net/2020/06/25/KAJ1W4OfNMkvtz8.png" alt="哔哩哔哩配置-1.png"></p>
<h2 id="4-将获取的HTML代码插入到Typora中"><a href="#4-将获取的HTML代码插入到Typora中" class="headerlink" title="4.将获取的HTML代码插入到Typora中"></a>4.将获取的HTML代码插入到Typora中</h2><p>插入效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=73773499&amp;bvid=BV1tE411h7x4&amp;cid=146795963&amp;page=1"</span> <span class="attr">scrolling</span>=<span class="string">"no"</span> <span class="attr">border</span>=<span class="string">"0"</span> <span class="attr">frameborder</span>=<span class="string">"no"</span> <span class="attr">framespacing</span>=<span class="string">"0"</span> <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当然这还不够，你会发现这个时候上传，视频会变得很小。。。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><h4 id="lt-1-添加“哔哩哔哩视频适配“"><a href="#lt-1-添加“哔哩哔哩视频适配“" class="headerlink" title="&lt;1.添加“哔哩哔哩视频适配“"></a>&lt;1.添加“哔哩哔哩视频适配“</h4><p>进入 <strong>C:\hexo\themes\next\source\css\_custom\custom.styl</strong></p>
<p>加入如下代码：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">/*哔哩哔哩视频适配*/</span></span><br><span class="line"><span class="string">.bilibili</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">relative;</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">100</span><span class="string">%;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">767px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">15em;max-width:</span> <span class="string">25em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">768px)</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">991px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">20em;max-width:</span> <span class="string">30em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">992px)</span> <span class="string">and</span> <span class="string">(max-width:</span> <span class="string">1199px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">30em;max-width:</span> <span class="string">40em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">@media</span> <span class="string">only</span> <span class="string">screen</span> <span class="string">and</span> <span class="string">(min-width:</span> <span class="string">1200px)</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">.bilibili</span> <span class="string">&#123;height:</span> <span class="string">40em;max-width:</span> <span class="string">50em;&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="lt-2-代码调整"><a href="#lt-2-代码调整" class="headerlink" title="&lt;2.代码调整"></a>&lt;2.代码调整</h4><p>加入<strong>class=“bilibili”</strong>调用哔哩哔哩的播放器</p>
<p>并加入视频的大小调整<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"</span><br></pre></td></tr></table></figure></p>
<h4 id="lt-3-效果展示"><a href="#lt-3-效果展示" class="headerlink" title="&lt;3.效果展示"></a>&lt;3.效果展示</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">class</span>=<span class="string">"bilibili"</span> <span class="attr">src</span>=<span class="string">"//player.bilibili.com/player.html?aid=73773499&amp;bvid=BV1tE411h7x4&amp;cid=146795963&amp;page=1&amp;danmaku=1"</span> <span class="attr">scrolling</span>=<span class="string">"”no”"</span> <span class="attr">border</span>=<span class="string">"”0″"</span> <span class="attr">frameborder</span>=<span class="string">"”no”"</span> <span class="attr">framespacing</span>=<span class="string">"”0″"</span> <span class="attr">allowfullscreen</span>=<span class="string">"”true”"</span> <span class="attr">style</span>=<span class="string">"width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="lt-4-bilibili参数说明"><a href="#lt-4-bilibili参数说明" class="headerlink" title="&lt;4.bilibili参数说明"></a>&lt;4.bilibili参数说明</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">aid 视频ID 就是B站的av号</span><br><span class="line">cid 应该是客户端的id,clientid的缩写（推测） 测试表示不填也不会有什么问题</span><br><span class="line">page 第几个视频 也就是分P的 默认是1</span><br><span class="line">as_wide 是否宽屏 1：宽屏 0：小屏</span><br><span class="line">high_quality 视频质量 1：最高视频质量 0：最低视频质量</span><br><span class="line">danmaku 是否开启弹幕 1：开启（默认） 0：关闭</span><br></pre></td></tr></table></figure>
<h2 id="5-上传效果展示"><a href="#5-上传效果展示" class="headerlink" title="5.上传效果展示"></a>5.上传效果展示</h2><iframe class="bilibili" src="//player.bilibili.com/player.html?aid=73773499&bvid=BV1tE411h7x4&cid=146795963&page=1&danmaku=1" scrolling="”no”" border="”0″" frameborder="”no”" framespacing="”0″" allowfullscreen="”true”" style="width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;"> </iframe>

<h1 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h1><p>这里介绍一个最实用的评论系统—-Valine，基于LeanCloud，可以在不登陆的情况下评论（十分convenientQwQ）</p>
<h2 id="1-创建LeanCloud账号"><a href="#1-创建LeanCloud账号" class="headerlink" title="1.创建LeanCloud账号"></a>1.创建LeanCloud账号</h2><p>使用<strong>“免费试用”</strong>即可</p>
<p><img src="https://i.loli.net/2020/06/25/WB8Q5VpY7xJFyb2.png" alt="Valine-1.png"></p>
<h2 id="2-身份验证-邮箱验证"><a href="#2-身份验证-邮箱验证" class="headerlink" title="2.身份验证+邮箱验证"></a>2.身份验证+邮箱验证</h2><p><strong>温馨提示：</strong>验证（<strong>个人认证</strong>）时需要<strong>支付宝</strong>扫码验证身份</p>
<p><img src="https://i.loli.net/2020/06/25/QZU7DYoevFTtg5f.png" alt="Valine-2.png"></p>
<h2 id="3-进入“控制台”创建新项目"><a href="#3-进入“控制台”创建新项目" class="headerlink" title="3.进入“控制台”创建新项目"></a>3.进入“控制台”创建新项目</h2><p>下面是我已创建好的一个项目</p>
<p><img src="https://i.loli.net/2020/06/25/5tcmJdqTx6Vn8Sy.png" alt="Valine-3.png"></p>
<p><strong>温馨提示：</strong>选取”<strong>开发版</strong>“，项目名称随便取</p>
<p><img src="https://i.loli.net/2020/06/25/hTBFoSqDwe4KtHr.png" alt="Valine-4.png"></p>
<h2 id="4-进入项目并获取App-ID和App-Key"><a href="#4-进入项目并获取App-ID和App-Key" class="headerlink" title="4.进入项目并获取App ID和App Key"></a>4.进入项目并获取App ID和App Key</h2><p>进入顺序：你的项目$ \rightarrow $设置$ \rightarrow $应用Keys（之后就可以看到这两个东东了）</p>
<p><img src="https://i.loli.net/2020/06/25/nAeyZdLQFckgz21.png" alt="Valine-5.png"></p>
<h2 id="5-主题中配置Valine"><a href="#5-主题中配置Valine" class="headerlink" title="5.主题中配置Valine"></a>5.主题中配置Valine</h2><p><strong>C:\hexo\themes\next\ _config.yml</strong></p>
<p>其中将enable改为true，notify是”是否提示“</p>
<p><img src="https://i.loli.net/2020/06/25/Gwnu7EQ9kibNBdq.png" alt="Valine-6.png"></p>
<p>（没错，就是这么<del>简单</del>）</p>
<h2 id="6-管理评论"><a href="#6-管理评论" class="headerlink" title="6.管理评论"></a>6.管理评论</h2><p>进入顺序：你的项目$ \rightarrow $存储$ \rightarrow $结构化数据$ \rightarrow $Comment</p>
<p>即可管理评论（<del>嘿嘿嘿</del>）</p>
<p><img src="https://i.loli.net/2020/06/25/DAXvehB6mgZ94fk.png" alt="Valine-7.png"></p>
<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><p>这里我就只说一下<strong>腾讯云</strong>的域名绑定吧（弄完之后再回过头来看，发现是真的简单。。。）</p>
<h2 id="1-注册腾讯云账户并进入“域名注册”"><a href="#1-注册腾讯云账户并进入“域名注册”" class="headerlink" title="1.注册腾讯云账户并进入“域名注册”"></a>1.注册腾讯云账户并进入“域名注册”</h2><p><img src="https://i.loli.net/2020/06/27/1pxKsTUV4ROImD5.png" alt="腾讯云域名-1.png"></p>
<h2 id="2-选择个性化的域名"><a href="#2-选择个性化的域名" class="headerlink" title="2.选择个性化的域名"></a>2.选择个性化的域名</h2><p><img src="https://i.loli.net/2020/06/27/JADMfnH6kiLVv8Q.png" alt="腾讯云域名-2.png"></p>
<h2 id="3-查找并选择实惠，喜爱的域名后缀"><a href="#3-查找并选择实惠，喜爱的域名后缀" class="headerlink" title="3.查找并选择实惠，喜爱的域名后缀"></a>3.查找并选择实惠，喜爱的域名后缀</h2><p>比如我现在这个Blog后缀就是ink</p>
<p>在“查询结果”中找到“<strong>最优秀</strong>”的并添加到“购物车“</p>
<p><img src="https://i.loli.net/2020/06/27/mIQ16cMpXgS5VuA.png" alt="腾讯云域名-3.png"></p>
<h2 id="4-购买域名"><a href="#4-购买域名" class="headerlink" title="4.购买域名"></a>4.购买域名</h2><p><strong>温馨提示：</strong>这里注册人需要实名认证</p>
<p><img src="https://i.loli.net/2020/06/27/m3u9nUQ5HO1hNlb.png" alt="腾讯云域名-4.png"></p>
<h2 id="5-在控制台中进入“域名管理”"><a href="#5-在控制台中进入“域名管理”" class="headerlink" title="5.在控制台中进入“域名管理”"></a>5.在控制台中进入“域名管理”</h2><p>这里直接在“腾讯云产品”处搜索“域名管理”即可</p>
<p><img src="https://i.loli.net/2020/06/27/ZILaDNEgW5dFCBh.png" alt="腾讯云域名-5.png"></p>
<h2 id="6-审核域名"><a href="#6-审核域名" class="headerlink" title="6.审核域名"></a>6.审核域名</h2><p>这里我是已经审核完毕了，但如果是新买了那么可能需要一些时间（少则几十秒，多则几个工作日，不定）来审核，完成之后就会显示“正常”</p>
<p><img src="https://i.loli.net/2020/06/27/vh49J8YDHgKoNbl.png" alt="腾讯云域名-6.png"></p>
<h2 id="7-解析域名"><a href="#7-解析域名" class="headerlink" title="7.解析域名"></a>7.解析域名</h2><p>进入顺序：解析$ \rightarrow $添加记录</p>
<p><img src="https://i.loli.net/2020/06/27/9yCIZFqMLBDQz8w.png" alt="腾讯云域名-7.png"></p>
<p><img src="https://i.loli.net/2020/06/27/kpcnAJermsd65WT.png" alt="腾讯云域名-8.png"></p>
<p>这里在添加时其实会有非常明确的注释</p>
<p>在“主机记录”栏中填入什么其实并不重要（即啥都可以填（当时必须是英文））</p>
<p>只是最后关系到域名使用的链接方式</p>
<p>当然我还是推荐直接就是选择“@”即“不需要”，这样在访问时感觉简洁一点。。。</p>
<p>这里“记录类型”需要填写CNAME</p>
<p>后边的“记录值”就是你的原本的域名</p>
<p><img src="https://i.loli.net/2020/06/27/DFkyWOcBQfG8EXK.png" alt="腾讯云域名-9.png"></p>
<h2 id="8-绑定github新域名"><a href="#8-绑定github新域名" class="headerlink" title="8.绑定github新域名"></a>8.绑定github新域名</h2><p>进入顺序：github仓库$ \rightarrow $settings$ \rightarrow $Github Pages$ \rightarrow $Custom domain</p>
<p>在这个地方输入你买的域名，save即可</p>
<p><img src="https://i.loli.net/2020/06/27/6qhETFNRi4coMfa.png" alt="腾讯云域名-10.png"></p>
<h2 id="9-添加CNAME文件"><a href="#9-添加CNAME文件" class="headerlink" title="9.添加CNAME文件"></a>9.添加CNAME文件</h2><p><strong>C:\hexo\source</strong>中添加一个名为CNAME的文件</p>
<p><strong>温馨提示：</strong>这个文件需要将其的后缀名删除！！！（如下图）</p>
<p><img src="https://i.loli.net/2020/06/27/PYplstVOXjJHzm1.png" alt="腾讯云域名-11.png"></p>
<p>再用某某方式打开它（这里我用的是Sublime）</p>
<p>并在其中添加你的新域名</p>
<p>这样之后，就Perfect了</p>
<p><img src="https://i.loli.net/2020/06/27/Zxn1OkSMr38zUhY.png" alt="腾讯云域名-12.png"></p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>如果没有这个文件，我们在每次hexo g，hexo d之后都需要重新在github上save新域名，非常的麻烦</p>
<p>所以可以直接在这个地方加一个CNAME文件，保证这个新域名地址的Blog也可以被更新</p>
<h2 id="10-修改默认域名地址"><a href="#10-修改默认域名地址" class="headerlink" title="10.修改默认域名地址"></a>10.修改默认域名地址</h2><p>这个时候我们只需要打开文件</p>
<p><strong>C:\hexo\_config.yml</strong>进行两部修改：</p>
<p>修改如图<strong>url</strong>处的域名（即改为<strong>自己购买的域名</strong>）</p>
<p>将<strong>permalink</strong>处改为如图的<strong>“articles/:title/”</strong>即可大功告成</p>
<p><img src="https://i.loli.net/2020/07/04/OToK8NcsmYp4Jw1.png" alt="腾讯云域名-13.png"></p>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200603赛后总结</title>
    <url>/articles/T20200603%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200603赛后总结"><a href="#T20200603赛后总结" class="headerlink" title="T20200603赛后总结"></a>T20200603赛后总结</h1><h2 id="成绩排行：T20200603成绩"><a href="#成绩排行：T20200603成绩" class="headerlink" title="成绩排行：T20200603成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200603/result20200603.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200603/result20200603.html">T20200603成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>emm。。。这套题我只想吐槽一下T1。</p>
<p>为啥$ nh $的假贪心可以直接过？？？<del>我吐了</del></p>
<p>我和LMK写的$ nlogh $的真线段树贪心它不香吗。。。</p>
<p>就是排序写挂了。。。<strong>100=&gt;0</strong> wonderful！！！</p>
<p>然后就是T3，没懂+INF。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P1250" target="_blank" rel="noopener">P1250 种树</a></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心</strong></p>
<p>但是我觉得需要<strong>线段树+贪心</strong>比较好。。。</p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/5LEIkVxpAKNW1Sr.png" alt="T20200603 trees.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一看，啥都不用说，丫的就是一个贪心，每次选出被覆盖次数最多的那个区域种上树，不久OU了吗。</p>
<p>那么现在要做的就是如何每次选出被覆盖次数最多的区域了。</p>
<p>对于这些区间，需要想到的就是区间排序在操作，所以此时就有两种操作了，１.左对齐排序　２.右对齐排序。经过我亲身排序错误的爆零尝试，才知道我脑抽了。。。右对齐它多香啊。。。</p>
<p>所以之后就每次枚举当前区间，将最右边的全部覆盖掉。</p>
<p><strong>时间复杂度：$ O(nh) $或$ O(nlogh) $</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//trees</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">3e4</span>+<span class="number">10</span>;</span><br><span class="line">LL Total,House;</span><br><span class="line">LL Tree[MAXn&lt;&lt;<span class="number">2</span>],Tag[MAXn&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    LL B,E,T;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp;Temp) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(E==Temp.E) <span class="keyword">return</span> B&lt;Temp.B;</span><br><span class="line">        <span class="keyword">return</span> E&lt;Temp.E;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushUp</span><span class="params">(LL X)</span></span>&#123; Tree[X]=Tree[Lson]+Tree[Rson]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">UP</span><span class="params">(LL L, LL R, LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree[X]=(R-L+<span class="number">1</span>);</span><br><span class="line">    Tag[X]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">PushDown</span><span class="params">(LL L,LL R,LL X)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Tag[X]) <span class="keyword">return</span> ;</span><br><span class="line">    LL Mid=(L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    UP(L,Mid,Lson);</span><br><span class="line">    UP(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">    Tag[X]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UpDate</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X=<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) </span><br><span class="line">    &#123;</span><br><span class="line">        Tree[X]=R-L+<span class="number">1</span>;</span><br><span class="line">        Tag[X]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) UpDate(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) UpDate(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    PushUp(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">Query</span><span class="params">(LL L,LL R,LL Tl,LL Tr,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=Tl &amp;&amp; R&lt;=Tr) <span class="keyword">return</span> Tree[X];</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Ans=<span class="number">0</span>;</span><br><span class="line">    PushDown(L,R,X);</span><br><span class="line">    <span class="keyword">if</span>(Tl&lt;=Mid) Ans+=Query(L,Mid,Tl,Tr,Lson);</span><br><span class="line">    <span class="keyword">if</span>(Tr&gt;Mid) Ans+=Query(Mid+<span class="number">1</span>,R,Tl,Tr,Rson);</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL TL,LL TR,LL T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL L=TL,R=TR,Ans=TL;</span><br><span class="line">    <span class="keyword">while</span>(L&lt;=R) &#123;</span><br><span class="line">        LL Mid=(L+R)&gt;&gt;<span class="number">1</span>, S=((Mid<span class="number">-1</span>)&lt;TL ? <span class="number">0</span> : Query(<span class="number">1</span>,Total,TL,Mid<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span> (S+TR-Mid+<span class="number">1</span>&gt;=T) Ans=Mid,L=Mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> R=Mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(LL L,LL R,LL X = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,Tree[X]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Print(L,Mid,Lson); Print(Mid+<span class="number">1</span>,R,Rson);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"trees.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"trees.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>,&amp;Total,&amp;House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) <span class="built_in">scanf</span> (<span class="string">"%d %d %d"</span>,&amp;Num[i].B,&amp;Num[i].E,&amp;Num[i].T);    </span><br><span class="line">    sort(Num,Num+House);</span><br><span class="line">    FOR(i,<span class="number">0</span>,House<span class="number">-1</span>) &#123;</span><br><span class="line">        LL Res=Query(<span class="number">1</span>,Total,Num[i].B,Num[i].E);</span><br><span class="line">        <span class="keyword">if</span>(Res&gt;=Num[i].T) <span class="keyword">continue</span>;</span><br><span class="line">        LL Place=Get(Num[i].B,Num[i].E,Num[i].T);</span><br><span class="line">        UpDate(<span class="number">1</span>,Total,Place,Num[i].E);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Tree[<span class="number">1</span>]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>倍增</strong></p>
<p>或<strong>树状数组</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/yiSBUuOHe4xgCW2.png" alt="T20200603 at.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于本题考试的时候没有一个不是AC的，所以也就没什么必要分析了</p>
<p>我还是来一波solution的分析吧</p>
<blockquote>
<p>题目实际上是求每个结点深度差不超过K的儿子个数。</p>
<pre><code>由于涉及到方面有：深度、子树求和，大概思路可以想到是先预处理，然后按深度从大到小增删点，再查询某子树有多少个点。

增删点的过程可以通过给点设权值来实现，1表示这个点存在，0表示不存在。那么查询某子树有多少个点就相当于是对某个子树中点的权值进行求和。

与子树相关可用dfs序，修改和求和可以用树状数组实现。
</code></pre></blockquote>
<p>所以，就这么OU了，真香。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//at</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,K,u,v,Cur;</span><br><span class="line">LL Sum[MAXn],Val[MAXn],Temp[MAXn],Anc[MAXn][<span class="number">20</span>];</span><br><span class="line">LL Head[MAXn],Next[MAXn&lt;&lt;<span class="number">1</span>],End[MAXn&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">DFS</span><span class="params">(LL X, LL Fa)</span> </span>&#123;</span><br><span class="line">    Anc[X][<span class="number">0</span>]=Fa; Temp[Fa]++;</span><br><span class="line">    FOR(i,<span class="number">1</span>,<span class="number">19</span>) Anc[X][i]=Anc[Anc[X][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    LL TO=X,TK=K;</span><br><span class="line">    <span class="keyword">for</span> (LL i=<span class="number">0</span>;TK;++i)</span><br><span class="line">        <span class="keyword">if</span> (TK &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">            TK ^= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            TO=Anc[TO][i];</span><br><span class="line">        &#125;</span><br><span class="line">    Temp[Anc[TO][<span class="number">0</span>]]--;</span><br><span class="line">    <span class="keyword">for</span> (LL i=Head[X];i;i=Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(End[i]==Fa) <span class="keyword">continue</span>;</span><br><span class="line">        DFS(End[i],X);</span><br><span class="line">        Temp[X]+=Temp[End[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(LL From,LL To)</span> </span>&#123;</span><br><span class="line">    Next[++Cur]=Head[From];</span><br><span class="line">    Head[From]=Cur;</span><br><span class="line">    End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"at.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"at.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;N,&amp;K);</span><br><span class="line">	FOR(i,<span class="number">1</span>,N<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">        AddEdge(u,v); AddEdge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,N) <span class="built_in">printf</span> (<span class="string">"%lld\n"</span>,Temp[i]);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>构造+组合数学</strong></p>
<p>或<strong>矩阵快速幂+动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FEVoNZiWK3J1r7s.png" alt="T20200603 poker.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>其实我不怎么想分析，因为</p>
<p>1.这明明叫高二学堂，他跟题面有啥关系啊？！</p>
<p>2.这题解写的是嘛呀，看不懂（高二巨佬也没搞懂，只看懂了80分）</p>
<p>综上所述，我就直接上solution了</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>输出$n$，不解释。。。</p>
<p><strong>期望得分：10</strong></p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>利用上式对$Ai$和$Xi$进行搜索，同样不解释。。。</p>
<p><strong>期望得分：20</strong></p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>把牌按数值大小编号，数值相同的编上4个不同号码。</p>
<p>用$ f[i][j][k] $表示现在处理完前i张牌，一共用了$j$张，构成和为$k$的方案数。转移只要使用类似背包的方法即可。</p>
<p>方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f’[i][j][k]=f[i][j][k]+Σf[i<span class="number">-1</span>][j<span class="number">-1</span>][k-w(i)]。</span><br></pre></td></tr></table></figure>
<p>其中$ w(i) $为$i$的牌面。</p>
<p>为免MLE，可把第一维省去。</p>
<p><strong>期望得分：40</strong></p>
<h4 id="【算法四】"><a href="#【算法四】" class="headerlink" title="【算法四】"></a>【算法四】</h4><p>这是Symbol提出来的方法。</p>
<p>如果现在所有的牌面都大于1，假设有$k$’张，那么把所有牌面都减小1，总和减少$k’$之后，问题显然是等价的；而如果有牌面等于1，那么只要把这几张牌去掉，剩下的牌面就又都是大于1的了。</p>
<p>所以可以使用$ f[i][j] $表示用j张牌构成和为$i$的方案数，转移的时候分情况：</p>
<p>1）所有牌面大于1，则$ f[i][j]+=f[i-j][j] $；</p>
<p>2）有牌面等于1，那么我们可以枚举这些牌的数量$ t（\leq 4） $，则$ f[i][j]+=f[i-j][j-t] $。</p>
<p>最后答案就是$ f[n][1 \rightarrow k] $的最小值。</p>
<p><strong>时间复杂度为$ O(nk) $</strong></p>
<p><strong>期望得分：60</strong></p>
<h4 id="【算法五】"><a href="#【算法五】" class="headerlink" title="【算法五】"></a>【算法五】</h4><p>对算法4进行优化，考虑到$k$比较小，而转移只需要用到前$k$层的值。</p>
<p>我们可以把连续$k$层的f压在一个矩阵内，并按一维编号，最多不超过$k^2$个。然后我们每次转移1层的$f$，也就是如果现在矩阵记录的是$f[1 \rightarrow k][]$的值，那么转移一次，矩阵记录的就变成了$f[2 \rightarrow k+1][]$的值。然后填矩阵就是了。</p>
<p><strong>时间复杂度为$ O(logn \times k^6) $</strong>，多组数据下，这个方法会由于常数大被卡掉。</p>
<p><strong>期望得分：80</strong></p>
<h4 id="【算法六】"><a href="#【算法六】" class="headerlink" title="【算法六】"></a>【算法六】</h4><p>首先，假设牌面的集合为$ {xi} $，集合中的每个元素对应一个$ ai（\leq 4）$，表示这个牌面用了多少张。那么问题就转化成了求$ Σai \times xi=n $的正整数解个数，其中$ x1&lt;x2&lt;…&lt;xm，Σai≤k $。由于ai和k都比较小，我们可以暴力枚举所有情况，再去解方程。而现在约束还是比较多的，我们得想办法除去约束。</p>
<p>设$ yi=xi-x_{i-1} $，换元后方程变为$ Σbi \times yi=n $的形式，其中$ bi \leq k $。至此，我们成功把未知数单调这个棘手的约束解决了。</p>
<p>接下来，我们发现$bi$比较小$(≤10)$，那么可以把$bi$的lcm算出来，最多为<strong>2520</strong>。然后把$bi \times yi$表示成$ pi \times lcm+qi $的形式，其中$qi$必须能被$bi$整除。</p>
<p>现在方程转化为</p>
<script type="math/tex; mode=display">
lcm \times Σpi+Σqi=n。</script><p>考虑到$ Σqi $还是比较小的$(≤3W)$，可以枚举$ Σqi $的每个可能值，那么$pi$的方案数就可以用经典的隔板法来计算。而对于$ Σqi $的计算，我们可以用背包来实现。背包的时候要注意各种细节，而且注意复杂度的把握。</p>
<p><strong>期望得分：100</strong></p>
<p>（由于这道题我是实在不知道题解和代码的意思，所以就只能用std的代码了。。。我太CHAI了 害~~~）</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Poker Hewr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fo(i,a,b) for (int i=a; i&lt;=b; ++i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fd(i,a,b) for (int i=a; i&gt;=b; --i)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mo 1000000009</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mn=<span class="number">11</span>,mm=<span class="number">30010</span>;</span><br><span class="line"><span class="keyword">int</span> a[mn],d[mn],Rev[mn],f[mm],F[mm];</span><br><span class="line"><span class="keyword">int</span> n,k,m,L,Ans,NowS,N,A,B;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> c;</span><br><span class="line">	<span class="keyword">while</span> (c=(a%b)) a=b,b=c;</span><br><span class="line">	<span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (a&lt;b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret=Rev[b];</span><br><span class="line">	fo (i,a-b+<span class="number">1</span>,a) ret=(LL)ret*i%mo;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pow</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (b)&#123;</span><br><span class="line">		<span class="keyword">if</span> (b&amp;<span class="number">1</span>) ret=(LL)ret*a%mo;</span><br><span class="line">		a=(LL)a*a%mo,b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS) F[i]=f[i];</span><br><span class="line">	<span class="keyword">int</span> l=L/x*x;</span><br><span class="line">	fo (i,NowS+<span class="number">1</span>,<span class="built_in">min</span>(n,NowS+l)) F[i]=<span class="number">0</span>;</span><br><span class="line">	NowS=<span class="built_in">min</span>(n,NowS+l);</span><br><span class="line">	fo (i,<span class="number">0</span>,NowS)&#123;</span><br><span class="line">		f[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i&gt;=x)&#123;</span><br><span class="line">			F[i]=(F[i]+(f[i]=F[i-x]))%mo;</span><br><span class="line">			<span class="keyword">if</span> (i&gt;=l+x) f[i]=(f[i]-F[i-l-x]+mo)%mo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Ans=<span class="number">0</span>;</span><br><span class="line">	d[m]=a[m];</span><br><span class="line">	fd (i,m<span class="number">-1</span>,<span class="number">1</span>) d[i]=d[i+<span class="number">1</span>]+a[i];</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,NowS=<span class="number">0</span>,L=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,m) L=L*d[i]/gcd(L,d[i]);</span><br><span class="line">	fo (i,<span class="number">1</span>,m) dp(d[i]);</span><br><span class="line">	fo (nn,m,NowS) <span class="keyword">if</span> (!((N=n-nn)%L) &amp;&amp; (A=f[nn]))&#123;</span><br><span class="line">		B=C(N/L+m<span class="number">-1</span>,m<span class="number">-1</span>);</span><br><span class="line">		Ans=((LL)A*B+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> M,<span class="keyword">int</span> K,<span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (M&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		m=M<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">int</span> tmp=work();</span><br><span class="line">		Ans=((LL)tmp*W+Ans)%mo;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!K) <span class="keyword">return</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,<span class="number">4</span>) <span class="keyword">if</span> (i&lt;=K)&#123;</span><br><span class="line">		a[M]=i;</span><br><span class="line">		dfs(M+<span class="number">1</span>,K-i,(LL)W*C(<span class="number">4</span>,i)%mo);</span><br><span class="line">		a[M]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Rev[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	fo (i,<span class="number">1</span>,mn<span class="number">-1</span>) Rev[i]=(LL)Rev[i<span class="number">-1</span>]*Pow(i,mo<span class="number">-2</span>)%mo;</span><br><span class="line">	freopen(<span class="string">"poker.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"poker.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k)&#123;</span><br><span class="line">		<span class="keyword">if</span> (!(n+k)) <span class="keyword">break</span>;</span><br><span class="line">		Ans=<span class="number">0</span>;</span><br><span class="line">		dfs(<span class="number">1</span>,k,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;Ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200607赛后总结</title>
    <url>/articles/T20200607%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200607赛后总结"><a href="#T20200607赛后总结" class="headerlink" title="T20200607赛后总结"></a>T20200607赛后总结</h1><h2 id="成绩排行：T20200607成绩"><a href="#成绩排行：T20200607成绩" class="headerlink" title="成绩排行：T20200607成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200607/result2019.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200607/result2019.html">T20200607成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考试总体偏简单，主要是在T3上，最初的代码量高达150+行，我是真的懵逼了。。。虽然我知道绝对是错误的思路引起的，但我还是毅然决然的交了上去（<del>其实就是因为想着争取混一点分QwQ</del>），结果取得了5分的好成绩（此处应该有Big Hand！=&gt;至少证明我还是有潜能的吧。。。[<del>口胡</del>]）。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/LJIZiPxKV8WCSF7.png" alt="T20200607 exam.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题作为NOIP2016模拟题Day2T1，自然是有点神奇的。。。</p>
<p>不知道为什么最后测试来是90分，而不是满分。。。（听欧巨说是需要一个特判？？？QwQ）</p>
<p>首先看完题之后，第一个想到的就是贪心的抽屉原理（鸽巢原理），即：使得不正确的题将每$ k-1 $个正确的题隔开，那么绝对是最优的结果。</p>
<p>但思考片刻，发现情况可能复杂的多。上边的情况只是在保证不正确的题目个数$ s \leq \frac{Cor}{k-1} $的情况下成立。而对于$ s &gt; \frac{Cor}{k-1} $的情况就只能另当别论了。</p>
<p>在一番冥思苦想之后，发现！</p>
<p>在正确的题目数确定的情况下，将$s$个$ k-1 $的正确题目组合放在最后边是这种情况下最优的，即：先将所有的$Cor$放在最后边，每$k-1$个就用一个错误的隔开，最后在不正确的题目不够用时，就可以直接统计剩余的正确题目的数量了，又由于发现剩余题目的贡献是一个等差数列</p>
<script type="math/tex; mode=display">
Ans_{remain}+=\frac{a_1 \times (r^{remain}-1)}{r-1}</script><p>这鸭子之后这个题就被秒了！</p>
<p><strong>温馨提示</strong>：注意$ k=1 $时需要特判！</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//exam</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Cor,Limit,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"exam.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"exam.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>,Step=A%MOD;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*Step)%MOD;</span><br><span class="line">		Step=(Step*Step)%MOD;</span><br><span class="line">		B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Cor,&amp;Limit);</span><br><span class="line">	LL Mine=Total-Cor;</span><br><span class="line">	<span class="keyword">if</span>((Cor<span class="number">-1</span>)/(Limit<span class="number">-1</span>)+<span class="number">1</span>&lt;=Mine) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Cor); &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL Remain=Total-(Limit)*Mine;</span><br><span class="line">		LL New=Remain/Limit;</span><br><span class="line">		Ans=(((<span class="number">2</span>*Limit)%MOD)*(((Fast(<span class="number">2</span>,New)%MOD)<span class="number">-1</span>+MOD)%MOD));</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Ans+(Remain-New*Limit)%MOD)%MOD+Mine*(Limit<span class="number">-1</span>))%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>前缀和+单调队列</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/YPx7CHwbp5zdijl.png" alt="T20200607 genes.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>怎么说呢，考试的时候脑阔出问题了，考后直接打了一遍。</p>
<p>=&gt;一次编译成功=&gt;一次提交成功=&gt;直接AC=&gt;害~~~</p>
<p>首先可以想到改环成链。</p>
<p>然后发现这就是一个滑动窗口，每一个窗口如果不是优质基因序列，那么绝对存在这个窗口的某一个前缀&lt;0，因此可以想到维护一个单调队列来记录和更新当前窗口中前缀和的最小值。所以这道题就AC了。。。<del>汗</del></p>
<p>废话不多说，直接上代码</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//genes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Queue[MAXn],Head=<span class="number">1</span>,Tail,New;</span><br><span class="line">LL Total,Ans,Num[MAXn],Pre[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"genes.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"genes.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,Total+<span class="number">1</span>,<span class="number">2</span>*Total) &#123;</span><br><span class="line">		Num[i]=Num[i-Total] ;</span><br><span class="line">		Pre[i]=Pre[i<span class="number">-1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">2</span>*Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Queue[Head]&lt;i-Total) Head++;</span><br><span class="line">		<span class="keyword">while</span>(Head&lt;=Tail &amp;&amp; Pre[i]&lt;Pre[Queue[Tail]]) Tail--;</span><br><span class="line">		Queue[++Tail]=i;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total &amp;&amp; Pre[Queue[Head]]-New&gt;=<span class="number">0</span>) Ans++;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=Total) New=Pre[i-Total+<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">   fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/uBVn153NlwzhSTa.png" alt="T20200607 paths.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>这道题一看到，第一个想到的就是凸包！</p>
<p>内心活动：终于可以有施展拳脚的时候了。</p>
<p>但现实总是会给我一脚。。。每个点都要走？！</p>
<p>那直接记录其中一条线路啊，$ DP[n][4] $。直接4中状态转移，<del>它不香吗</del>，但是当我写完之后定睛一看，wo GIAO，为啥是150行？？？</p>
<p>所以我取得了5分的好成绩！</p>
<p>由于正解是真的ZZ，所以我就直接上正解了。</p>
<h4 id="【算法一】"><a href="#【算法一】" class="headerlink" title="【算法一】"></a>【算法一】</h4><p>由于每个点要么在去的路上，要么在回来的路上，所以用二进制数表示$N$个点的状态，对于特殊的点特判一下，然后从所有状态中取最优的</p>
<p><strong>期望得分：20分</strong></p>
<h4 id="【算法二】"><a href="#【算法二】" class="headerlink" title="【算法二】"></a>【算法二】</h4><p>考虑到每个点只能走一次，且从终点往回走和从起点再走一遍到终点没有区别，所以这道题可以转化为求两条不相交路径和的最小值。</p>
<p>于是考虑用动态规划求解。</p>
<p>用$ F[i][j] $表示第一个点走到i,第二个点(回去的那个点)走到j的最优值。</p>
<p>为了保证更新时不会更新出$ F[i][i] $(即一个点走了两次)，而且每个点都会在路径上，我们每次用$ F[i][j] $去更新点$ max(i,j)+1 $，所以转移方程为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">0</span>; k=<span class="built_in">max</span>(i,j)+<span class="number">1</span>，</span><br><span class="line">F[k][j]=<span class="built_in">max</span>(F[k][j],F[i][j]+Dis(i,k));</span><br><span class="line">F[i][k]=<span class="built_in">max</span>(F[i][k],F[i][j]+Dis(j,k));</span><br></pre></td></tr></table></figure>
<p>$ Dis(i,j) $为从i直接走到j点的距离.</p>
<p>对于两个特殊点和$ max(i,j)=N $的情况特判处理即可。</p>
<p><strong>期望得分：100</strong></p>
<h4 id="【算法三】"><a href="#【算法三】" class="headerlink" title="【算法三】"></a>【算法三】</h4><p>同时上面的DP也可以用记忆化搜索实现，对于$ |x-y|&gt;1 $的情况，说明当前情况只能从$ max(x,y)-1 $转移过来，当$ |x-y|=1 $时，则能从$ 1 \rightarrow min(x,y) $中的任意一点转移过来，于是用记忆化搜索完成上面的步骤，加上适当剪枝即可。</p>
<p><strong>期望得分：60~100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//paths</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> DP[MAXn][MAXn];</span><br><span class="line"><span class="keyword">int</span> Total,A,B;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">double</span> X,Y;</span><br><span class="line">&#125;Num[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"paths.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"paths.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node F,Node T)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sqrt</span>((F.X-T.X)*(F.X-T.X)+(F.Y-T.Y)*(F.Y-T.Y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Total,&amp;A,&amp;B);</span><br><span class="line">	A++; B++;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Num[i].X,&amp;Num[i].Y);</span><br><span class="line">	Cl(DP,<span class="number">0x7f</span>);</span><br><span class="line">	DP[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0.0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) </span><br><span class="line">		FOR(j,<span class="number">1</span>,Total) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i==Total &amp;&amp; j==Total) <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">int</span> k=<span class="built_in">max</span>(i,j);</span><br><span class="line">			<span class="keyword">if</span>(k==Total) &#123;</span><br><span class="line">				<span class="keyword">if</span>(k!=A &amp;&amp; j!=Total) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B &amp;&amp; i!=Total) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k]));</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				k++;</span><br><span class="line">				<span class="keyword">if</span>(k!=A) DP[i][k]=<span class="built_in">min</span>(DP[i][k],DP[i][j]+Distance(Num[j],Num[k]));</span><br><span class="line">				<span class="keyword">if</span>(k!=B) DP[k][j]=<span class="built_in">min</span>(DP[k][j],DP[i][j]+Distance(Num[i],Num[k])); </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,DP[Total][Total]);</span><br><span class="line"> fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>二分图扩展概念</title>
    <url>/articles/%E4%BA%8C%E5%88%86%E5%9B%BE%E6%89%A9%E5%B1%95%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分图扩展概念"><a href="#二分图扩展概念" class="headerlink" title="二分图扩展概念"></a>二分图扩展概念</h1><h2 id="最小顶点覆盖"><a href="#最小顶点覆盖" class="headerlink" title="最小顶点覆盖"></a>最小顶点覆盖</h2><p>在二分图中寻找一个尽量小的点集，使图中每一条边至少有一个点在该点集中。<br><strong>最小顶点覆盖 = 最大匹配</strong></p>
<h3 id="证明（反证法）"><a href="#证明（反证法）" class="headerlink" title="证明（反证法）"></a>证明（反证法）</h3><p>假设当前存在一条两个端点都不在最小顶点覆盖点集中，那么这么光芒四射的边定可以增大最大匹配边集，与最大匹配矛盾，所以得证。</p>
<h2 id="最小路径覆盖"><a href="#最小路径覆盖" class="headerlink" title="最小路径覆盖"></a>最小路径覆盖</h2><p>在二分图中寻找一个尽量小的边集，使图中每一个点都是该边集中某条边的端点。<br><strong>最小路径覆盖 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>因为一条边最多可以包含两个顶点，所以我们选边的时候让这样的边尽量多，也就是说最大匹配的边集数目咯。剩下的点就只能一个边连上一个点到集合里啦。</p>
<h2 id="最大独立集"><a href="#最大独立集" class="headerlink" title="最大独立集"></a>最大独立集</h2><p>在N个点中选出来一个最大点集，使这个点集中的任意两点之间都没有边。<br><strong>最大独立集 == 顶点数 - 最大匹配</strong></p>
<h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>因为去掉最大匹配两端的顶点去掉以后，剩下的点肯定是独立集。我们再从每个匹配里面挑选出来一个点加入到独立集中，也是不会破坏原有独立集的独立性的。</p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>快速乘 &amp; 龟速乘</title>
    <url>/articles/%E5%BF%AB%E9%80%9F%E4%B9%98-%E9%BE%9F%E9%80%9F%E4%B9%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="龟速乘"><a href="#龟速乘" class="headerlink" title="龟速乘"></a>龟速乘</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>就是用来解决LL $ \times $ LL%MOD时LL会爆掉但%MOD之后不会爆掉的运算</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Slow</span><span class="params">(LL L,LL R,LL M)</span> </span>&#123;</span><br><span class="line">    L=(L%M+M)%M; </span><br><span class="line">    R=(R%M+M)%M;<span class="comment">//我也不知道为什么 </span></span><br><span class="line">	LL Res=L*R-(LL)((LD)L/M*R+<span class="number">1e-8</span>)*M;</span><br><span class="line">	<span class="keyword">return</span> Res&lt;<span class="number">0</span> ? Res+M : Res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速乘"><a href="#快速乘" class="headerlink" title="快速乘"></a>快速乘</h1><h2 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h2><p>与龟速乘同理，只是改变了一下形式，用类似快速幂的方式完成QwQ</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">quick_mul</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x,<span class="keyword">long</span> <span class="keyword">long</span> y,<span class="keyword">long</span> <span class="keyword">long</span> mod)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">long</span> <span class="keyword">long</span> ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y &amp; <span class="number">1</span> == <span class="number">1</span>)ans+=x,ans%=mod;</span><br><span class="line">        x=x+x,x%=mod;</span><br><span class="line">    	y&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>树上三点最短路</title>
    <url>/articles/%E6%A0%91%E4%B8%8A%E4%B8%89%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树上三点最短路"><a href="#树上三点最短路" class="headerlink" title="树上三点最短路"></a>树上三点最短路</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p>若这三个点为$u$,$v$,$w$<br>首先通<strong>瞪眼法</strong>可以发现</p>
<h3 id="性质一"><a href="#性质一" class="headerlink" title="性质一"></a>性质一</h3><p>a=LCA(u,v),b=LCA(u,w),c=LCA(v,w)中一定有两个是相等的，即u,v,w中绝对有两个的最近公共祖先是同一个点<br>同样的，通过<strong>信仰模拟法</strong>可以发现</p>
<h3 id="性质二"><a href="#性质二" class="headerlink" title="性质二"></a>性质二</h3><p>三点之间的最短路=Dep[u]+Dep[v]+Dep[w]-Dep[a]-Dep[b]-Dep[c];</p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200529赛后总结</title>
    <url>/articles/T20200529%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200529赛后总结"><a href="#T20200529赛后总结" class="headerlink" title="T20200529赛后总结"></a>T20200529赛后总结</h1><h2 id="成绩排行：T20200529成绩"><a href="#成绩排行：T20200529成绩" class="headerlink" title="成绩排行：T20200529成绩)"></a>成绩排行：<a href="[file:///C:/Users/DeNeRATe/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/T20200529/result20200529.html](file:///C:/Users/DeNeRATe/Desktop/竞赛试题/T20200529/result20200529.html">T20200529成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是集训的第一套题。。。可谓是<strong>开门黑</strong>。</p>
<p>在此膜拜 stO 欧巨 Orz。</p>
<p>总的来说，这一套题除了第二题外没有什么难搞的，好吧，T3的代码量有点大。。。</p>
<p>本以为T1瞬秒之后准备AK了。。。结果T3我成功反驳了我的正确思路QwQ</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>乱搞</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/FyraMX3N4cH6GgY.png" alt="T20200529 words.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>定睛手膜一下样例可以知道，若我分析到$tr$了，下一个是$e$，如果直接算下一个$tre$个数量的话，会有一部分重复，而这部分的重复个数刚好就是$tr$之后的这个字母在$heap$里边的出现次数，因此，在手摸几个样例发现，这个思路确实是毫无破绽，那么正解不就出来了吗。。。</p>
<p>温馨提示：我就是因为没有判首尾是否需要算入答案的情况，使得我的100=&gt;0wonderful!</p>
<p><strong>时间复杂度：$ O(2n) $</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//words</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> A[MAXn],B[MAXn];</span><br><span class="line">LL Cnt[<span class="number">30</span>],DP,Ans,Lena,Lenb;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"words.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"words.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,A+<span class="number">1</span>); <span class="built_in">scanf</span>(<span class="string">"%s"</span>,B+<span class="number">1</span>);</span><br><span class="line">	Lena=<span class="built_in">strlen</span>(A+<span class="number">1</span>); Lenb=<span class="built_in">strlen</span>(B+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Lenb<span class="number">-1</span>) Cnt[B[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Lena) &#123;</span><br><span class="line">		DP=Lenb-Cnt[A[i]-<span class="string">'a'</span>+<span class="number">1</span>],Ans+=DP;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans+Lenb);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+斜率优化</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/NTXyKD1ALVrlOou.png" alt="T20200529 distance.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>当我看到$ n \leq 1,000 $，然后又看到是一个矩阵时，我就知道了这道题100%是一个<strong>$ O(n^2) $</strong>的时间复杂度。</p>
<p>继而就没什么思路了。</p>
<p>（我发现我口胡这道题好像不太行，那就直接上题解？）</p>
<blockquote>
<p>分别从左上，右上，左下，右下四个方向做一次斜率DP取最优值即可。</p>
</blockquote>
<p>没错，这个就是solution里边写的东西，你看，这是人说的话吗？！</p>
<p>$ \approx $没说。。。所以，最后还是需要我来口胡一哈。。。</p>
<p>相当于就是记录每一行的一个单调队列，因为对于同一行，他们的纵坐标是一定的，那么横坐标又是单调递增的，所以可以直接推出转移式，记录并转移（<del>口胡完毕</del>）</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//distance</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Row,Line,DP[MAXn][MAXn],Dis[MAXn];</span><br><span class="line"><span class="keyword">char</span> Sta[MAXn][MAXn];</span><br><span class="line">LL Cube[MAXn][MAXn],F[MAXn][MAXn];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL X,Y;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">friend</span> Node <span class="keyword">operator</span> - (Node A,Node B) &#123;</span><br><span class="line">		Node Temp;</span><br><span class="line">		Temp.X=A.X-B.X; </span><br><span class="line">		Temp.Y=A.Y-B.Y;</span><br><span class="line">		<span class="keyword">return</span> Temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;Queue[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.X*B.Y-A.Y*B.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Cross</span><span class="params">(Node A,Node B,Node C)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> Cross(B-A,C-A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"distance.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"distance.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Calc</span><span class="params">(Node A,LL Loc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> A.Y<span class="number">-2</span>*Loc*A.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		LL Head=<span class="number">0</span>,Tail=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Sta[i][j]==<span class="string">'1'</span>) Dis[i]=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> ++Dis[i];</span><br><span class="line">			Node New;</span><br><span class="line">			New.X=j; New.Y=j*j+Dis[j]*Dis[j];</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Cross(Queue[Tail<span class="number">-1</span>],Queue[Tail],New)&lt;=<span class="number">0</span>) Tail--;</span><br><span class="line">			Queue[++Tail]=New;</span><br><span class="line">			<span class="keyword">while</span>(Head+<span class="number">1</span>&lt;Tail &amp;&amp; Calc(Queue[Head+<span class="number">1</span>],j)&gt;Calc(Queue[Head+<span class="number">2</span>],j)) Head++;</span><br><span class="line">			DP[i][j]=Calc(Queue[Head+<span class="number">1</span>],j)+j*j;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>(); </span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Row,&amp;Line);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,Sta[i]+<span class="number">1</span>);</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) Cube[i][j]=Sta[i][j];</span><br><span class="line">	&#125;</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = DP[i][j];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[i][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j) </span><br><span class="line">			Sta[i][j] = Cube[Row - i + <span class="number">1</span>][j];</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][j]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i)</span><br><span class="line">		reverse(Sta[i] + <span class="number">1</span>, Sta[i] + Line + <span class="number">1</span>);</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row;++i)</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			F[i][j] = <span class="built_in">min</span>(F[i][j], DP[Row - i + <span class="number">1</span>][Line - j + <span class="number">1</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> (LL i = <span class="number">1</span>; i &lt;= Row; ++i) &#123;</span><br><span class="line">		<span class="keyword">for</span> (LL j = <span class="number">1</span>; j &lt;= Line; ++j)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%lld%c"</span>, F[i][j], j == Line ? <span class="string">'\n'</span> : <span class="string">' '</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>洛谷同题<a href="https://www.luogu.com.cn/problem/P6122" target="_blank" rel="noopener">P6122 Mole Tunnels</a></p>
<h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>模拟最大流+贪心</strong></p>
<p>但是我觉得（<strong>树链剖分+贪心</strong>）也是可以的</p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/06/24/KUHBTmeN9fWcDGY.png" alt="T20200529 tree.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>首先观察到，这道题的树非常的特殊，是一颗完美二叉树，这就不免是我们想到这道题一定不简单，没错我就是被这种思想禁锢了。。。使得我最后用手摸样例推翻了我自己的思路。。。害~~~</p>
<p><img src="https://i.loli.net/2020/06/24/B4NpU8E1OMaKS2z.png" alt="T20200529 tree 草稿1.png"></p>
<p>可以发现这个时候有两条边被重复走了。那么我们肯定可以找出更优解，即：</p>
<p><img src="https://i.loli.net/2020/06/24/GkIDg3u4ytUbP8R.png" alt="T20200529 tree 草稿2.png"></p>
<p>这个时候，我们发现这两条被来回走过的边，<strong>他们无了！！！</strong>。</p>
<p>脑洞瞬间打开（而我不一样，我不知道为啥举了一个假样例，否定了我的想法。。。）</p>
<p>所以我们可以维护每一条边的使用次数，记向上走的为$+1$，向下走的为$-1$，那么就可以用（树链剖分）模拟最大流来通过这道题。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P6122</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">4e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Dis[MAXn],Loc[MAXn],Flow[MAXn];</span><br><span class="line">LL Hole,Total,Food[MAXn],New,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_down</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&gt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Len_up</span><span class="params">(LL X)</span> </span>&#123; <span class="keyword">return</span> Flow[X]&lt;<span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">    Dis[X]=INF; Loc[X]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(Food[X]) Dis[X]=<span class="number">0</span>,Loc[X]=X;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Lson]+Len_down(Lson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Lson]+Len_down(Lson);</span><br><span class="line">        Loc[X]=Loc[Lson];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Dis[X]&gt;Dis[Rson]+Len_down(Rson)) &#123;</span><br><span class="line">        Dis[X]=Dis[Rson]+Len_down(Rson);</span><br><span class="line">        Loc[X]=Loc[Rson];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Hole,&amp;Total);</span><br><span class="line">    Cl(Dis,<span class="number">0x3f</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Hole) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Food[i]);</span><br><span class="line">    BOR(i,Hole,<span class="number">1</span>) Update(i);</span><br><span class="line">    <span class="keyword">while</span>(Total--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;New);</span><br><span class="line">        LL Tag=<span class="number">0</span>,Cost=INF,Temp=<span class="number">0</span>,LCA=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(Cost&gt;Temp+Dis[X]) Tag=Loc[X],LCA=X,Cost=Temp+Dis[X];</span><br><span class="line">            Temp+=Len_up(X);</span><br><span class="line">        &#125;</span><br><span class="line">        Ans+=Cost;</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]++;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Flow[X]--;</span><br><span class="line">        Food[Tag]--;</span><br><span class="line">        <span class="keyword">for</span>(LL X=Tag;X!=LCA;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="keyword">for</span>(LL X=New;X!=<span class="number">0</span>;X&gt;&gt;=<span class="number">1</span>) Update(X);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Maker</title>
    <url>/articles/%E6%95%B0%E6%8D%AE%E5%88%B6%E9%80%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据制造"><a href="#数据制造" class="headerlink" title="数据制造"></a>数据制造</h1><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>最近突然来了兴趣，出了一场比赛，有了一些心得吧，也学到了很多。</p>
<p>所以这里来说一下<strong>批量制造数据</strong></p>
<p><img src="https://i.loli.net/2020/07/13/ZUVmd4ew2figDxI.png" alt="数据制造-1.png"></p>
<p>所以，其实原理简单的一批，<strong>困难的主要是如何设计好的data</strong>，这个真的是体验之后感悟颇深（<del>感觉出数据比写程序还难。。。</del>）</p>
<h2 id="rand-和srand-产生随机数"><a href="#rand-和srand-产生随机数" class="headerlink" title="rand()和srand()产生随机数"></a>rand()和srand()产生随机数</h2><p><strong>rand()​</strong>函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个<strong>伪随机数</strong>，是根据一个数，我们可以称它为种子，为基准以某个递推公式推算出来的一系数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统，为了改变这个种子的值，C提供了 <strong>srand()​</strong>函数，它的原形是<strong>void srand( int a)​</strong><br>   初始化随机产生器既rand()函数的初始值，即使把种子的值改成a; 从这你可以看到通过sand()函数，我们是可以产生可以预见的随机序列,那我们如何才能产生不可预见的随机序列呢？我们可能常常需要这样的随机序列，是吧。利用<strong>srand((unsigned)time(NULL))​</strong>是一种方法，因为每一次运行程序的时间是不同的.</p>
<p>$rand()$会返回一随机数值，范围在<strong>0至RAND_MAX​</strong> 间。返回0至RAND_MAX之间的随机数值，RAND_MAX定义在<strong>stdlib.h</strong>，(其值至少为32767)，运算的结果是一个不定的数，要看你定义的变量类型，int整形的话就是32767。 在调用此函数产生随机数前，必须先利用$srand()$设好随机数种子，如果未设随机数种子，$rand()$在调用时会自动设随机数种子为<strong>1</strong>。一般用for语句来设置种子的个数。</p>
<p><strong>random（）产生随机数为0或1；</strong></p>
<p><strong>random（n）产生随机数为0到n之间的一个随机数；</strong></p>
<p><strong>rand（）产生0到32768之间的一个随机数。</strong></p>
<h3 id="产生指定范围的随机数"><a href="#产生指定范围的随机数" class="headerlink" title="产生指定范围的随机数"></a>产生指定范围的随机数</h3><p>由于$rand$产生的随机数从0到$rand_max$，而$rand_max$是一个很大的数，那么如何产生从$X \rightarrow Y$的数呢？</p>
<p>  从$X$到$Y$，有$Y-X+1$个数，所以要产生从$X$到$Y$的数，只需要这样写：</p>
<script type="math/tex; mode=display">
k=rand()\%(Y-X+1)+X</script><p>  这样，就可以产生你想要的任何范围内的随机数了。</p>
<h3 id="32bits随机数"><a href="#32bits随机数" class="headerlink" title="32bits随机数"></a>32bits随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generate a random 32 bits integer number </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rand32</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((rand()&lt;&lt;<span class="number">16</span>)+(rand()&lt;&lt;<span class="number">1</span>)+rand()%<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了32bits的随机数生成方法，就可以构造32bits范围内的随机整数区间了，方法和之前16bits的情况一样。</p>
<h3 id="32bits范围内的随机整数区间"><a href="#32bits范围内的随机整数区间" class="headerlink" title="32bits范围内的随机整数区间"></a>32bits范围内的随机整数区间</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//generate a random 32bits integer number in [start,end)</span></span><br><span class="line"> <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">uniform_integer_32</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> <span class="built_in">end</span>)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> base=rand32();</span><br><span class="line">    <span class="keyword">if</span>(base==RAND32_MAX)</span><br><span class="line">        <span class="keyword">return</span> uniform_integer_32(start,<span class="built_in">end</span>);</span><br><span class="line">    <span class="keyword">int</span> range=<span class="built_in">end</span>-start;</span><br><span class="line">    <span class="keyword">int</span> remainder=RAND32_MAX%range;</span><br><span class="line">    <span class="keyword">int</span> bucket=RAND32_MAX/range;</span><br><span class="line">    <span class="keyword">if</span>(base&lt;RAND32_MAX-remainder)</span><br><span class="line">        <span class="keyword">return</span> start+base/bucket;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> uniform_integer_32(start,<span class="built_in">end</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>Awesome TEST</title>
    <url>/articles/TEST/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>Nothing Here</strong></p>
<p><strong>Just A Test</strong></p>
]]></content>
      <tags>
        <tag>Awesome TEST</tag>
      </tags>
  </entry>
  <entry>
    <title>期末理综专项复习信心赛-题解</title>
    <url>/articles/%E6%9C%9F%E6%9C%AB%E7%90%86%E7%BB%BC%E4%B8%93%E9%A1%B9%E5%A4%8D%E4%B9%A0%E4%BF%A1%E5%BF%83%E8%B5%9B-%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>Personal Program</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11中vector的N种遍历方式</title>
    <url>/articles/C-11%E4%B8%ADvector%E7%9A%84N%E7%A7%8D%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-11中vector的N种遍历方式"><a href="#C-11中vector的N种遍历方式" class="headerlink" title="C++11中vector的N种遍历方式"></a>C++11中vector的N种遍历方式</h1><h2 id="1-老式遍历"><a href="#1-老式遍历" class="headerlink" title="1.老式遍历"></a>1.老式遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Count=New.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Count;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;New[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-for循环迭代器遍历"><a href="#2-for循环迭代器遍历" class="headerlink" title="2.for循环迭代器遍历"></a>2.for循环迭代器遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator Iter=New.vbegin();Iter!=New.cend();Iter++) </span><br><span class="line">    	<span class="built_in">cout</span>&lt;&lt;*Iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-auto迭代器遍历"><a href="#3-auto迭代器遍历" class="headerlink" title="3.auto迭代器遍历"></a>3.auto迭代器遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> Iter=New.cbegin();Iter!=New.cend();Iter++) </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;*Iter&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-for-each函数遍历"><a href="#4-for-each函数遍历" class="headerlink" title="4.for_each函数遍历"></a>4.for_each函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">(<span class="keyword">const</span> T&amp; Val)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">	for_each(New.cbegin(),New.cend(),Print&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-for-each-仿函数遍历"><a href="#5-for-each-仿函数遍历" class="headerlink" title="5.for_each+仿函数遍历"></a>5.for_each+仿函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Functor</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> T&amp; Obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="built_in">cout</span>&gt;&gt;Obj&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">	for_each(New.cbegin(),New.cend(),Functor&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-for-each-Lambda函数遍历"><a href="#6-for-each-Lambda函数遍历" class="headerlink" title="6.for_each+Lambda函数遍历"></a>6.for_each+Lambda函数遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">ShowVec</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; New)</span> </span>&#123;</span><br><span class="line">    for_each(New.cbegin(),New.cend(),[](<span class="keyword">const</span> <span class="keyword">int</span>&amp; Val)-&gt;<span class="keyword">void</span>&#123; <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-for区间遍历"><a href="#7-for区间遍历" class="headerlink" title="7.for区间遍历"></a>7.for区间遍历</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> Val : New) &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;Val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-ETC"><a href="#8-ETC" class="headerlink" title="8.ETC."></a>8.ETC.</h2>]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基操</title>
    <url>/articles/Markdown%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Markdown基操"><a href="#Markdown基操" class="headerlink" title="Markdown基操"></a>Markdown基操</h1><h2 id="一-基础格式"><a href="#一-基础格式" class="headerlink" title="一.基础格式"></a>一.基础格式</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1.标题"></a>1.标题</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span># 这是一级标题</span><br><span class="line"><span class="symbol">2 </span>## 这是二级标题</span><br><span class="line"><span class="symbol">3 </span>### 这是三级标题</span><br><span class="line"><span class="symbol">4 </span>#### 这是四级标题</span><br><span class="line"><span class="symbol">5 </span>##### 这是五级标题</span><br><span class="line"><span class="symbol">6 </span>###### 这是六级标题</span><br></pre></td></tr></table></figure>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2.字体"></a>2.字体</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>**这是加粗的文字**</span><br><span class="line"><span class="symbol">2 </span>*这是倾斜的文字*`</span><br><span class="line"><span class="symbol">3 </span>***这是斜体加粗的文字***</span><br><span class="line"><span class="symbol">4 </span>~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br><em>这是倾斜的文字</em><br><strong><em>这是斜体加粗的文字\</em></strong><br><del>这是加删除线的文字</del></p>
<h3 id="3-引用"><a href="#3-引用" class="headerlink" title="3.引用"></a>3.引用</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>&gt;这是引用的内容</span><br><span class="line"><span class="symbol">2 </span>&gt;&gt;这是引用的内容</span><br><span class="line"><span class="symbol">3 </span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>
<p>效果如下：（。。。博客园的格式有点不一样鹅。。。）</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h3 id="4-分割线"><a href="#4-分割线" class="headerlink" title="4.分割线"></a>4.分割线</h3><p>（三个或者三个以上的 - 或者 * 都可以。）</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>---</span><br><span class="line"><span class="symbol">2 </span>----</span><br><span class="line"><span class="symbol">3 </span>***</span><br><span class="line"><span class="symbol">4 </span>*****</span><br></pre></td></tr></table></figure>
<p>（好像展示效果也没啥用。。。）</p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h3><p>（好吧 我太懒了 [好像各个地方都可以在写Markdown的时候直接插入图片，链接，代码和列表吧] 逃 QwQ）</p>
<p>（当然还是有一个基础的，换行：2<em>Space+1</em>Enter）</p>
<h2 id="二-数学公式语法"><a href="#二-数学公式语法" class="headerlink" title="二.数学公式语法"></a>二.数学公式语法</h2><h3 id="1-行内和独行"><a href="#1-行内和独行" class="headerlink" title="1.行内和独行"></a>1.行内和独行</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>行内公式：将公式插入到本行内，符号：$公式内容$，如：$ xyz $</span><br><span class="line"><span class="symbol">2 </span>独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$ xyz $$</span><br></pre></td></tr></table></figure>
<h3 id="2-上标，下标和组合"><a href="#2-上标，下标和组合" class="headerlink" title="2.上标，下标和组合"></a>2.上标，下标和组合</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>上标符号，符号：^，如：$x^<span class="number">4</span>$</span><br><span class="line"><span class="symbol">2 </span>下标符号，符号：_，如：$x_1$</span><br><span class="line"><span class="symbol">3 </span>组合符号，符号：&#123;&#125;，如：$&#123;<span class="number">16</span>&#125;_&#123;<span class="number">8</span>&#125;O&#123;<span class="number">2</span>+&#125;_&#123;<span class="number">2</span>&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="3-字体格式"><a href="#3-字体格式" class="headerlink" title="3.字体格式"></a>3.字体格式</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>字体控制，符号：\displaystyle，如：$\displaystyle \frac&#123;x+y&#125;&#123;y+z&#125;$</span><br><span class="line"><span class="symbol">2 </span>下划线符号，符号：\underline，如：$\underline&#123;x+y&#125;$</span><br><span class="line"><span class="symbol">3 </span>上大括号，符号：\overbrace&#123;算式&#125;，如：$\overbrace&#123;a+b+c+d&#125;^&#123;<span class="number">2.0</span>&#125;$</span><br><span class="line"><span class="symbol">4 </span>下大括号，符号：\underbrace&#123;算式&#125;，如：$a+\underbrace&#123;b+c&#125;_&#123;<span class="number">1.0</span>&#125;+d$</span><br><span class="line"><span class="symbol">5 </span>上位符号，符号：\stacrel&#123;上位符号&#125;&#123;基位符号&#125;，如：$\vec&#123;x&#125;\stackrel&#123;\mathrm&#123;<span class="keyword">def</span>&#125;&#125;&#123;=&#125;&#123;x_1,\dots,x_n&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="4-占位符"><a href="#4-占位符" class="headerlink" title="4.占位符"></a>4.占位符</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>紧贴，符号\!，如：$x \! y$  </span><br><span class="line"><span class="symbol">2 </span>没有空格，符号``，如：$xy$  </span><br><span class="line"><span class="symbol">3 </span>小空格，符号\,，如：$x \, y$  </span><br><span class="line"><span class="symbol">4 </span>中空格，符号\:，如：$x \: y$  </span><br><span class="line"><span class="symbol">5 </span>大空格，符号\，如：$x \ y$  </span><br><span class="line"><span class="symbol">6 </span>quad空格，符号：\quad，如：$x \quad y$</span><br><span class="line"><span class="symbol">7 </span>两个quad空格，符号：\qquad，如：$x \qquad y$</span><br></pre></td></tr></table></figure>
<h3 id="5-定界符"><a href="#5-定界符" class="headerlink" title="5.定界符"></a>5.定界符</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>小括号，符号：（），如：$ (x+y) $</span><br><span class="line"><span class="symbol">2 </span>中括号，符号： []，如：$ [x+y] $</span><br><span class="line"><span class="symbol">3 </span>各种大小的括号，符号：\big  \Big  \bigg  \Bigg</span><br><span class="line"><span class="symbol">4 </span>自适应括号，符号：\left \right，如：$\left(x\right)$，$\left(x&#123;yz&#125;\right)$</span><br><span class="line"><span class="number">5</span>大括号，符号：\lbrace \rbrace，如：$\lbrace x \rbrace$</span><br></pre></td></tr></table></figure>
<h3 id="6-组合"><a href="#6-组合" class="headerlink" title="6.组合"></a>6.组合</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>组合公式，符号：&#123;上位公式 \choose 下位公式&#125;，如：$&#123;n+<span class="number">1</span> \choose k&#125;=&#123;n \choose k&#125;+&#123;n \choose k-<span class="number">1</span>&#125;$</span><br></pre></td></tr></table></figure>
<h3 id="7-四则运算"><a href="#7-四则运算" class="headerlink" title="7.四则运算"></a>7.四则运算</h3><figure class="highlight gml"><table><tr><td class="code"><pre><span class="line"> <span class="number">1</span> 加法运算，符号：+，如：$<span class="symbol">x</span>+<span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">2</span> 减法运算，符号：-，如：$<span class="symbol">x</span>-<span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">3</span> 加减运算，符号：\pm，如：$<span class="symbol">x</span> \pm <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">4</span> 减甲运算，符号：\mp，如：$<span class="symbol">x</span> \mp <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">5</span> 乘法运算，符号：\times，如：$<span class="symbol">x</span> \times <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">6</span> 点乘运算，符号：\cdot，如：$<span class="symbol">x</span> \cdot <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">7</span> 星乘运算，符号：\ast，如：$<span class="symbol">x</span> \ast <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">8</span> 除法运算，符号：\<span class="keyword">div</span>，如：$<span class="symbol">x</span> \<span class="keyword">div</span> <span class="symbol">y</span>=z$</span><br><span class="line"> <span class="number">9</span> 斜法运算，符号：/，如：$<span class="symbol">x</span>/<span class="symbol">y</span>=z$</span><br><span class="line"><span class="number">10</span> 分式表示，符号：\<span class="built_in">frac</span>&#123;分子&#125;&#123;分母&#125;，如：$\<span class="built_in">frac</span>&#123;<span class="symbol">x</span>+<span class="symbol">y</span>&#125;&#123;<span class="symbol">y</span>+z&#125;$</span><br><span class="line"><span class="number">11</span> 分式表示，符号：&#123;分子&#125; \voer &#123;分母&#125;，如：$&#123;<span class="symbol">x</span>+<span class="symbol">y</span>&#125; \over &#123;<span class="symbol">y</span>+z&#125;$</span><br><span class="line"><span class="number">12</span> 绝对值表示，符号：||，如：$|<span class="symbol">x</span>+<span class="symbol">y</span>|$</span><br></pre></td></tr></table></figure>
<h3 id="8-高级运算"><a href="#8-高级运算" class="headerlink" title="8.高级运算"></a>8.高级运算</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>平均数运算，符号：\overline&#123;算式&#125;，如：$\overline&#123;xyz&#125;$</span><br><span class="line"><span class="symbol">2 </span>开二次方运算，符号：\sqrt，如：$\sqrt x$</span><br><span class="line"><span class="symbol">3 </span>开方运算，符号：\sqrt[开方数]&#123;被开方数&#125;，如：$\sqrt[<span class="number">3</span>]&#123;x+y&#125;$</span><br><span class="line"><span class="symbol">4 </span>对数运算，符号：\<span class="keyword">log</span>，如：$\<span class="keyword">log</span>(x)$</span><br><span class="line"><span class="symbol">5 </span>极限运算，符号：\lim，如：$\lim^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">6 </span>极限运算，符号：\displaystyle \lim，如：$\displaystyle \lim^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">7 </span>求和运算，符号：\sum，如：$\sum^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">8 </span>求和运算，符号：\displaystyle \sum，如：$\displaystyle \sum^&#123;x \<span class="keyword">to</span> \infty&#125;_&#123;y \<span class="keyword">to</span> <span class="number">0</span>&#125;&#123;\frac&#123;x&#125;&#123;y&#125;&#125;$</span><br><span class="line"><span class="symbol">9 </span>异或运算，符号：\bigoplus，如：$x \bigoplus y$</span><br></pre></td></tr></table></figure>
<p>（好吧，蒟蒻我由于没用过积分符号，所以就。。。逃）（矩阵Markdown不知道怎么搞，所以。。。）</p>
<h3 id="9-逻辑运算"><a href="#9-逻辑运算" class="headerlink" title="9.逻辑运算"></a>9.逻辑运算</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span>等于运算，符号：=，如：$x+y=z$</span><br><span class="line"><span class="symbol">2 </span>大于运算，符号：&gt;，如：$x+y&gt;z$</span><br><span class="line"><span class="symbol">3 </span>小于运算，符号：&lt;，如：$x+y&lt;z$</span><br><span class="line"><span class="symbol">4 </span>大于等于运算，符号：\geq，如：$x+y \geq z$</span><br><span class="line"><span class="symbol">5 </span>小于等于运算，符号：\leq，如：$x+y \leq z$</span><br><span class="line"><span class="symbol">6 </span>不等于运算，符号：\neq，如：$x+y \neq z$</span><br><span class="line"><span class="symbol">7 </span>约等于运算，符号：\approx，如：$x+y \approx z$</span><br><span class="line"><span class="symbol">8 </span>恒定等于运算，符号：\equiv，如：$x+y \equiv z$</span><br></pre></td></tr></table></figure>
<h3 id="10-集合运算"><a href="#10-集合运算" class="headerlink" title="10.集合运算"></a>10.集合运算</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> 1 属于运算，符号：<span class="tag">\<span class="name">in</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">in</span></span> y$</span></span><br><span class="line"> 2 不属于运算，符号：<span class="tag">\<span class="name">notin</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">notin</span></span> y$</span></span><br><span class="line"> 3 不属于运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">in</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">in</span></span> y$</span></span><br><span class="line"> 4 子集运算，符号：<span class="tag">\<span class="name">subset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subset</span></span> y$</span></span><br><span class="line"> 5 子集运算，符号：<span class="tag">\<span class="name">supset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supset</span></span> y$</span></span><br><span class="line"> 6 真子集运算，符号：<span class="tag">\<span class="name">subseteq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subseteq</span></span> y$</span></span><br><span class="line"> 7 非真子集运算，符号：<span class="tag">\<span class="name">subsetneq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">subsetneq</span></span> y$</span></span><br><span class="line"> 8 真子集运算，符号：<span class="tag">\<span class="name">supseteq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supseteq</span></span> y$</span></span><br><span class="line"> 9 非真子集运算，符号：<span class="tag">\<span class="name">supsetneq</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">supsetneq</span></span> y$</span></span><br><span class="line">10 非子集运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">subset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">subset</span></span> y$</span></span><br><span class="line">11 非子集运算，符号：<span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">supset</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">not</span></span><span class="tag">\<span class="name">supset</span></span> y$</span></span><br><span class="line">12 并集运算，符号：<span class="tag">\<span class="name">cup</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">cup</span></span> y$</span></span><br><span class="line">13 交集运算，符号：<span class="tag">\<span class="name">cap</span></span>，如：<span class="formula">$x <span class="tag">\<span class="name">cap</span></span> y$</span></span><br><span class="line">14 实数集合，符号：<span class="tag">\<span class="name">mathbb</span><span class="string">&#123;R&#125;</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;R&#125;</span></span> $</span></span><br><span class="line">15 自然数集合，符号：<span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Z&#125;</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Z&#125;</span></span> $</span></span><br><span class="line">16 空集，符号：<span class="tag">\<span class="name">emptyset</span></span>，如：<span class="formula">$ <span class="tag">\<span class="name">emptyset</span></span> $</span></span><br></pre></td></tr></table></figure>
<p>（至于差集那些的没听说过。。。）</p>
<h3 id="11-数学符号"><a href="#11-数学符号" class="headerlink" title="11.数学符号"></a>11.数学符号</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"> 1 无穷，符号：<span class="tag">\<span class="name">infty</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">infty</span></span>$</span></span><br><span class="line"> 2 虚数，符号：<span class="tag">\<span class="name">imath</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">imath</span></span>$</span></span><br><span class="line"> 3 虚数，符号：<span class="tag">\<span class="name">jmath</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">jmath</span></span>$</span></span><br><span class="line"> 4 矢量符号，符号<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">vec</span><span class="string">&#123;a&#125;</span></span>$</span></span><br><span class="line"> 5 上箭头，符号：<span class="tag">\<span class="name">uparrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">uparrow</span></span>$</span></span><br><span class="line"> 6 上箭头，符号：<span class="tag">\<span class="name">Uparrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Uparrow</span></span>$</span></span><br><span class="line"> 7 下箭头，符号：<span class="tag">\<span class="name">downarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">downarrow</span></span>$</span></span><br><span class="line"> 8 下箭头，符号：<span class="tag">\<span class="name">Downarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Downarrow</span></span>$</span></span><br><span class="line"> 9 左箭头，符号：<span class="tag">\<span class="name">leftarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">leftarrow</span></span>$</span></span><br><span class="line">10 左箭头，符号：<span class="tag">\<span class="name">Leftarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Leftarrow</span></span>$</span></span><br><span class="line">11 右箭头，符号：<span class="tag">\<span class="name">rightarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">rightarrow</span></span>$</span></span><br><span class="line">12 右箭头，符号：<span class="tag">\<span class="name">Rightarrow</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">Rightarrow</span></span>$</span></span><br><span class="line">13 底端对齐的省略号，符号：<span class="tag">\<span class="name">ldots</span></span>，如：<span class="formula">$1,2,<span class="tag">\<span class="name">ldots</span></span>,n$</span></span><br><span class="line">14 中线对齐的省略号，符号：<span class="tag">\<span class="name">cdots</span></span>，如：<span class="formula">$x_1^2 + x_2^2 + <span class="tag">\<span class="name">cdots</span></span> + x_n^2$</span></span><br><span class="line">15 竖直对齐的省略号，符号：<span class="tag">\<span class="name">vdots</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">vdots</span></span>$</span></span><br><span class="line">16 斜对齐的省略号，符号：<span class="tag">\<span class="name">ddots</span></span>，如：<span class="formula">$<span class="tag">\<span class="name">ddots</span></span>$</span></span><br></pre></td></tr></table></figure>
<h3 id="12-希腊字母"><a href="#12-希腊字母" class="headerlink" title="12.希腊字母"></a>12.希腊字母</h3><p><img src="https://i.loli.net/2020/09/12/dt7ElwCO6XzyYVA.png" alt="Markdown基操.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="https://www.jianshu.com/p/191d1e21f7ed" target="_blank" rel="noopener">HERE</a></p>
<p>2.<a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">HERE</a></p>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>memset处理</title>
    <url>/articles/memset%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="memset处理"><a href="#memset处理" class="headerlink" title="memset处理"></a>memset处理</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇主要是方便到时候忘了<strong>memset初始化赋值形式</strong>时参考一下</p>
<h2 id="赋值方式"><a href="#赋值方式" class="headerlink" title="赋值方式"></a>赋值方式</h2><p>memset赋值时时赋的<strong>ASCLL码</strong>转化为的<strong>二进制</strong></p>
<p>比如：memset(,0xff,sizeof())，0xff转化为二进制为11111111，int为4Byte所以最后为11111111111111111111111111111111为-1。(化为<strong>二进制补位</strong>，然后再赋值)。</p>
<h2 id="部分常用"><a href="#部分常用" class="headerlink" title="部分常用"></a>部分常用</h2><h3 id="int-amp-long-long"><a href="#int-amp-long-long" class="headerlink" title="int &amp; long long"></a>int &amp; long long</h3><p><strong>最大值</strong>：memset(New,0x7F,sizeof(New)) //将New中的值全部赋为<strong>2139062143</strong></p>
<p><strong>较大值</strong>：memset(New,0x3F,sizeof(New)) //这种赋值可以进行加操作并<strong>不会溢出</strong></p>
<p><strong>最小值</strong>：memest(New,0x80,sizeof(New)) //设置New为<strong>-2139062144</strong></p>
<h3 id="double"><a href="#double" class="headerlink" title="double"></a>double</h3><p><strong>最大值</strong>：memset(New,0x7F,sizeof(New)) //全部赋值为<strong>1.38242e+306</strong></p>
<p><strong>最小值</strong>：memset(New,0xFE,sizeof(New)) //全部赋值为<strong>-5.31401e+303</strong></p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>几何反演</title>
    <url>/articles/%E5%87%A0%E4%BD%95%E5%8F%8D%E6%BC%94/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="几何反演"><a href="#几何反演" class="headerlink" title="几何反演"></a>几何反演</h1><p>吐槽一句：<strong>几何反演</strong>比<strong>莫比乌斯反演</strong>简单多了，只是比较<strong>巧妙</strong>，一般会想不到。。。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>反演变换适用于题目中存在多个<strong>圆/直线</strong>之间的<strong>相切关系</strong>的情况。利用反演变换的性质，在反演空间求解问题，可以大幅<strong>简化计算</strong>。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定<strong>反演中心</strong>$O$和<strong>反演半径</strong>$R$</p>
<p>若平面上$P$和$P^{‘}$满足：</p>
<ul>
<li><p>点$P^{‘}$在<strong>射线</strong>$ \vec{OP} $上</p>
</li>
<li><p>$ |OP| \cdot |OP^{‘}|=R^2 $    </p>
</li>
</ul>
<p>那么称点$P$和点$P^{‘}$互为<strong>反演点</strong></p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/08/13/mlxR6uPQkOBjCgf.png" alt="几何反演-1.png"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p><strong>温馨提示</strong>:为了方便您的阅读,以下内容我们规定:</p>
<p>$\color{red}红色$代表<strong>原图形</strong></p>
<p>$ \color{orange}橙色$代表<strong>反演图形</strong></p>
<p>$ \color{blue}蓝色$代表<strong>反演中心以及反演半径所组成的圆</strong></p>
<p><em>　在<strong>圆上</strong>的点反演点为<em>*自身</em></em>(<del>颜色不好标…问题不大</del>)</p>
<p><img src="https://i.loli.net/2020/08/13/Cyk2QnKVrLZO5MS.png" alt="几何反演-2.png"></p>
<p><em>　<strong>圆$O$外</strong>的点的反演点在<strong>圆内</strong>，<em>*反之亦然</em></em> </p>
<p><img src="https://i.loli.net/2020/08/13/9WTNOsxf4kIdSn2.png" alt="几何反演-3.png"></p>
<ul>
<li><strong>过点$O$</strong>的圆$A$,<strong>反演图形</strong>为过其<strong>交点</strong>的<strong>不过$O$</strong>的<strong>直线</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/08/13/NaienwoscM81xyC.png" alt="几何反演-4.png"></p>
<p><em>　两个图形<strong>相切</strong>，那么他们的<strong>反演图形</strong>也<em>*相切</em></em></p>
<p><img src="https://i.loli.net/2020/08/13/UijqXEP15Y47Rwk.png" alt="几何反演-5.png"></p>
<p><img src="https://i.loli.net/2020/08/13/5EvMpfJUzOnlcqS.png" alt="几何反演-6.png"></p>
<p><img src="https://i.loli.net/2020/08/13/kTQpE3qIvsHcBAZ.png" alt="几何反演-7.png"></p>
<h2 id="二级结论"><a href="#二级结论" class="headerlink" title="二级结论"></a>二级结论</h2><ul>
<li>记圆$A$半径为$r_1$,其反演图形圆$B$半径为$r_2$,则有:</li>
</ul>
<script type="math/tex; mode=display">
r_2= \frac{1}{2} \left( \frac{1}{|OA|-r_1}- \frac{1}{|OA|+r_1} \right)  R_2 \\
\Rightarrow r_2= \frac{r_1}{|OA|^2-r^2_1}R^2</script><p>当然证明的话…真的就是有手就行(<del>口胡</del>)</p>
<p>*　记$O$坐标为$(x_0,y_0)$,点$A$坐标为$ (x_1,y_1 )$,点$B$坐标为$ (x_2,y_2) $,则有:</p>
<script type="math/tex; mode=display">
x_2=x_0+ \frac{|OB|}{|OA|} (x_1-x_0)\\
y_2=y_0+ \frac{|OB|}{|OA|} (y_1-y_0)</script>]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>复数基操</title>
    <url>/articles/%E5%A4%8D%E6%95%B0%E5%9F%BA%E6%93%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复数基操"><a href="#复数基操" class="headerlink" title="复数基操"></a>复数基操</h1><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>我们在解<strong>多次方程</strong>时，总会遇到类似$ x^2+1=0 $的情况，我们会说这个方程<strong>没有实数解</strong>，那么，既然只是没有实数解，有的是什么解呢。。。</p>
<p>这个时候我们可以强行给他来一个解—$i$，那么这个方程就有一个解$x=i$了</p>
<p>但光有这个解没有什么用，所以我们需要给他找<strong>一些性质和是加一些运算</strong></p>
<p>类似于实数的表示方式，我们可以将这种形式的数表示为$ a+bi $，当然$a$和$b$都是<strong>实数</strong>，那么他是否满足运算性质呢？</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>因为我们将复数定义的<strong>代数形式</strong>为$ a+bi\,\,\,a,b \in \real $，其中$i$为虚数单位，<strong>全体复数</strong>的集合为<strong>复数集</strong>，其中$a$为复数$z$的<strong>实部</strong>，$b$为$z$的<strong>虚部</strong></p>
<p>我们发现，当$b=0$时，$ z \in \real $，当$b \neq 0$时，$ z \notin \real $</p>
<p>那么我们可以发一张图来表示<strong>所有数的关系</strong></p>
<p><img src="https://i.loli.net/2020/08/14/weq5AgtzWcysBDi.png" alt="复数基操-1.png"></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><strong>几何意义</strong>：实数与$x$轴上的点一一对应，复数与<strong>坐标系</strong>上的点一一对应，比如：$ z=a+bi $表示为$ (a,b) $</li>
<li><strong>复数相等</strong>：对于$z_1=a_1+b_1i,z_2=a_2+b_2i<strong>$当且仅当</strong>$ a_1=a_2,b_1=b_2 $</li>
<li><p><strong>几何意义</strong>：复数集与复平面内的<strong>向量集合</strong>一一对应(实数<strong>0与零向量</strong>对应)，$ z=a+bi \Leftrightarrow (a,b) \Leftrightarrow \vec{OZ}  $</p>
</li>
<li><p><strong>复数的模</strong>：对于复数$ z=a+bi $的<strong>模</strong>$ |z|= \sqrt{a^2+b^2} $</p>
</li>
</ul>
<h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><h3 id="加法和减法"><a href="#加法和减法" class="headerlink" title="加法和减法"></a>加法和减法</h3><p>很明显对于$ z_1=a_1+b_1i,z_2=a_2+b_2i $满足$ z_1+z_2=a_1+a_2+(b_1+b_2)i $同样可以验证出满足<strong>加法和减法的交换律和结合律</strong></p>
<script type="math/tex; mode=display">
z_1+z_2=z_2+z_1 \\
(z_1+z_2)+z_3=z_1+(z_2+z_3)</script><h4 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h4><p>和<strong>向量</strong>一样</p>
<p><img src="https://i.loli.net/2020/08/14/aiuIlQA6XchZWUS.png" alt="复数基操-2.png"></p>
<h3 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h3><p>首先由常识可以知道满足<strong>交换律，结合律以及分配律</strong>，且由于其和实数的表示有关，复数域也满足所有<strong>乘法公式</strong></p>
<script type="math/tex; mode=display">
z_1z_2=z_2z_1 \\
(z_1z_2)z_3=z_1(z_2z_3) \\
z_1(z_2+z_3)=z_1z_2+z_1z_3</script><h4 id="几何意义-1"><a href="#几何意义-1" class="headerlink" title="几何意义"></a>几何意义</h4><p>两个复数<strong>相乘</strong>，在复平面上表示为两个向量<strong>模长相乘</strong>，<strong>辐角相加</strong></p>
<p><img src="https://i.loli.net/2020/08/14/r9Zzhgp1mijykJe.png" alt="复数基操-3.png"></p>
<h3 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h3><p>乘法和除法可以<strong>互相转化</strong>，对于$ z_1=a_1+b_1i,z_2=a_2+b_2i $</p>
<script type="math/tex; mode=display">
\frac{a_1+b_1i}{a_1+b_2i}= \frac{(a_1+b_1i)(a_2-b_2i)}{(a_2+b_2i)(a_2-b_2i)}= \frac{a_1a_2+b_1b_2}{a_2^2+b_2^2}+ \frac{b_1a_2-a_1b_2}{a_2^2+b_2^2}(a_2+b_2i \neq 0)</script><h3 id="共轭"><a href="#共轭" class="headerlink" title="共轭"></a>共轭</h3><p>我们定义，当两个虚数<strong>实部相等</strong>，<strong>虚部互为相反数</strong>时，这两个复数互为<strong>共轭复数</strong> 。通常记$ z=a+bi $的共轭复数为$ \bar{z}=a-bi $。我们可以发现，两个复数<strong>互为共轭复数</strong>，那么它们 关于<strong>实轴对称</strong>,如图$z_1$和$z_2$互为共轭</p>
<h4 id="几何意义-2"><a href="#几何意义-2" class="headerlink" title="几何意义"></a>几何意义</h4><p><img src="https://i.loli.net/2020/08/14/BTWUp3gPy4Svti2.png" alt="复数基操-4.png"></p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>吉司机线段树</title>
    <url>/articles/%E5%90%89%E5%8F%B8%E6%9C%BA%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="吉司机线段树"><a href="#吉司机线段树" class="headerlink" title="吉司机线段树"></a>吉司机线段树</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>吉老师niubility！！！</strong></p>
<p>关于<strong>吉司机线段树</strong>是吉老师在<strong>2016年国家集训队论文</strong>中提到的一种处理方式—<strong>区间最值操作 &amp; 历史区间最值</strong></p>
<h2 id="区间最值操作"><a href="#区间最值操作" class="headerlink" title="区间最值操作"></a>区间最值操作</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>将$ [l,r] $的数全部对$x$取<strong>max或min</strong>，即$a_i=max(a_i,x)$或者$ a_i=min(a_i,x) $</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们以区间取min为一个示例</p>
<p>区间取min以为着大于$t$的数需要被更改，因此这个操作不是整个区间，而是区间中<strong>大于$t$的数</strong></p>
<p>于是，我们可以维护<strong>区间最大值</strong>$Max$，<strong>次大值</strong>$Sec$，<strong>区间和</strong>$Sum$以及<strong>最大值的个数</strong>$Cnt$</p>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol>
<li>如果$ Max \leq t $，显然这个$t$是没有意义的，<strong>直接返回</strong>；</li>
<li>如果$ Sec &lt; t \leq Max $ ，那么这个$t$就能更新当前<strong>区间中的最大值</strong>。于是我们让区间和加上$ Cnt(t-Max) $，然后更新$Max$为$t$ ，并打一个标记。</li>
<li>如果$ t \leq Sec $，那么这时你发现你不知道有多少个数涉及到更新的问题。于是我们的策略就是，<strong>暴力递归</strong>向下操作。然后上传信息。</li>
</ol>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>使用<strong>势能分析</strong>可以得到复杂度为$ O(mlogn) $</p>
<p>我也不知道咋整，具体分析过程见<strong>论文</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=5306" target="_blank" rel="noopener">HDU5306 Gorgeous Sequence</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HDU 5306</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Max[MAXN&lt;&lt;<span class="number">2</span>],Sum[MAXN&lt;&lt;<span class="number">2</span>],Tag[MAXN&lt;&lt;<span class="number">2</span>],Sec[MAXN&lt;&lt;<span class="number">2</span>],Cnt[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">LL Test,Total,<span class="built_in">Task</span>,Opt,u,v,w;</span><br><span class="line">LL Num[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Sum[X]=Sum[Lson]+Sum[Rson];</span><br><span class="line">    <span class="keyword">if</span>(Max[Lson]==Max[Rson]) &#123;</span><br><span class="line">        Max[X]=Max[Lson];</span><br><span class="line">        Cnt[X]=Cnt[Lson]+Cnt[Rson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Lson],Sec[Rson]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Max[Lson]&gt;Max[Rson]) &#123;</span><br><span class="line">        Max[X]=Max[Lson];</span><br><span class="line">        Cnt[X]=Cnt[Lson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Lson],Max[Rson]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Max[X]=Max[Rson];</span><br><span class="line">        Cnt[X]=Cnt[Rson];</span><br><span class="line">        Sec[X]=<span class="built_in">max</span>(Sec[Rson],Max[Lson]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Tag[X]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123; </span><br><span class="line">        Max[X]=Sum[X]=Num[L]; </span><br><span class="line">        Cnt[X]=<span class="number">1</span>; Sec[X]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tag[X]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Max[Lson]&gt;Tag[X]) &#123; Tag[Lson]=Tag[X]; Sum[Lson]-=Cnt[Lson]*(Max[Lson]-Tag[X]); Max[Lson]=Tag[X]; &#125;</span><br><span class="line">        <span class="keyword">if</span>(Max[Rson]&gt;Tag[X]) &#123; Tag[Rson]=Tag[X]; Sum[Rson]-=Cnt[Rson]*(Max[Rson]-Tag[X]); Max[Rson]=Tag[X]; &#125;</span><br><span class="line">        Tag[X]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Max[X]&lt;=Temp) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To &amp;&amp; Sec[X]&lt;Temp) &#123;</span><br><span class="line">        Tag[X]=Temp; </span><br><span class="line">        Sum[X]-=Cnt[X]*(Max[X]-Temp);</span><br><span class="line">        Max[X]=Temp;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Update(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Update(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_MAX</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Max[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_SUM</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Sum[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">    Push_down(X,L,R);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res+=Get_SUM(Lson,L,Mid,From,To); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res+=Get_SUM(Rson,Mid+<span class="number">1</span>,R,From,To); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;<span class="built_in">Task</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">Task</span>--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Test);</span><br><span class="line">        FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]); &#125;</span><br><span class="line">        Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">        <span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Opt,&amp;u,&amp;v);</span><br><span class="line">            <span class="keyword">if</span>(Opt==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;w);</span><br><span class="line">                Update(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_MAX(<span class="number">1</span>,<span class="number">1</span>,Total,u,v));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_SUM(<span class="number">1</span>,<span class="number">1</span>,Total,u,v));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">  <span class="comment">//  system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="历史最值问题"><a href="#历史最值问题" class="headerlink" title="历史最值问题"></a>历史最值问题</h2><h3 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h3><p>历史最值<strong>不等于可持久化</strong></p>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><p>我们这次以最大值max来举例</p>
<p>简单地说，一个位置的历史最大值就是当前位置下<strong>曾经出现过的数的最大值</strong>。形式化地定义，我们定义一个辅助数组$B$，一开始与$A$完全相同。在$A$的每次操作后，我们对整个数组取max：</p>
<script type="math/tex; mode=display">
\forall i \in [1,n],B_i=max(B_i,A_i)</script><p>这时我们将$B_i$称为这个位置的<strong>历史最大值</strong></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><a href="https://www.luogu.com.cn/problem/P4314" target="_blank" rel="noopener">P4314 CPU监控</a></p>
<p>可能会想，不就是一个历史最大值吗，直接每次Tag标记加上去的时候取一个max就可以了，然而并不是这样的，有一个问题需要一些技巧</p>
<p>若果你像我上边所说的做了，并且实现了代码，这儿有一个<strong>Hack数据</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">10</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">P <span class="number">1</span> <span class="number">8</span> <span class="number">100</span></span><br><span class="line">P <span class="number">1</span> <span class="number">8</span> <span class="number">-10</span></span><br><span class="line">A <span class="number">3</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>显然答案是110，而你会输出100，这是因为标记在减小之前没有取一个最大值，所以会错</p>
<p>所以，我们还需要给每一个节点记录<strong>历史最大Tag标记</strong></p>
<p>同理，还要记录<strong>历史最大覆盖标记</strong></p>
<p>所以重要的就是如何<strong>push_down</strong></p>
<h3 id="重点分析"><a href="#重点分析" class="headerlink" title="重点分析"></a>重点分析</h3><p>pushdown的时候重点是要<strong>分类讨论</strong>：之前是否被覆盖过，即由 Cov 标记决定</p>
<p>先讲覆盖的时候：（要传 d 和 hd ,表示用于更新的当前覆盖值和用于更新的历史覆盖最大值）</p>
<ul>
<li>如果Cov为<strong>true</strong>：用Hd更新Hcov，取max</li>
<li>如果Cov为<strong>false</strong>：Cov变为true，Hcov变为hd</li>
</ul>
<p>此外还要更新<strong>历史最大值Hmx</strong>，(和Hd取max)</p>
<p>加法的时候更复杂一些：d 和 Hd 的含义同理</p>
<ul>
<li>如果Cov为<strong>true</strong>：说明之前被覆盖过了，此时相当于用d+Cov进行Cover即可</li>
<li>如果Cov为<strong>false</strong>：此时只有加法，用Max+Hd和add+Hd<strong>分别更新</strong>Hmx和Had,并更新Max和add标记 (把Max和add加上d)</li>
</ul>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Tag1[MAXN&lt;&lt;<span class="number">2</span>],Tag2[MAXN&lt;&lt;<span class="number">2</span>],Max[MAXN&lt;&lt;<span class="number">2</span>],Pre[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">LL Total,Test,u,v,w,Num[MAXN];</span><br><span class="line"><span class="keyword">char</span> Opt;</span><br><span class="line">LL HTag1[MAXN&lt;&lt;<span class="number">2</span>],HTag2[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL Temp=<span class="number">0</span>,Fac=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> Ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(Ch&lt;<span class="string">'0'</span> || Ch&gt;<span class="string">'9'</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span>(Ch==<span class="string">'-'</span>) &#123; Fac=<span class="number">-1</span>; &#125; </span><br><span class="line">		Ch=getchar(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">while</span>(Ch&gt;=<span class="string">'0'</span> &amp;&amp; Ch&lt;=<span class="string">'9'</span>) &#123; </span><br><span class="line">		Temp=(Temp&lt;&lt;<span class="number">1</span>)+(Temp&lt;&lt;<span class="number">3</span>)+Ch-<span class="string">'0'</span>; </span><br><span class="line">		Ch=getchar(); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> Fac*Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    Max[X]=<span class="built_in">max</span>(Max[Lson],Max[Rson]);</span><br><span class="line">    Pre[X]=<span class="built_in">max</span>(Pre[Lson],Pre[Rson]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">chg</span><span class="params">(LL X,LL v,LL hv)</span> </span>&#123;</span><br><span class="line">	Max[X]=v;</span><br><span class="line">	Pre[X]=<span class="built_in">max</span>(Pre[X],hv);</span><br><span class="line">	Tag2[X]=v;</span><br><span class="line">	HTag2[X]=<span class="built_in">max</span>(HTag2[X],hv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LL X,LL v,LL hv)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Tag2[X]!=INF) <span class="keyword">return</span> chg(X,Tag2[X]+v,Tag2[X]+hv);</span><br><span class="line">	HTag1[X]=<span class="built_in">max</span>(HTag1[X],hv+Tag1[X]);</span><br><span class="line">	Tag1[X]+=v;</span><br><span class="line">	Max[X]+=v;</span><br><span class="line">	Pre[X]=<span class="built_in">max</span>(Pre[X],Max[X]-Tag1[X]+HTag1[X]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X)</span></span>&#123;</span><br><span class="line">	add(Lson,Tag1[X],HTag1[X]);</span><br><span class="line">	add(Rson,Tag1[X],HTag1[X]);</span><br><span class="line">	Tag1[X]=HTag1[X]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Tag2[X]!=INF)&#123;</span><br><span class="line">		chg(Lson,Tag2[X],HTag2[X]);</span><br><span class="line">		chg(Rson,Tag2[X],HTag2[X]);</span><br><span class="line">		Tag2[X]=INF;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	Tag2[X]=INF;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123;</span><br><span class="line">        Pre[X]=Max[X]=Num[L];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">    	<span class="keyword">if</span>(Tag2[X]!=INF) &#123;</span><br><span class="line">    		Max[X]=Tag2[X]+Temp;</span><br><span class="line">			Pre[X]=<span class="built_in">max</span>(Pre[X],<span class="built_in">max</span>(Tag2[X]+Temp,Tag2[X]));</span><br><span class="line">			Tag2[X]+=Temp;</span><br><span class="line">			HTag2[X]=<span class="built_in">max</span>(HTag2[X],<span class="built_in">max</span>(Tag2[X],Tag2[X]+Temp));</span><br><span class="line">    		<span class="keyword">return</span>;	</span><br><span class="line">    	&#125;</span><br><span class="line">    	HTag1[X]=<span class="built_in">max</span>(HTag1[X],<span class="built_in">max</span>(Tag1[X],Tag1[X]+Temp));</span><br><span class="line">    	Tag1[X]+=Temp;</span><br><span class="line">    	Max[X]+=Temp;</span><br><span class="line">    	Pre[X]=<span class="built_in">max</span>(Pre[X],Max[X]-Tag1[X]+HTag1[X]);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Add(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Add(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">        Max[X]=Temp;</span><br><span class="line">        Pre[X]=<span class="built_in">max</span>(Pre[X],Temp);</span><br><span class="line">        Tag2[X]=Temp;</span><br><span class="line">        HTag2[X]=<span class="built_in">max</span>(HTag2[X],Temp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Change(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Change(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_MAX</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp;  R&lt;=To) &#123; <span class="keyword">return</span> Max[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=-INF;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_MAX(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get_PRE</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line"><span class="comment">//	cout&lt;&lt;"X:"&lt;&lt;X&lt;&lt;" "&lt;&lt;"L:"&lt;&lt;L&lt;&lt;" "&lt;&lt;"R:"&lt;&lt;R&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Tag1:"&lt;&lt;Tag1[X]&lt;&lt;" "&lt;&lt;"Tag2:"&lt;&lt;Tag2[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;"Max:"&lt;&lt;Max[X]&lt;&lt;" "&lt;&lt;"Pre:"&lt;&lt;Pre[X]&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//	cout&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Pre[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=-INF;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_PRE(Lson,L,Mid,From,To)); &#125;</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) &#123; Res=<span class="built_in">max</span>(Res,Get_PRE(Rson,Mid+<span class="number">1</span>,R,From,To)); &#125;</span><br><span class="line">    Push_up(X,L,R);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Debug</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"X:"</span>&lt;&lt;X&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"L:"</span>&lt;&lt;L&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"R:"</span>&lt;&lt;R&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Tag1:"</span>&lt;&lt;Tag1[X]&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"Tag2:"</span>&lt;&lt;Tag2[X]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Max:"</span>&lt;&lt;Max[X]&lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="string">"Pre:"</span>&lt;&lt;Pre[X]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">if</span>(L==R) <span class="keyword">return</span>;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Debug(Lson,L,Mid); Debug(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    Total=Read();</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; Num[i]=Read(); &#125;</span><br><span class="line">    Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">    Test=Read();</span><br><span class="line">    <span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		Opt=getchar();</span><br><span class="line">        u=Read(); v=Read();</span><br><span class="line"><span class="comment">//    	printf("%c %lld %lld\n",Opt,u,v);</span></span><br><span class="line">        <span class="keyword">if</span>(Opt==<span class="string">'Q'</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_MAX(<span class="number">1</span>,<span class="number">1</span>,Total,u,v)); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'A'</span>) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Get_PRE(<span class="number">1</span>,<span class="number">1</span>,Total,u,v)); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'P'</span>) &#123; w=Read(); Add(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w); &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Opt==<span class="string">'C'</span>) &#123; w=Read(); Change(<span class="number">1</span>,<span class="number">1</span>,Total,u,v,w); &#125;</span><br><span class="line"><span class="comment">//        Debug(1,1,Total);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>复杂度分析</title>
    <url>/articles/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h1><h2 id="主定理"><a href="#主定理" class="headerlink" title="主定理"></a>主定理</h2><script type="math/tex; mode=display">
T(n)= \begin{cases} \Theta(n^{log_b a}) & f(n)=O(n^{log_b a- \epsilon}) \\
\Theta(f(n)) & f(n)= \Omega(n^{log_b a+ \epsilon}) \\
\Theta(n^{log_b a}log^{k+1} n) & f(n)= \Theta(n^{log_b a}log^k n),k \geq 0 \end{cases}</script><h2 id="势能分析"><a href="#势能分析" class="headerlink" title="势能分析"></a>势能分析</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>势能分析</strong>，是一种求<strong>均摊复杂度下界</strong>的方法。 求均摊复杂度，关键是表达出<strong>先前操作</strong>对<strong>当前操作</strong>的影响。势能分析用一个<strong>函数</strong>来表达此种影响。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>定义“状态”$S$：即<strong>某一时刻</strong>的<strong>所有数据</strong>。在快排的例子中，一个“状态”就是当前过程需要排序的下标区间</p>
<p>定义“初始状态”$S_0$：即<strong>未进行任何操作</strong>时的状态。在快排的例子中，“初始状态”就是整个数组</p>
<p>假设存在<strong>从状态到数</strong>的函数$F$，且对于<strong>任何状态</strong>$S$，$F(S) \geq F(S_0)$ ，则有以下推论：</p>
<p>设$ S_1,S_2, \cdots ,S_m $为从$S_0$开始连续做$m$次操作所得的状态序列，$c_i$为第$i$次操作的时间开销。</p>
<p>记$ p<em>i=c_i+F(S_i)-F(S</em>{i-1}) $，则$m$次操作的<strong>总时间花销</strong>为</p>
<script type="math/tex; mode=display">
\sum^m_{i=1}p_i+F(S_0)-F(S_m)</script><p>又因为$ F(S) \geq F(S_0) $，所以有</p>
<script type="math/tex; mode=display">
\sum^m_{i=1}p_i \geq \sum^m_{i=1}c_i</script><p>因此，若$ p_i=O(T(n)) $，则$ O(T(n)) $时<strong>均摊复杂度的一个上界</strong></p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>字符及字符串的处理</title>
    <url>/articles/%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字符及字符串的处理"><a href="#字符及字符串的处理" class="headerlink" title="字符及字符串的处理"></a>字符及字符串的处理</h1><h3 id="By-DeNeRATe—2020-08-04"><a href="#By-DeNeRATe—2020-08-04" class="headerlink" title="By DeNeRATe—2020.08.04"></a>By DeNeRATe—2020.08.04</h3><h3 id="前言简介"><a href="#前言简介" class="headerlink" title="前言简介"></a>前言简介</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>字符串</strong>，就是由<strong>字符</strong>连接而成的<strong>序列</strong>。  </p>
<h4 id="程序定义"><a href="#程序定义" class="headerlink" title="程序定义"></a>程序定义</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<h4 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h4><p>‘a’ 和 “a”的区别（对于字符单引号和双引号的区别）</p>
<p>单引号’a’表示单个字符，在其中必须且只能有一个字符。<br>双引号”a”表示字符串，字符串是由若干个字符组成的。<br>字符是组成字符串的元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">"DC is extremely niubility"</span><span class="comment">//这个双引号之间的就是一个字符串，以一个整体</span></span><br><span class="line"><span class="string">'W'</span><span class="comment">//单引号之间的就只是一个字符，不可包含多个字符</span></span><br></pre></td></tr></table></figure>
<h4 id="常见的字符串问题"><a href="#常见的字符串问题" class="headerlink" title="常见的字符串问题"></a>常见的字符串问题</h4><h5 id="1-字符串匹配问题"><a href="#1-字符串匹配问题" class="headerlink" title="1.字符串匹配问题"></a>1.字符串匹配问题</h5><h5 id="2-子串相关问题"><a href="#2-子串相关问题" class="headerlink" title="2.子串相关问题"></a>2.子串相关问题</h5><h5 id="3-前缀-后缀相关问题"><a href="#3-前缀-后缀相关问题" class="headerlink" title="3.前缀/后缀相关问题"></a>3.前缀/后缀相关问题</h5><h5 id="4-回文串相关问题"><a href="#4-回文串相关问题" class="headerlink" title="4.回文串相关问题"></a>4.回文串相关问题</h5><h5 id="5-子序列相关问题"><a href="#5-子序列相关问题" class="headerlink" title="5.子序列相关问题"></a>5.子序列相关问题</h5><h5 id="6-ELSE"><a href="#6-ELSE" class="headerlink" title="6.ELSE"></a>6.ELSE</h5><h3 id="关于字符—ASCLL码"><a href="#关于字符—ASCLL码" class="headerlink" title="关于字符—ASCLL码"></a>关于字符—ASCLL码</h3><blockquote>
<p>ASCII ((American Standard Code for Information Interchange): 美国信息交换标准代码）是基于<a href="https://baike.baidu.com/item/拉丁字母/1936851" target="_blank" rel="noopener">拉丁字母</a>的一套电脑<a href="https://baike.baidu.com/item/编码/80092" target="_blank" rel="noopener">编码</a>系统，主要用于显示现代<a href="https://baike.baidu.com/item/英语/109997" target="_blank" rel="noopener">英语</a>和其他<a href="https://baike.baidu.com/item/西欧/3028649" target="_blank" rel="noopener">西欧</a>语言。它是最通用的信息交换标准，并等同于<a href="https://baike.baidu.com/item/国际" target="_blank" rel="noopener">国际</a>标准ISO/IEC 646。ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符</p>
<p>ASCII 码使用指定的7 位或8 位<a href="https://baike.baidu.com/item/二进制数" target="_blank" rel="noopener">二进制数</a>组合来表示128 或256 种可能的<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>。标准ASCII 码也叫基础ASCII码，使用7 位<a href="https://baike.baidu.com/item/二进制数" target="_blank" rel="noopener">二进制数</a>（剩下的1位二进制为0）来表示所有的大写和小写字母，数字0 到9、标点符号，以及在美式英语中使用的特殊<a href="https://baike.baidu.com/item/控制字符" target="_blank" rel="noopener">控制字符</a>  。其中：</p>
<p><strong>0～31及127(共33个)是<a href="https://baike.baidu.com/item/控制字符" target="_blank" rel="noopener">控制字符</a>或通信专用字符（其余为可显示字符），</strong>如控制符：LF（换行）、CR（<a href="https://baike.baidu.com/item/回车" target="_blank" rel="noopener">回车</a>）、FF（换页）、DEL（<a href="https://baike.baidu.com/item/删除/13020275" target="_blank" rel="noopener">删除</a>）、BS（退格)、BEL（响铃）等；通信专用字符：SOH（文头）、EOT（文尾）、ACK（确认）等；ASCII值为8、9、10 和13 分别转换为<a href="https://baike.baidu.com/item/退格" target="_blank" rel="noopener">退格</a>、制表、换行和回车字符。它们并没有特定的图形显示，但会依不同的应用程序，而对<a href="https://baike.baidu.com/item/文本" target="_blank" rel="noopener">文本</a>显示有不同的影响 。</p>
<p>32～126(共95个)是<a href="https://baike.baidu.com/item/字符" target="_blank" rel="noopener">字符</a>(32是空格），其中48～57为0到9十个阿拉伯数字。</p>
<p>65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<p>同时还要注意，在标准ASCII中，其最高位(b7)用作<a href="https://baike.baidu.com/item/奇偶校验位" target="_blank" rel="noopener">奇偶校验位</a>。所谓奇偶校验，是指在代码传送过程中用来检验是否出现错误的一种方法，一般分<a href="https://baike.baidu.com/item/奇校验" target="_blank" rel="noopener">奇校验</a>和偶校验两种。<a href="https://baike.baidu.com/item/奇校验" target="_blank" rel="noopener">奇校验</a>规定：正确的代码一个<a href="https://baike.baidu.com/item/字节" target="_blank" rel="noopener">字节</a>中1的个数必须是奇数，若非奇数，则在最高位b7添1；偶校验规定：正确的代码一个字节中1的个数必须是<a href="https://baike.baidu.com/item/偶数" target="_blank" rel="noopener">偶数</a>，若非偶数，则在最高位b7添1 。</p>
<p>后128个称为<a href="https://baike.baidu.com/item/扩展ASCII" target="_blank" rel="noopener">扩展ASCII</a>码。许多基于<a href="https://baike.baidu.com/item/x86" target="_blank" rel="noopener">x86</a>的系统都支持使用扩展（或“高”）ASCII。扩展ASCII 码允许将每个字符的第8 位用于确定附加的128 个特殊符号字符、外来语字母和图形符号</p>
</blockquote>
<h4 id="如何打印ASCLL码"><a href="#如何打印ASCLL码" class="headerlink" title="如何打印ASCLL码"></a>如何打印ASCLL码</h4><h4 id="1-gt-直接查表-HERE-I-AM"><a href="#1-gt-直接查表-HERE-I-AM" class="headerlink" title="1&gt; 直接查表 HERE I AM"></a>1&gt; 直接查表 <a href="http://ascii.911cha.com/" target="_blank" rel="noopener">HERE I AM</a></h4><h4 id="2-gt-使用强制转换将int型转换为char型"><a href="#2-gt-使用强制转换将int型转换为char型" class="headerlink" title="2&gt; 使用强制转换将int型转换为char型"></a>2&gt; 使用强制转换将int型转换为char型</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">128</span>;i++) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d的ASCLL码为:%c\n"</span>,(<span class="keyword">char</span>)i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输入输出问题"><a href="#输入输出问题" class="headerlink" title="输入输出问题"></a>输入输出问题</h3><h4 id="1-流输入输出—cin-cout"><a href="#1-流输入输出—cin-cout" class="headerlink" title="1.流输入输出—cin,cout"></a>1.流输入输出—cin,cout</h4><p>cin会从流中取数据，<strong>遇到空格或者换行符都会停止所以不适合读数据串</strong>。一般用来取单个变量的数据。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;//所需头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;<span class="comment">//空格或换行停止一个字符的输入</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="string">"b"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="1-gt-输入1"><a href="#1-gt-输入1" class="headerlink" title="1&gt;输入1"></a>1&gt;输入1</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">3</span>(回车)</span><br></pre></td></tr></table></figure>
<p>第一种输入会把换行符之前，即“<strong>2+空格+3+\n</strong>”的数据都存入缓冲区。程序执行到cin&gt;&gt;a，去缓冲区取数据，碰到空格停止，所以就取走了一个2赋给了a，然后继续执行cin&gt;&gt;b，此时<strong>缓冲区如果还残留数据，程序会从缓冲区取数据而不是要求用户输入</strong>，所以重复相同的步骤取走了剩余的3。最后，<strong>留下一个换行符在缓冲区内</strong>。</p>
<h5 id="2-gt-输入2"><a href="#2-gt-输入2" class="headerlink" title="2&gt;输入2"></a>2&gt;输入2</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>(回车)</span><br><span class="line"><span class="number">3</span>(回车)</span><br></pre></td></tr></table></figure>
<p>此类即可类比推理</p>
<h4 id="2-getchar-putchar的输入输出"><a href="#2-getchar-putchar的输入输出" class="headerlink" title="2.getchar,putchar的输入输出"></a>2.getchar,putchar的输入输出</h4><p>getchar()与putchar(）<strong>不会忽略任何一个字符</strong>，包括换行 ，tab，enter在内。</p>
<p>这就使得我们在写程序时，可以使用这一性质，比如：快读，快写等常规操作</p>
<p>若我输入：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">abcd efgh</span><br></pre></td></tr></table></figure>
<p>则：</p>
<p>我们分别接收到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">' '</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span>,<span class="string">'h'</span></span><br></pre></td></tr></table></figure>
<h4 id="3-scanf-printf格式化输入输出"><a href="#3-scanf-printf格式化输入输出" class="headerlink" title="3.scanf,printf格式化输入输出"></a>3.scanf,printf格式化输入输出</h4><p>一般会用到的：”%\c”,”%\s”此两种方式</p>
<h5 id="1-gt-”-c”"><a href="#1-gt-”-c”" class="headerlink" title="1&gt;”%\c”"></a>1&gt;”%\c”</h5><p>类似于getchar()，不会跳过任何一个字符，包括空格，tab，‘\n’等。<strong>但是，要注意：空格的作用。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a,b,c;</span><br><span class="line">    <span class="comment">//a = getchar();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">" %c %c %c"</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %c %c"</span>, a,b,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-”-s”"><a href="#2-gt-”-s”" class="headerlink" title="2&gt;”%\s”"></a>2&gt;”%\s”</h5><p>相对于%c，%s简单许多:</p>
<p>scanf()以<strong>非空白符</strong>开始，<strong>空白符</strong>结束，完成一个%s的录入;<br>printf()从<strong>当前位置</strong>打印到‘\0’结束</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;cstring&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-ELSE"><a href="#4-ELSE" class="headerlink" title="4.ELSE"></a>4.ELSE</h4><p>当然，对于字符以及字符串的输入输出方式还有很多，比如：</p>
<h5 id="1-gt-使用string类型的getline输入"><a href="#1-gt-使用string类型的getline输入" class="headerlink" title="1&gt;使用string类型的getline输入"></a>1&gt;使用string类型的getline输入</h5><p>(虽然一般不用，但它的骚操作真的非灰常优秀)</p>
<h5 id="2-gt-gets-和puts-输入输出"><a href="#2-gt-gets-和puts-输入输出" class="headerlink" title="2&gt;gets()和puts()输入输出"></a>2&gt;gets()和puts()输入输出</h5><h5 id="3-gt-意念输入输出（纯属口胡QwQ）"><a href="#3-gt-意念输入输出（纯属口胡QwQ）" class="headerlink" title="3&gt;意念输入输出（纯属口胡QwQ）"></a>3&gt;<del>意念输入输出（纯属口胡QwQ）</del></h5><p>但我们做题的时候能用到的，基本就是这些了。</p>
<h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><h4 id="1-P1307-数字反转"><a href="#1-P1307-数字反转" class="headerlink" title="1.P1307 数字反转"></a>1.<a href="https://www.luogu.com.cn/problem/P1307" target="_blank" rel="noopener">P1307 数字反转</a></h4><h4 id="2-P5660-数字游戏"><a href="#2-P5660-数字游戏" class="headerlink" title="2.P5660 数字游戏"></a>2.<a href="https://www.luogu.com.cn/problem/P5660" target="_blank" rel="noopener">P5660 数字游戏</a></h4><h4 id="3-输入一幅-n-times-m-的矩阵"><a href="#3-输入一幅-n-times-m-的矩阵" class="headerlink" title="3.输入一幅$ n \times m $的矩阵"></a>3.输入一幅$ n \times m $的矩阵</h4><p><strong>Input Sample </strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">8</span></span><br><span class="line">...###..</span><br><span class="line">####....</span><br><span class="line">#..##..#</span><br><span class="line">.##.#..#</span><br></pre></td></tr></table></figure>
<h3 id="程序的调试"><a href="#程序的调试" class="headerlink" title="程序的调试"></a>程序的调试</h3><p>通常我们在做完一道题后，60%(意思就是很多时候，不要当真)</p>
<p>所以此时的我们，需要<strong>调试</strong>。</p>
<h4 id="1-调试的简介"><a href="#1-调试的简介" class="headerlink" title="1.调试的简介"></a>1.调试的简介</h4><blockquote>
<p>编好程序后，用各种手段进行查错和排错的过程。作为程序的正确性不仅仅表现在正常功能的完成上，更重要的是对意外情况的正确处理。从心理学的角度考虑，开发人员和调试人员不应该是同一个人。</p>
</blockquote>
<h4 id="2-调试的一般方法"><a href="#2-调试的一般方法" class="headerlink" title="2.调试的一般方法"></a>2.调试的一般方法</h4><h5 id="1-gt-信仰模拟法"><a href="#1-gt-信仰模拟法" class="headerlink" title="1&gt; 信仰模拟法"></a>1&gt; 信仰模拟法</h5><h5 id="2-gt-直接输出法"><a href="#2-gt-直接输出法" class="headerlink" title="2&gt; 直接输出法"></a>2&gt; 直接输出法</h5><h5 id="3-gt-Dev-C-C-自带调试"><a href="#3-gt-Dev-C-C-自带调试" class="headerlink" title="3&gt; Dev-C/C++自带调试"></a>3&gt; Dev-C/C++自带调试</h5><h4 id="3-Dev-C-C-功能介绍"><a href="#3-Dev-C-C-功能介绍" class="headerlink" title="3.Dev-C/C++功能介绍"></a>3.Dev-C/C++功能介绍</h4><h4 id="4-Dev-C-C-实战演示"><a href="#4-Dev-C-C-实战演示" class="headerlink" title="4.Dev-C/C++实战演示"></a>4.Dev-C/C++实战演示</h4><p>我们先来一份代码</p>
<h5 id="1-gt-法一：略"><a href="#1-gt-法一：略" class="headerlink" title="1&gt;法一：略"></a>1&gt;法一：略</h5><h5 id="2-gt-法二：P2178-NOI2015-品酒大会"><a href="#2-gt-法二：P2178-NOI2015-品酒大会" class="headerlink" title="2&gt;法二：P2178 [NOI2015]品酒大会"></a>2&gt;法二：<a href="https://www.luogu.com.cn/problem/P2178" target="_blank" rel="noopener">P2178 [NOI2015]品酒大会</a></h5><h5 id="3-gt-法三：P2503-HAOI2006-均分数据"><a href="#3-gt-法三：P2503-HAOI2006-均分数据" class="headerlink" title="3&gt;法三：P2503 [HAOI2006]均分数据"></a>3&gt;法三：<a href="https://www.luogu.com.cn/problem/P2503" target="_blank" rel="noopener">P2503 [HAOI2006]均分数据</a></h5><h3 id="字符串的定义扩展"><a href="#字符串的定义扩展" class="headerlink" title="字符串的定义扩展"></a>字符串的定义扩展</h3><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>一个 <strong>字符集</strong>$ \sum $是一个建立了全序关系的集合，也就是说,$ \sum $中的任意两个不同的元素$\alpha$和$\beta$都可以比较大小，要么$ \alpha &gt; \beta $，要么$ \alpha &lt; \beta $ 。字符集$ \sum $中的元素称为字符。</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>一个 <strong>字符串</strong>$S$是将$n$个字符顺次排列形成的序列，$n$称为$S$的长度，表示为$ |S| $ .$S$的第$i$个字符表示为$S[i]$。（在有的地方，也会用$S[i-1]$表示第$i$个字符。）</p>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><p>字符串$S$的 <strong>子串</strong>$S[i \cdots j]$，$ i \leq j $ ，表示$S$串中从$i$到$j$这一段，也就是<strong>顺次排列</strong>$ S[i],S[i+1],\cdots,S[j] $形成的字符串。</p>
<p>有时也会用 $ S[i \cdots j],i&gt;j $, 来表示空串。</p>
<h4 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h4><p>字符串$S$的 <strong>子序列</strong> 是从$S$中将若干元素提取出来并不改变相对位置形成的序列，即$ S[p_1],S[p_2],\cdots,S[p_k],1 \leq p_1 &lt; p_2 &lt; \cdots &lt;p_k \leq |S| $</p>
<h4 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h4><p><strong>后缀</strong> 是指从某个位置$i$开始到整个串末尾结束的一个特殊子串。字符串$S$的从$i$开头的后缀表示为$Suffix(S,i)$，也就是$ Suffix(S,i)=S[i \cdots |S|-1] $。</p>
<p><strong>真后缀</strong> 指除了$S$本身的$S$的后缀。</p>
<p>举例来说，字符串 <code>abcabcd</code> 的所有后缀为 <code>{d, cd, bcd, abcd, cabcd, bcabcd, abcabcd}</code> ，而它的真后缀为 <code>{d, cd, bcd, abcd, cabcd, bcabcd}</code> 。</p>
<h4 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h4><p><strong>后缀</strong> 是指从串首开始到某个位置 结束的一个特殊子串。字符串$S$的从$i$开头的后缀表示为$Preffix(S,i)$，也就是$ Preffix(S,i)=S[i \cdots |S|-1] $。</p>
<p><strong>真前缀</strong> 指除了$S$本身的$S$的前缀。</p>
<p>举例来说，字符串 <code>abcabcd</code> 的所有前缀为 <code>{a, ab, abc, abca, abcab, abcabc, abcabcd}</code> , 而它的真前缀为 <code>{a, ab, abc, abca, abcab, abcabc}</code> 。</p>
<h4 id="字典序"><a href="#字典序" class="headerlink" title="字典序"></a>字典序</h4><p>以第$i$个字符作为第$i$关键字进行大小比较，空字符小于字符集内任何字符（即:$ a&lt;aa $）。</p>
<h4 id="回文串"><a href="#回文串" class="headerlink" title="回文串"></a>回文串</h4><p><strong>回文串</strong> 是正着写和倒着写相同的字符串，即满$ \forall 1 \leq i \leq |s|,s[i]=s[|s|+1-i] $ 的$s$。</p>
<h3 id="C-C-标准库中的字符串部分函数使用"><a href="#C-C-标准库中的字符串部分函数使用" class="headerlink" title="C/C++标准库中的字符串部分函数使用"></a>C/C++标准库中的字符串部分函数使用</h3><h4 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h4><p><code>int strlen(const char *str)</code> ：返回从 <code>str[0]</code> 开始直到 <code>&#39;\0&#39;</code> 的字符数。注意，未开启 O2 优化时，该操作写在循环条件中复杂度是$ O(N) $的。</p>
<h4 id="sscanf"><a href="#sscanf" class="headerlink" title="sscanf"></a>sscanf</h4><p><code>sscanf(const char *__source, const char *__format, ...)</code> ：从字符串 <code>__source</code> 里读取变量，比如 <code>sscanf(str,&quot;%d&quot;,&amp;a)</code> </p>
<h4 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf"></a>sprintf</h4><p><code>sprintf(char *__stream, const char *__format, ...)</code> ：将 <code>__format</code> 字符串里的内容输出到 <code>__stream</code> 中，比如 <code>sprintf(str,&quot;%d&quot;,i)</code> 。</p>
<h4 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h4><p><code>int strcmp(const char *str1, const char *str2)</code> ：按照字典序比较 <code>str1 str2</code> 若 <code>str1</code> 字典序小返回负值，一样返回 0，大返回正值 请注意，不要简单的认为只有 <code>0, 1, -1</code> 三种，在不同平台下的返回值都遵循正负，但并非都是 <code>0, 1, -1</code></p>
<h4 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h4><p><code>char *strcpy(char *str, const char *src)</code> : 把 <code>src</code> 中的字符复制到 <code>str</code> 中， <code>str</code> <code>src</code> 均为字符数组头指针，返回值为 <code>str</code> 包含空终止符号 <code>&#39;\0&#39;</code> 。</p>
<h4 id="strcat"><a href="#strcat" class="headerlink" title="strcat"></a>strcat</h4><p><code>char *strcat(char *str1, const char *str2)</code> : 将 <code>str2</code> 接到 <code>str1</code> 的结尾，用 <code>*str2</code> 替换 <code>str1</code> 末尾的 <code>&#39;\0&#39;</code> 返回 <code>str1</code> 。</p>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><center><font size="6"> Good Luck And Have Fun</font></center>

]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>常数优化火车头</title>
    <url>/articles/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96%E7%81%AB%E8%BD%A6%E5%A4%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常数优化火车头"><a href="#常数优化火车头" class="headerlink" title="常数优化火车头"></a>常数优化火车头</h1><p>虽然感觉用处不大,但还是记录一下,万一某次就有用起来了呢…</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(<span class="meta-string">"Ofast"</span>)</span></span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"Ofast"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fgcse"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fgcse-lm")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fipa-sra"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-pre")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-ftree-vrp"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fpeephole2")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-ffast-math"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fsched-spec")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"unroll-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-falign-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-labels")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fdevirtualize"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fcaller-saves")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fcrossjumping"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fthread-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-funroll-loops"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fwhole-program")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-freorder-blocks"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fschedule-insns")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"inline-functions"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-tail-merge")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fschedule-insns2"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fstrict-aliasing")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fstrict-overflow"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-falign-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fcse-skip-blocks"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fcse-follow-jumps")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fsched-interblock"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fpartial-inlining")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"no-stack-protector"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-freorder-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-findirect-inlining"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fhoist-adjacent-loads")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-frerun-cse-after-loop"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline-small-functions")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-finline-small-functions"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-ftree-switch-conversion")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-foptimize-sibling-calls"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("-fexpensive-optimizations")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-funsafe-loop-optimizations"</span>)</span></span></span><br><span class="line">%:pragma GCC optimize("inline-functions-called-once")</span><br><span class="line">%:<span class="function">pragma GCC <span class="title">optimize</span><span class="params">(<span class="string">"-fdelete-null-pointer-checks"</span>)</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡三进制</title>
    <url>/articles/%E5%B9%B3%E8%A1%A1%E4%B8%89%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="平衡三进制"><a href="#平衡三进制" class="headerlink" title="平衡三进制"></a>平衡三进制</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://community.topcoder.com/stat?c=problem_statement&amp;pm=12917&amp;rd=15837" target="_blank" rel="noopener"><strong>PowerOfThree</strong></a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>给定一个<strong>二维平面</strong>上的点$ (x,y) $，一个Robot第$i$次可以向<strong>一个方向</strong>走$ 3^i $步（<strong>$i$从0开始</strong>），判断<strong>是否存在</strong>一种方式使得最后Robot走到$ (x,y) $</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p> 首先可以想到是和3有关，但发现和3有关的算法很少。。。</p>
<p>所以肯定可以想到<strong>3进制</strong>，但发现使用0，1，2表示的话，无法表示出所有的情况，且无法判断。</p>
<p>所以引入<strong>平衡三进制</strong> </p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>平衡三进制</strong>，也称为<strong>对称三进制</strong>。这是一个不太标准的<strong>计数体系</strong> 。正规的三进制的数字都是由 <code>0</code> , <code>1</code> , <code>2</code> 构成的，而平衡三进制的数字是由 <code>-1</code> , <code>0</code> , <code>1</code> 构成的。它的<strong>基数</strong>也是 <code>3</code> （因为有三个可能的值）。由于将 <code>-1</code> 写成数字不方便，我们将使用字母 $Z$来代替 <code>-1</code> ，并且这个计数体系可以很轻松的表示出负数。</p>
<p>比如：$ 6 \Rightarrow 1Z0 $，$ -5 \Rightarrow Z11 $</p>
<h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>在平衡三进制的转转换法中，需要先写出一个给定的数 $x$在标准三进制中的表示。当 $x$ 是用标准三进制表示时，其数字的每一位都是 <code>0</code> 、 <code>1</code> 或 <code>2</code> 。从最低的数字开始迭代，我们可以先跳过任何的 <code>0</code> 和 <code>1</code> ，但是如果遇到 <code>2</code> 就应该先将其变成$Z$，下一位数字再加上 <code>1</code> 。而遇到数字 <code>3</code> 则应该转换为 <code>0</code> 下一位数字再加上 <code>1</code> 。</p>
<p><strong>温馨提示</strong>：一个10进制数对应一个三进制数对应一个平衡三进制数</p>
<p>比如：</p>
<script type="math/tex; mode=display">
237_{10} \Rightarrow 22210_3</script><ul>
<li><code>0</code> 和 <code>1</code> 被跳过（因为在平衡三进制中允许 <code>0</code> 和 <code>1</code> )；</li>
</ul>
<ul>
<li><code>2</code> 变成 $Z$ ，左边的数字加 <code>1</code> ，得到 $23Z10$ ；</li>
<li><code>3</code> 变成 <code>0</code> ，左边的数字加 <code>1</code> ，得到 $30Z10$；</li>
<li><code>3</code> 变成 <code>0</code> ，左边的数字（默认是 <code>0</code> ）加 <code>1</code> ，得到 $100Z10$；</li>
<li><code>1</code> 被跳过，得到 $100Z10$。</li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>手动吸氧</title>
    <url>/articles/%E6%89%8B%E5%8A%A8%E5%90%B8%E6%B0%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="手动开启O2优化—以及-O-O1-O2-O3优化的知识点"><a href="#手动开启O2优化—以及-O-O1-O2-O3优化的知识点" class="headerlink" title="手动开启O2优化—以及-O -O1 -O2 -O3优化的知识点"></a>手动开启O2优化—以及-O -O1 -O2 -O3优化的知识点</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li><p>O1优化会消耗少多的编译时间，它主要对代码的分支，常量以及表达式等进行优化。 </p>
<p>O2会尝试更多的寄存器级的优化以及指令级的优化，它会在编译期间占用更多的内存和编译时间。 </p>
<p>O3在O2的基础上进行更多的优化，例如使用伪寄存器网络，普通函数的内联，以及针对循环的更多优化。 </p>
<p>Os主要是对代码大小的优化，我们基本不用做更多的关心。 通常各种优化都会打乱程序的结构，让调试工作变得无从着手。并且会打乱执行顺序，依赖内存操作顺序的程序需要做相关处理才能确保程序的正确性。 </p>
</li>
<li><p>-O0： 不做任何优化，这是默认的编译选项。</p>
</li>
<li><p>-O和-O1： 对程序做部分编译优化，对于大函数,优化编译占用稍微多的时间和相当大的内存。使用本项优化，编译器会尝试减小生成代码的尺寸，以及缩短执行时间，但并不执行需要占用大量编译时间的优化。</p>
</li>
<li>O2优化能使程序的编译效率大大提升。从而减少程序的运行时间，达到优化的效果。</li>
</ul>
<h2 id="开启方式"><a href="#开启方式" class="headerlink" title="开启方式"></a>开启方式</h2><h3 id="O2"><a href="#O2" class="headerlink" title="O2"></a>O2</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(2)</span></span><br></pre></td></tr></table></figure>
<h3 id="O3"><a href="#O3" class="headerlink" title="O3"></a>O3</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3,<span class="meta-string">"Ofast"</span>,<span class="meta-string">"inline"</span>)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶逆变换</title>
    <url>/articles/%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E9%80%86%E5%8F%98%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="快速傅里叶逆变换"><a href="#快速傅里叶逆变换" class="headerlink" title="快速傅里叶逆变换"></a>快速傅里叶逆变换</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>IDFT（傅里叶逆变换）</strong>是把目标多项式的<strong>点值形式</strong>转换成<strong>系数形式</strong></p>
<p>即：由$n$维点值$ (A(x<em>0),A(x_1), \cdots ,A(X</em>{n-1})) $，推出$n$维系数向量$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $</p>
<h2 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>设$ (d<em>0,d_1, \cdots ,d</em>{n-1}) $为$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $得到的<strong>离散傅里叶变换</strong>的结果</p>
<p>我们<strong>构造</strong>一个多项式$ F(x)=d<em>0+d_1 \cdot x+d_2 \cdot x^2 + \cdots + d</em>{n-1} \cdot x^{n-1} $</p>
<p>设向量$ (c<em>0,c_1, \cdots ,c</em>{n-1}) $中</p>
<p>$c_k$为$ F(x) $在$ x= \omega^{-k}_n $的<strong>点值表示</strong></p>
<p>即$ c<em>k= \sum^{n-1}</em>{i=0} d_i \cdot ( \omega^{-k}_n)^i $</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>我们考虑对$d_i$进行<strong>还原</strong></p>
<p>于是</p>
<script type="math/tex; mode=display">
c_k= \sum^{n-1}_{i=0} [ \sum^{n-1}_{i=0}a_j \cdot ( \omega^i_n)^j] \cdot ( \omega^{-k}_n)^i \\
\Rightarrow \sum^{n-1}_{j=0} a_j \sum^{n-1}_{i=0} ( \omega^i_n)^j \cdot ( \omega ^{-k}_n)^i \\
\Rightarrow \sum^{n-1}_{j=0} a_j \sum^{n-1}_{i=0} ( \omega^i_n)^{j-k}</script><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>我们令$ S(j,k)= \sum^{n-1}_{i=0} ( \omega^i_n)^{j-k} $</p>
<p>对其进行<strong>化简</strong></p>
<p>设$ j-k= \delta $</p>
<p>则$ S(j,k)= \omega_n^{0}+ \omega^{ \delta}_n+ \omega^{2 \delta}_n+ \cdots + \omega^{(n-1) \delta}_n $</p>
<p>其<strong>公比</strong>为$ \omega^{ \delta}_n $</p>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p><strong>当$ \omega^{ \delta}_n=1 $即$ \delta=0 $时</strong></p>
<script type="math/tex; mode=display">
S(j,k)=n \Rightarrow \delta=0 \Rightarrow j-k=0 \Rightarrow j=k</script><p><strong>当$ \omega^{ \delta}_n \neq 1 $即$ \delta \neq 0 $时</strong></p>
<script type="math/tex; mode=display">
S(j,k)= \frac{ \omega^0_n[( \omega^{ \delta}_n)^n -1]}{ \omega ^{ \delta}_n -1}= \frac{1[( \omega^n_n)^{ \delta}-1]}{ \omega^{ \delta}_n -1}= \frac{[1^{ \delta} -1]}{ \omega^{ \delta}_n -1}= \frac{0}{ \omega ^{ \delta}_n -1}=0 \Rightarrow j \neq k​</script><p>所以$ S(j,k)=[j=k] \cdot n $</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>将$ S(j,k) $<strong>代入原式</strong></p>
<script type="math/tex; mode=display">
c_k= \sum ^{n-1}_{j=0} a_j \cdot S(j,k) = \sum^{n-1}_{j=0} a_j \cdot [j=k] \cdot n=a_k \cdot n</script><p>所以$ a_k= \frac{c_k}{n} $</p>
<p>其中$ a_k $为原多项式$ A(x) $的<strong>系数向量</strong>$ (a_0,a_1, \cdots ,a_n) $中的$ a_k $</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>由此可得</p>
<p>我们将$ ( \omega^0<em>n, \omega^{-1}_n, \omega^{-2}_n, \cdots , \omega^{-(n-1)}_n) $作为<strong>插值节点</strong>$ (d_0,d_1, \cdots ,d</em>{n-1}) $作为系数向量，做一次<strong>离散傅里叶变换</strong>得到的向量的每一项都<strong>除以$n$</strong>得到$ ( \frac{c<em>0}{n}, \frac{c_1}{n}, \cdots , \frac{c</em>{n-1}}{n}) $就是多项式的<strong>系数向量</strong>$ (a<em>0,a_1, \cdots ,a</em>{n-1}) $</p>
<p>注意，$ \omega^{-k}_n $是$ \omega^k_n $的<strong>共轭复数</strong></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plurality</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line"></span><br><span class="line">    Plurality (<span class="keyword">double</span> A=<span class="number">0.0</span>,<span class="keyword">double</span> B=<span class="number">0.0</span>) &#123; X=A; Y=B; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> + (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X+B.X,A.Y+B.Y); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> - (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X-B.X,A.Y-B.Y); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> * (Plurality A,Plurality B) &#123; <span class="keyword">return</span> Plurality(A.X*B.X-A.Y*B.Y,A.X*B.Y+A.Y*B.X); &#125;</span><br><span class="line">    <span class="keyword">friend</span> Plurality <span class="keyword">operator</span> * (Plurality A,<span class="keyword">double</span> B) &#123; <span class="keyword">return</span> Plurality(A.X*B,A.Y*B); &#125;</span><br><span class="line">&#125;F[MAXN],G[MAXN];</span><br><span class="line"><span class="keyword">int</span> N,M,Rev[MAXN],Limit=<span class="number">1</span>,Loc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(Plurality *New)</span> </span>&#123; </span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) Rev[i]=(Rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>) | ((i &amp; <span class="number">1</span>)&lt;&lt;(Loc<span class="number">-1</span>));</span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) <span class="keyword">if</span>(i&lt;Rev[i]) swap(New[i],New[Rev[i]]); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Plurality *New,<span class="keyword">int</span> Tag)</span> </span>&#123;</span><br><span class="line">    Change(New);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> Mid=<span class="number">1</span>;Mid&lt;Limit;Mid&lt;&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="function">Plurality <span class="title">Step</span><span class="params">(<span class="built_in">cos</span>(PI/Mid),Tag*<span class="built_in">sin</span>(PI/Mid))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> K=<span class="number">0</span>;K&lt;Limit;K+=(Mid&lt;&lt;<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="function">Plurality <span class="title">I</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Mid;i++,I=I*Step) &#123;</span><br><span class="line">               Plurality A=New[K+i],B=I*New[K+i+Mid];</span><br><span class="line">               New[K+i]=A+B;</span><br><span class="line">               New[K+i+Mid]=A-B; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) &#123; New[i]/=(<span class="keyword">double</span>)Limit; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>指针 &amp; 函数基础应用</title>
    <url>/articles/%E6%8C%87%E9%92%88-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="指针-amp-函数基础应用"><a href="#指针-amp-函数基础应用" class="headerlink" title="指针 &amp; 函数基础应用"></a>指针 &amp; 函数基础应用</h1><h3 id="By-DeNeRATe—2020-8-6"><a href="#By-DeNeRATe—2020-8-6" class="headerlink" title="By DeNeRATe—2020.8.6"></a>By DeNeRATe—2020.8.6</h3><p>为了更好地理解和应用指针，我们先来简介一下内存空间。</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>指针是我们必须了解的一个板块，但它在竞赛范围内的应用开始逐渐呈下降态，在实现算法时对于指针的使用一般会去回避，因为一不小心，指针就会指偏，而且不容易调试。$ \cdots \cdots $</p>
<p>但指针的作用是无可替代的，那此时该怎么办呢—<strong>迭代器</strong>$ \cdots \cdots $</p>
<p>所以，我们就来先讲一下这神奇的东西—<strong>指针</strong></p>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>○<strong>内存栈区</strong>： 存放局部变量名；</p>
<p>○<strong>内存堆区</strong>： 存放new或者malloc出来的对象；</p>
<p>○<strong>常数区</strong>： 存放局部变量或者全局变量的值；</p>
<p>○<strong>静态区</strong>： 用于存放全局变量或者静态变量；</p>
<p>○<strong>代码区</strong>：二进制代码。</p>
<h4 id="程序的内存分配"><a href="#程序的内存分配" class="headerlink" title="程序的内存分配"></a>程序的内存分配</h4><p>○<strong>栈区（stack）</strong>— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </p>
<p>○<strong>堆区（heap） </strong>— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表</p>
<p>○<strong>全局区（静态区）（static）</strong>—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域（RW）， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域（ZI）。 - 程序结束后有系统释放 </p>
<p>○<strong>文字常量区 </strong>—常量字符串就是放在这里的。 程序结束后由系统释放 （RO）</p>
<p>○<strong>程序代码区</strong>—存放函数体的二进制代码。 （RO）</p>
<h4 id="图解内存"><a href="#图解内存" class="headerlink" title="图解内存"></a>图解内存</h4><p>在 sw-at 的博客上扒了一张图，这张图中所示内存空间，地址由下往上增长，分别标示了 .text、.data、.bss、stack和heap的内存分部情况。</p>
<p><img src="https://i.loli.net/2020/08/06/5NCGkj2tbfzA1FY.png" alt="程序内存分配.png"></p>
<p>text、data(gvar)、bss 在内存中地址较低低的位置（low level address），而堆栈则在相对较搞的位置。<br>堆(Heap)往高地址方向生长，栈(Stack)往低地址方向生长。</p>
<h4 id="不同内存的特点"><a href="#不同内存的特点" class="headerlink" title="不同内存的特点"></a>不同内存的特点</h4><p>○<strong>栈</strong></p>
<p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，用于在函数作用域内创建，在离开作用域后自动销毁的变量的存储区。通常是局部变量，函数参数等的存储区。他的存储空间是连续的，两个紧密挨着定义的局部变量，他们的存储空间也是紧挨着的。栈的大小是有限的，通常Visual C++编译器的默认栈的大小为<strong>1MB</strong>，所以不要定义int a[1000000]这样的超大数组。</p>
<p>○<strong>堆</strong></p>
<p>通常是用于那些在编译期间不能确定存储大小的变量的存储区，它的存储空间是不连续的，一般由malloc（或new）函数来分配内存块，并且需要用free（delete）函数释放内存。如果程序员没有释放掉，那么就会出现常说的内存泄漏问题。需要注意的是，两个紧挨着定义的指针变量，所指向的malloc出来的两块内存并不一定的是紧挨着的，所以会产生内存碎片。另外需要注意的一点是，堆的大小几乎不受限制，理论上每个程序最大可达<strong>4GB</strong>。</p>
<p>○<strong>全局/静态存储区</strong></p>
<p> 和“栈”一样，通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的全局变量和静态变量。</p>
<p>○<strong>常量存储区</strong></p>
<p> 和“全局/静态存储区”一样，通常是用于那些在编译期间就能确定存储大小的常量的存储区，并且在程序运行期间，存储区内的常量是全局可见的。这是一块比较特殊的存储去，他们里面存放的是常量，不允许被修改。</p>
<p><img src="https://i.loli.net/2020/08/06/qiws5oZ7BVlgz3m.png" alt="栈和堆对比 _ 全局存储器和常量存储区的对比.png"></p>
<h4 id="程序变量分配内存"><a href="#程序变量分配内存" class="headerlink" title="程序变量分配内存"></a>程序变量分配内存</h4><h5 id="1-预备知识"><a href="#1-预备知识" class="headerlink" title="1.预备知识"></a>1.预备知识</h5><p>byte:字节           bit:位</p>
<p>$ \Rightarrow $<strong>1 byte = 8 bit</strong></p>
<h5 id="2-程序变量"><a href="#2-程序变量" class="headerlink" title="2.程序变量"></a>2.程序变量</h5><p>○<strong>短整型short</strong></p>
<p>  所占内存大小：<strong>2byte=16bit</strong>；</p>
<p>  所能表示范围：$ -32768 \rightarrow 32767$ 即$ -2^{15} \rightarrow 2^{15}-1 $</p>
<p>○<strong>整型int</strong>：</p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ -2147483648 \rightarrow 2147483647 $ 即$ -2^{31} \rightarrow 2^{31}-1 $</p>
<p>  <strong>unsigned int: </strong> </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 4294967295 $ 即$ 0 \rightarrow 2^{32}-1 $</p>
<p>○<strong>长整型long</strong>：</p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ -2147483648 \rightarrow 2147483647 $ 即$ -2^{31} \rightarrow 2^{31}-1 $</p>
<p><strong>unsigned long:</strong>  </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 4294967295 $即$ 0 \rightarrow 2^{32}-1 $</p>
<p>○<strong>4. long long:</strong></p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示范围：$ -9223372036854775808 \rightarrow 9223372036854775807 $ 即$ -2^{63} \rightarrow 2^{63}-1 $$</p>
<p>  <strong>unsigned long: </strong> </p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 1844674407370955161 $ 即$ 0 \rightarrow 2^{64}-1 $</p>
<p>○<strong>字符型char</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：不确定……；</p>
<p>  <strong>unsigned char</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：$ 0 \rightarrow 255 $ 即$ 0 \rightarrow 2^8-1 $$</p>
<p>   <strong>singned char:</strong>  </p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示范围：$ -128 \rightarrow127 $ 即$  -2^7 \rightarrow 2^7-1 $</p>
<p><strong>温馨提示：</strong>  char的默认类型不确定有可能是unsigned，也有可能是signed，主要更具编译器而定，可以自己测试一下编译器的默认char的符号类型。</p>
<p>○<strong>布尔类型bool</strong>：</p>
<p>  所占内存大小：<strong>1byte=8bit</strong>；</p>
<p>  所能表示的范围：只能取两个值<strong>false</strong>或者<strong>true</strong>；</p>
<p>  所以最小值就是：<strong>0</strong>， 最大值：<strong>1</strong>.</p>
<p>○<strong>单精度float</strong>：   </p>
<p>  所占内存大小：<strong>4byte=32bit</strong>；</p>
<p>  所能表示的范围：$ 1.17549e-038 \rightarrow 3.40282e+038 $</p>
<p>  <strong>温馨提示：</strong>浮点数在 内存中都是按科学计数法来存储的，浮点数的精度是由尾数的位数决定的，大家记住即可不必深究；</p>
<p> ○<strong>双精度double</strong>：</p>
<p>  所占内存大小：<strong>8byte=64bit</strong>；</p>
<p>  所能表示的范围：$ 2.22507e-308 \rightarrow 1.79769e+308 $</p>
<p>  <strong>温馨提示：</strong>如何区分和使用这两个浮点类型呢，首先float和double的精度不同， float保留到小数点后面7位，而double保留到小数点后面16位，float能保证6 位有效数字，而double能保证15位有效数字，如果在不追求精度的的情况下当然用 float比较好，节省内存，如果需要很高的精度的情况下，最好还是用 double，平时我们定义浮点型变量一般都用double，毕竟精度高，<strong>一般精度的损失是不能忽略的</strong></p>
<h4 id="关于做题时内存的作用"><a href="#关于做题时内存的作用" class="headerlink" title="关于做题时内存的作用"></a>关于做题时内存的作用</h4><p><del>（此处口胡）</del></p>
<p>比如：<a href="https://www.luogu.com.cn/problem/P6561" target="_blank" rel="noopener">P6561 [SBCOI2020] 人</a></p>
<h3 id="指针-编程语言中的一个对象"><a href="#指针-编程语言中的一个对象" class="headerlink" title="指针(编程语言中的一个对象)"></a>指针(编程语言中的一个对象)</h3><p>刚才扯得有点远了，但一些重要的关于内存的只是也是很重要的</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote>
<p>指针，是C语言中的一个重要<a href="https://baike.baidu.com/item/概念/829047" target="_blank" rel="noopener">概念</a>及其<a href="https://baike.baidu.com/item/特点/10931917" target="_blank" rel="noopener">特点</a>，也是掌握C语言比较困难的部分。指针也就是<a href="https://baike.baidu.com/item/内存地址/7354236" target="_blank" rel="noopener">内存地址</a>，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的<a href="https://baike.baidu.com/item/存储空间/10657950" target="_blank" rel="noopener">存储空间</a>长度也不同。有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。</p>
</blockquote>
<p>为了更好的理解指针，我们先来康康变量。</p>
<h4 id="变量的实质"><a href="#变量的实质" class="headerlink" title="变量的实质"></a>变量的实质</h4><p>首先是一张内存空间图：</p>
<p><img src="https://i.loli.net/2020/08/06/fJxu89CaTGbpOyl.png" alt="变量的实质-1.png"></p>
<p>如图所示，内存只不过是一个存放数据的空间，现在我们把它想象成电影院的座位，电影院中的每个座位都要编号，而我们的内存要存放各种各样的数据，当然我们要知道我们的这些数据存放在什么位置吧！所以内存也要象座位一样进行编号了，这就是我们所说的<strong>内存编址（为内存进行地址编码）</strong>。座位可以是遵循“一个座位对应一个号码”的原则，从“第 1 号”开始编号。而内存则是按一个字节接着一个字节的次序进行编址，如上图所示。每个字节都有个编号，我们称之为<strong>内存地址</strong>。</p>
<p>内存编址：</p>
<p><img src="https://i.loli.net/2020/08/06/RnfPAMbpcJV7Ivz.png" alt="变量的实质-2.png"></p>
<p>当我们在程序中写下了这样的语言声明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span> a;</span><br></pre></td></tr></table></figure>
<p>它其实是内存中申请了一个名为 i 的整型变量宽度空间（DOS 下的 16 位编程中其宽度为 2 个字节），和一个名为 a 的字符型变量宽度的空间（占 1 个字节）。</p>
<p>此时，内存空间中的映像如图：</p>
<p><img src="https://i.loli.net/2020/08/06/cPNgrlBQFmekqn8.png" alt="变量的实质-3.png"></p>
<p>图中可看出，i 在内存起始地址为 6 上申请了两个字节的空间（我这里假设了 int 的宽度为 16 位，不同系统中 int 的宽度可能是不一样的，最常用的win32环境下为4个字节），并命名为 i。a 在内存地址为 8 上申请了一字节的空间，并命名为 a。</p>
<h4 id="变量的赋值"><a href="#变量的赋值" class="headerlink" title="变量的赋值"></a>变量的赋值</h4><p>但我们在赋值时：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i=<span class="number">30</span>;</span><br><span class="line">a=<span class="string">'t'</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/08/06/xehYDg7iWm94cVb.png" alt="变量的赋值.png"></p>
<p>我们将30存在了以地址6（真正的地址可不是这样子哦，真正的地址如：0016FD14）为起始地址的两个字节空间里，a 在内存地址为 8 上申请了一字节的空间存入了‘t’</p>
<h4 id="变量的位置"><a href="#变量的位置" class="headerlink" title="变量的位置"></a>变量的位置</h4><p>我们是怎么知道真正的地址的呢：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;i = "</span>&lt;&lt; &amp;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i =  "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的 &amp;i 的值 0016FD14就是我们图示中内存空间编码为6的内存地址。</p>
<h4 id="指针的实质"><a href="#指针的实质" class="headerlink" title="指针的实质"></a>指针的实质</h4><p>下面看一条声明一个指向整型变量的指针的语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi;</span><br></pre></td></tr></table></figure>
<p>pi 是一个指针，当然我们知道啦，但是这样说，你就以为 pi 一定是个多么特别的东西了。其实，它也只过是一个变量而已。与上一篇中说的变量并没有实质的区别。好了，这就是指针。仅此而已，就这么简单。</p>
<p><img src="https://i.loli.net/2020/08/06/trjsJTEXcHMoD3U.png" alt="指针的实质-1.png"></p>
<p>pi 也只不过是一个变量而已嘛！那么它又为什么会被称为“指针”？关键是我们要让这个变量所存储的内容是什么。现在我要让 pi 成为具有真正“指针”意义的变量。请接着看下面语句：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pi=&amp;i;</span><br></pre></td></tr></table></figure>
<p><strong>把 i 地址的编号赋值给 pi</strong>。并记下来。也就是你<strong>在 pi 里面写上 i 的地址编号</strong>。结果如下图所示：</p>
<p><img src="https://i.loli.net/2020/08/06/IC4kUEV95AJqPi2.png" alt="指针的实质-2.png"></p>
<p>执行完 pi=&amp;i 后，在图示中的内存中，pi 的值是 6。这个 6 就是i 变量的地址编号，这样 pi 就指向了变量 i 了。pi 与那张纸条有什么区别？pi 不就是那张纸条嘛！因此，我们就把 pi 称为指针。</p>
<p>总结一句话：<strong>指针变量所存的内容就是内存的地址编号 ！</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">30</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"&amp;i = "</span>&lt;&lt; &amp;i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i =  "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> *pi = &amp;i;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*pi = "</span> &lt;&lt; *pi &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么程序中pi 什么意思呢？<strong>pi 内容所指的地址的内容</strong></p>
<h4 id="MORE-INFORMATION"><a href="#MORE-INFORMATION" class="headerlink" title="MORE INFORMATION"></a>MORE INFORMATION</h4><p>当然，对于指针我们其实只需要了解即可，若大家有兴趣的话，可以康康这：<a href="https://blog.csdn.net/weixin_39951988/article/details/87773322" target="_blank" rel="noopener">指针详解</a>(但确实没必要，有生之年应该不会用到其他的)</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p>听说，暴力打不出来的时候，STL和迭代器更配哟 — 哲哥</p>
<p>迭代器（iterator）有时又称游标（cursor）是程序设计的<a href="https://baike.baidu.com/item/软件设计模式/2117635" target="_blank" rel="noopener">软件设计模式</a>，可在容器（container，例如<a href="https://baike.baidu.com/item/链表/9794473" target="_blank" rel="noopener">链表</a>或<a href="https://baike.baidu.com/item/阵列/2644035" target="_blank" rel="noopener">阵列</a>）上遍访的接口，设计人员无需关心容器的内容。</p>
</blockquote>
<p>(此处展开$ [\,\,\,] + $)</p>
<h3 id="基础函数的访问"><a href="#基础函数的访问" class="headerlink" title="基础函数的访问"></a>基础函数的访问</h3><h4 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h4><p> ○C/C++自带函数</p>
<p>比如：swap()  reverse()  strcat()  sort() $ \cdots \cdots $</p>
<p> ○STL函数</p>
<p>比如：lower_bound()  upper_bound()  assign() $ \cdots \cdots $</p>
<p> ○自定义函数</p>
<p>（当然我们需要重点掌握的就是自定义函数了，因为其他的是人应该都是直接上手的  <del>口胡.JPG</del>）</p>
<h4 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h4><h5 id="1-gt"><a href="#1-gt" class="headerlink" title="1&gt;"></a>1&gt;</h5><p>简化代码量，对各个部分进行封装，使得问题变得简单和直观，提高了程序的易读性</p>
<h5 id="2-gt"><a href="#2-gt" class="headerlink" title="2&gt;"></a>2&gt;</h5><p>提升可维护性，把一些计算或操作编成通用的函数，以供随时调用，从而避免了代码的重复冗长</p>
<h5 id="3-gt"><a href="#3-gt" class="headerlink" title="3&gt;"></a>3&gt;</h5><p>但是运用函数，就需要传递参数，开辟缓存、堆栈等，相比较而言，会耗一些多余的效率</p>
<h4 id="自定义函数方式"><a href="#自定义函数方式" class="headerlink" title="自定义函数方式"></a>自定义函数方式</h4><ul>
<li>函数的返回类型分：</li>
</ul>
<h5 id="1-gt-void-型"><a href="#1-gt-void-型" class="headerlink" title="1&gt;void 型"></a>1&gt;void 型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>void类型是可以直接使用的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Update();</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-int-double-long-long-类型"><a href="#2-gt-int-double-long-long-类型" class="headerlink" title="2&gt;int(double)(long long)类型"></a>2&gt;int(double)(long long)类型</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Get</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>当然这种类型一般是需要一个变量来接收这个值的。例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> Res=Get();</span><br></pre></td></tr></table></figure>
<ul>
<li>传递的类型分：</li>
</ul>
<p>1&gt;值传递</p>
<p>2&gt;引传递</p>
<p>3&gt;指针传递</p>
<h4 id="传参操作"><a href="#传参操作" class="headerlink" title="传参操作"></a>传参操作</h4><h5 id="1-gt-值传递"><a href="#1-gt-值传递" class="headerlink" title="1&gt;值传递"></a>1&gt;值传递</h5><p>调用时，将实参的值传递对应的形参，即为值传递。函数中对任何形参值得修改都不会改变实参变量的值。<br>例如经典的交换x，y的值：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Temp=X;</span><br><span class="line">    X=Y; </span><br><span class="line">    Y=Temp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Change:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y:"</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    Change(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gt-引传递"><a href="#2-gt-引传递" class="headerlink" title="2&gt;引传递"></a>2&gt;引传递</h5><p>引用变量是变量的另一个<strong>别名</strong>，它<strong>没有自己的存储数据的内存位置</strong>，它访问的是另一个变量的内存位置。对引用变量作出的任何更改，实际上都是对它所引用的变量内存位置中存储数据的更改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Temp=X;</span><br><span class="line">    X=Y; </span><br><span class="line">    Y=Temp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Change:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"y:"</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    Change(a,b);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"main:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"a:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"b:"</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现main函数中的a,b改变了。所以 $ \cdots \cdots $</p>
<h5 id="3-gt-指针传递"><a href="#3-gt-指针传递" class="headerlink" title="3&gt;指针传递"></a>3&gt;指针传递</h5><p>这当然就是我们最容易忽略，但需要用的时候灰常有用的传递方式了。主要用处就是对于函数如果要传递数组作为继承时</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Num[MAXN],Total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ex_change</span><span class="params">(<span class="keyword">int</span> Temp[])</span><span class="comment">//方式1</span></span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ex_change</span><span class="params">(<span class="keyword">int</span> *Temp)</span><span class="comment">//方式2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这两种方式若在其中进行变量的更改，那个由于是传递的地址</span></span><br><span class="line">    <span class="comment">//所以外边的Num数组也会发生改变</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=Total;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Num[i]);</span><br><span class="line">    Ex_change(Num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h4><p><a href="https://www.luogu.com.cn/problem/P1035" target="_blank" rel="noopener">P1035 级数求和</a></p>
<p>(我们现在改一下这道题，有Q次询问)</p>
<h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><h5 id="1-gt-inline"><a href="#1-gt-inline" class="headerlink" title="1&gt;inline"></a>1&gt;inline</h5><p>作用：可写可不写 $ \cdots \cdots $</p>
<p>只是可以加快一下程序的速度，和register的作用差不多。</p>
<h5 id="2-gt-函数调用的位置"><a href="#2-gt-函数调用的位置" class="headerlink" title="2&gt;函数调用的位置"></a>2&gt;函数调用的位置</h5><p>初学函数时，若写多个函数，由于不注意，可能会出现神奇的错误—调用不了函数</p>
<p>因为函数和变量一样，只会在一定的区域内查找需要的函数。</p>
<p>而函数的作用范围是从这个函数所处的位置向下走的位置</p>
<p>比如如图：Paint()函数的作用范围只有红框，若果在DFS()函数中调用Paint()那么就会发现，编译器找不到Paint()函数在哪儿，就会报错</p>
<p><img src="https://i.loli.net/2020/08/06/LvPD6yxsealI4oO.png" alt="函数的作用范围.png"></p>
<h5 id="3-gt-函数名重复"><a href="#3-gt-函数名重复" class="headerlink" title="3&gt;函数名重复"></a>3&gt;函数名重复</h5><p>变量名在一定的区域内不可被重复定义。</p>
<p>但函数是可以重名的，但必须是变量调用数量不同，或者是变量类型不同。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">inline void Init(int a) √</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">inline void Init(int b,int c) √</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">inline void Init(int a) √</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">inline void Init(double a) √</span><br></pre></td></tr></table></figure>
<h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><center><font size="6"> Good Luck And Have Fun</font></center>]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>斐波那契数列模意义下循环节</title>
    <url>/articles/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E5%BE%AA%E7%8E%AF%E8%8A%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="斐波那契数列模意义下循环节"><a href="#斐波那契数列模意义下循环节" class="headerlink" title="斐波那契数列模意义下循环节"></a>斐波那契数列模意义下循环节</h1><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>对于函数$ f(n)=the\,\,\,nth\,\,\,number\,\,\,of\,\,\,the\,\,\,Fibonacci\,\,\,Sequence $ </p>
<p>求出$ f(f(n))\,\,\,n \leq 10^{100} $且对$ mod\,\,\,1e9+7 $</p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>当然我这里只能将要证明一下（<del>口胡一下</del>）</p>
<p><strong>具体证明</strong>可见于<a href="http://gradprogram.math.arizona.edu/~ura-reports/071/Campbell.Charles/Final.pdf" target="_blank" rel="noopener">Charles W. Campbell II. The Period of the Fibonacci Sequence Modulo j. 2007.</a></p>
<p>我们规定$ G(n) $表示$n$的<strong>最小循环节</strong>，且以下都是在$ mod\,\,\,p $意义下 </p>
<h3 id="引理一"><a href="#引理一" class="headerlink" title="引理一"></a>引理一</h3><p>$ n=p_1^{e_1} \times p_2^{e_2} \times \cdots \times p_m^{e_m} $ </p>
<p>那么$n$的循环节为$ lcm(G(p_1^{e_1}),G(p_2^{e_2}), \cdots ,G(p_m^{e_m})) $</p>
<h3 id="引理二"><a href="#引理二" class="headerlink" title="引理二"></a>引理二</h3><p>$ G(p_i^{e_i})=G(p_i) \times p_i^{e_i-1} $</p>
<h3 id="引理三"><a href="#引理三" class="headerlink" title="引理三"></a>引理三</h3><p>如果5是$ mod\,\,\,p $意义下的<strong>二次剩余</strong>，那么循环节长度为$p-1$的因子否则长为$2(p+1)$</p>
<p>且对于$ \leq 5 $得素数进行<strong>特殊判断</strong></p>
<p>$ loop(2)=3,loop(3)=8,loop(5)=20 $</p>
<p>可以求出所有的因子，然后一个<strong>矩阵快速幂</strong>一个一个判断</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> x = <span class="number">0</span>,f = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">char</span> c = getchar(); </span><br><span class="line">	<span class="keyword">while</span>(c  &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) c = getchar(); </span><br><span class="line">	<span class="keyword">while</span>(c  &lt;= <span class="string">'9'</span> &amp;&amp; c &gt;= <span class="string">'0'</span>) x = x * <span class="number">10</span> + c-<span class="string">'0'</span>,c = getchar(); </span><br><span class="line">	<span class="keyword">return</span> x *f ; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m1 = <span class="number">1000000007</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m2 = m1 * <span class="number">2</span> + <span class="number">2</span>; </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> m3 = m2 * <span class="number">3</span>; </span><br><span class="line"><span class="keyword">int</span> n ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>]; </span><br><span class="line">	Matrix () &#123; <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span> a); &#125;   	</span><br><span class="line">	Matrix  <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix &amp; p) <span class="keyword">const</span> &#123; </span><br><span class="line">		Matrix ret; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;++ i) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;++ j) </span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;++ k) </span><br><span class="line">					ret.a[i][j] = (ret.a[i][j] + a[i][k] * p.a[k][j]) % m1; </span><br><span class="line">		<span class="keyword">return</span> ret; </span><br><span class="line">	&#125; </span><br><span class="line">	Matrix  <span class="keyword">operator</span> + (<span class="keyword">const</span> Matrix &amp; p) <span class="keyword">const</span> &#123;</span><br><span class="line">		Matrix ret; </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= <span class="number">1</span>;++ i) </span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt;= <span class="number">1</span>;++ j) </span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k &lt;= <span class="number">1</span>;++ k) </span><br><span class="line">					ret.a[i][j] =(ret.a[i][j] +  a[i][k] * p.a[k][j]) % m2; </span><br><span class="line">	 	<span class="keyword">return</span> ret; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	Matrix p,q; </span><br><span class="line">	p.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; p.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; p.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">	q.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//,q.a[1][1] = 1; </span></span><br><span class="line">	<span class="keyword">for</span>(;x;x &gt;&gt;= <span class="number">1</span>,p = p + p) </span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) q = q + p; </span><br><span class="line">	<span class="keyword">return</span> q.a[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; </span><br><span class="line">	Matrix p,q; </span><br><span class="line">	p.a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; p.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>; p.a[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">	q.a[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;  </span><br><span class="line">	<span class="keyword">for</span>(;x;x &gt;&gt;= <span class="number">1</span>,p = p * p) </span><br><span class="line">		<span class="keyword">if</span>(x &amp; <span class="number">1</span>) q = q * p; </span><br><span class="line">	<span class="keyword">return</span> q.a[<span class="number">0</span>][<span class="number">0</span>]; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100007</span>]; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span> &#123;</span> </span><br><span class="line">	<span class="keyword">int</span> z[<span class="number">100007</span>],l;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; </span><br><span class="line"> 		<span class="built_in">memset</span>(z,<span class="number">0</span>,<span class="keyword">sizeof</span>(z)); </span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,s + <span class="number">1</span>); </span><br><span class="line">		l = <span class="built_in">strlen</span>(s + <span class="number">1</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= l;i ++) </span><br><span class="line">			z[i] = s[l - i + <span class="number">1</span>] - <span class="string">'0'</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">int</span> <span class="keyword">operator</span> % (<span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">long</span> &amp; a) <span class="keyword">const</span> &#123; </span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = l;i &gt;= <span class="number">1</span>;i --) </span><br><span class="line">			b = (b * <span class="number">10</span> + z[i]) % a; </span><br><span class="line">		<span class="keyword">return</span> b; </span><br><span class="line">	&#125; </span><br><span class="line">&#125;z;  </span><br><span class="line">main() &#123; </span><br><span class="line">	<span class="keyword">int</span> t = <span class="built_in">read</span>(); </span><br><span class="line">	bign num; </span><br><span class="line">	<span class="keyword">while</span>(t --)  &#123; </span><br><span class="line">		num.init(); </span><br><span class="line">		n = num % m3; </span><br><span class="line">		n = get1(n); </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,get2(n));  </span><br><span class="line">	&#125; 	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>有向图与SG函数</title>
    <url>/articles/%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%8ESG%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="有向图与SG函数"><a href="#有向图与SG函数" class="headerlink" title="有向图与SG函数"></a>有向图与SG函数</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>SG函数</strong>和<strong>有向图</strong>有着千丝万缕的联系，大部分<strong>公平组合游戏</strong>都可以转换为<strong>有向图游戏</strong></p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>在一个<strong>有向无环图</strong>中，只有<strong>一个起点</strong>，上面有一个棋子，两个玩家轮流沿着有向边推动棋子，<strong>不能走的玩家</strong>判负。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义$mex$函数的值为不属于集合$S$中的<strong>最小非负整数</strong>，即：</p>
<script type="math/tex; mode=display">
mex(S)=min \lbrace x \rbrace \,\,\, ( x \notin S,x \in \mathbb{N})</script><p>例如：$ mex( \lbrace 0,2,4 \rbrace )=1,mex( \lbrace 1,2 \rbrace )=0 $</p>
<p>对于状态$x$和它的所有$k$个<strong>后继状态</strong>$ y_1,y_2, \cdots ,y_k $，定义<strong>SG函数</strong>：</p>
<script type="math/tex; mode=display">
SG(x)=mex \lbrace SG(y_1),SG(y_2), \cdots ,SG(y_k) \rbrace</script><p>而对于由$n$个有向图游戏组成的<strong>组合游戏</strong>，设他们的起点分别为$ s_1,s_2, \cdots ,s_n $，则有定理：<strong>当且仅当</strong>$ SG(s_1) \bigoplus SG(s_2) \bigoplus \cdots \bigoplus SG(s_n) \neq 0 $时，这个游戏的<strong>先手必胜</strong></p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们可以将一个有$x$个物品的堆视为节点$x$，则当且仅当$ y &lt; x $时，节点$x$可以到达$y$。</p>
<p>那么，由$n$个堆组成的 <strong>Nim 游戏</strong>，就可以视为$n$个<strong>有向图游戏</strong>了。</p>
<p>根据上面的推论，可以得出$ SG(x)=x $。再根据 <strong>SG 定理</strong>，就可以得出 <strong>Nim 和的结论</strong>了。</p>
<p><img src="https://i.loli.net/2020/08/14/GSUxqWzHX8dPC4m.png" alt="有向图与SG函数-1.png"></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>浮点数操作的异常情况</title>
    <url>/articles/%E6%B5%AE%E7%82%B9%E6%95%B0%E6%93%8D%E4%BD%9C%E7%9A%84%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="浮点数操作的异常情况"><a href="#浮点数操作的异常情况" class="headerlink" title="浮点数操作的异常情况"></a>浮点数操作的异常情况</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们肯定逃不过使用<strong>double浮点型</strong>的时候,但是,如果一旦没有注意,常常会出现输出类似<strong>#IND #INF #NAN之类</strong>的奇怪输出(至少我是遇到了,贼难搞了)</p>
<h2 id="特殊浮点数的含义"><a href="#特殊浮点数的含义" class="headerlink" title="特殊浮点数的含义"></a>特殊浮点数的含义</h2><ul>
<li><p>#INF / inf：这个值表示“无穷大 (<strong>infinity</strong> 的缩写)”，即<strong>超出</strong>了计算机可以表示的<strong>浮点数的最大范围</strong>（或者说超过了 double 类型的最大值）。例如，当用 $0$ 除一个整数时便会得到一个1.#INF / inf值；相应的，如果用 $ 0 $  除一个负整数也会得到 -1.#INF / -inf 值。</p>
</li>
<li><p>#IND / nan：这个的情况更复杂，一般来说，它们来自于<strong>任何未定义结果</strong>（非法）的浮点数运算。”IND”是 <strong>indeterminate</strong> 的缩写，而”nan”是 <strong>not a number</strong> 的缩写。产生这个值的常见例子有：对负数开平方，对负数取对数，$ 0.0/0.0,0.0* \infin, \infin / \infin $ 等。</p>
</li>
</ul>
<p>简而言之，如果遇到 1.#INF / inf，就检查是否发生了运算结果溢出除零，而遇到 1.#IND / nan，就检查是否发生了非法的运算。</p>
<h2 id="特殊浮点数的判断"><a href="#特殊浮点数的判断" class="headerlink" title="特殊浮点数的判断"></a>特殊浮点数的判断</h2><p>很多 C 库都提供了一组函数用来判断一个浮点数是否是INF或 NAN。<strong>int _isnan(double x)</strong> 函数用来判断一个浮点数是否是 NAN，而 <strong>int _finite(double x)</strong> 用以判断一个浮点数是否是INF。</p>
<p>你可能已经注意到了，上面两个函数都是以下划线开头的，因此在可移植性上可能是存在问题的，那么如何实现一个通用的判断版本呢？</p>
<h3 id="对于NAN"><a href="#对于NAN" class="headerlink" title="对于NAN"></a>对于NAN</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Is_Number</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123; <span class="keyword">return</span> (X==X); &#125;</span><br></pre></td></tr></table></figure>
<p>这个操作看起来总会得到true,但神奇的是,对于<strong>IEEE 754浮点数NAN</strong>来说总是false</p>
<h3 id="对于INF"><a href="#对于INF" class="headerlink" title="对于INF"></a>对于INF</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Is_Finite_Number</span><span class="params">(<span class="keyword">double</span> X)</span> </span>&#123; <span class="keyword">return</span> (X&lt;=DBL_MAX &amp;&amp; X&gt;=-DBL_MAX); &#125;</span><br></pre></td></tr></table></figure>
<p>其中,DBL_MAX是<strong>预定义的常量</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>所以,<strong>综合运用</strong>上面的<strong>两个函数</strong>,就可以实现浮点数<strong>是否是INF</strong>的判断了</p>
]]></content>
      <tags>
        <tag>ELSE</tag>
      </tags>
  </entry>
  <entry>
    <title>牛顿迭代法</title>
    <url>/articles/%E7%89%9B%E9%A1%BF%E8%BF%AD%E4%BB%A3%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先这肯定是由<strong>Newton</strong>提出的。。。</p>
<p>这个算法主要是用来解决对于$ [a,b] $之间<strong>连续且单调</strong>的函数$ f(x) $</p>
<p>使得$ f(x)=0 $的<strong>近似解</strong>（当然这个近似需要自己<strong>手动设置</strong>）</p>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="1初始化近似解"><a href="#1初始化近似解" class="headerlink" title="1初始化近似解"></a>1初始化近似解</h3><p>我们任意取一个近似解为$ x_0 $</p>
<h3 id="2-画出-f-x0-的切线得更优解"><a href="#2-画出-f-x0-的切线得更优解" class="headerlink" title="2.画出$ f(x0) $的切线得更优解"></a>2.画出$ f(x0) $的切线得更优解</h3><p>假设我们目前的近似解是$ x<em>i $，我们画出与$ f(x) $切于点$ (x_i,f(x_i)) $的直线$ l $，将 与$ x $轴的交点横坐标记为$ x</em>{i+1} $，那么这就是一个<strong>更优的近似解</strong>。重复这个迭代的过程</p>
<p><img src="https://i.loli.net/2020/08/13/X1z5BFRpanJEeL4.png" alt="牛顿迭代法-1.png"></p>
<h3 id="3-得出更优解之间得关系"><a href="#3-得出更优解之间得关系" class="headerlink" title="3.得出更优解之间得关系"></a>3.得出更优解之间得关系</h3><p>我们重复这个迭代过程。</p>
<p>根据导数得<strong>几何意义</strong>，可得</p>
<script type="math/tex; mode=display">
f^{'}(x_i= \frac{f(x_i)}{x_i-x_{i+1}}</script><h3 id="4-得出递推式"><a href="#4-得出递推式" class="headerlink" title="4.得出递推式"></a>4.得出递推式</h3><p>因为我们知道$ f(x) $，所以可以直接化简写出<strong>递推式</strong>：</p>
<script type="math/tex; mode=display">
x_{i+1}=x_i- \frac{f(x_i)}{f^{'}(x_{i})}</script><p>因为$ f(x) $比较平滑，随着迭代次数得增多，$x_i$会<strong>越来越逼近方程的解</strong></p>
<p>至于证明，右手就行（<del>口胡</del>）</p>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>牛顿迭代法的<strong>收敛率</strong>是<strong>平方级别</strong>的，这意味着每次迭代后近似解的<strong>精确数位</strong>会<strong>翻倍</strong></p>
<p>关于其收敛性得证明可参考：<a href="http://en.citizendium.org/wiki/Newton&#39;s_method#Convergence_analysis" target="_blank" rel="noopener">citizendium - Newton method Convergence analysis</a></p>
<h2 id="基本应用"><a href="#基本应用" class="headerlink" title="基本应用"></a>基本应用</h2><h3 id="求解非负实数平方根"><a href="#求解非负实数平方根" class="headerlink" title="求解非负实数平方根"></a>求解非负实数平方根</h3><p>即：求$ f(x)=x^2-n=0 $的<strong>非负实数根</strong>，就是$ \sqrt x $的近似根</p>
<p>于是由分析可得：</p>
<script type="math/tex; mode=display">
x_{i+1}=x_i- \frac{x^2_i-n}{2 \times x_i}=\frac{x_i+ \frac{n}{x_i}}{2}</script><p>所以在实现的时候可以由自定义的精度来调整出适合的近似解</p>
<p>一般会把初始化的$x_0$设置为1.0</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-15</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Newton_sqrt</span><span class="params">(<span class="keyword">double</span> New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> X=<span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"> 		<span class="keyword">double</span> Xn=(X+New/X)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(X-Xn)&lt;Eps) <span class="keyword">break</span>;</span><br><span class="line">        X=Xn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求解整数平方根"><a href="#求解整数平方根" class="headerlink" title="求解整数平方根"></a>求解整数平方根</h3><p>即求出最接近$ x $的<strong>整数根</strong>使得$ x^2 \leq n \Rightarrow x^2-n \leq 0 $</p>
<p>这个与求解非负实数根唯一的不同就边界特判时需要稍作修改</p>
<p>即：如果$x$在迭代过程中上一次迭代值近似解变小，而这次的迭代值变大，那么我们就不进行迭代了，直接退出。（因为求的是整数解）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Newton_int_sqrt</span><span class="params">(<span class="keyword">int</span> New)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> X=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> Jud=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line"> 		<span class="keyword">int</span> Xn=(X+New/X)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(X==Xn || (Xn&gt;X &amp;&amp; Jud)) <span class="keyword">break</span>;</span><br><span class="line">        Jud=Xn&lt;X;</span><br><span class="line">        X=Xn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> X;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="高精度平方根"><a href="#高精度平方根" class="headerlink" title="高精度平方根"></a>高精度平方根</h3><p>高精度的平方根和低精度唯一的不同就是：使用高精度那么答案一定很大，若果直接设$x_0=1$那么<strong>时间复杂度</strong>上边就<strong>得不到保证</strong></p>
<p>所以，很自然就可以想到取一个绝对正确的更近似解$ x_0=2^{ \frac{1}{2}\lfloor log_2n \rfloor } $</p>
<p>具体的代码实现就免了。。。</p>
<p>当$ n=10^{1000} $时，该算法可以达到<strong>60ms</strong>，而不优化时为<strong>120ms</strong></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>(转载)写给OIer们的一些话</title>
    <url>/articles/%E8%BD%AC%E8%BD%BD-%E5%86%99%E7%BB%99OIer%E4%BB%AC%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%9D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="转载-写给OIer们的一些话"><a href="#转载-写给OIer们的一些话" class="headerlink" title="(转载) 写给OIer们的一些话"></a>(转载) 写给OIer们的一些话</h1><p>我是一个高二的OIer，离我正式退役的日子已经不超过一年了。在这个时期，与其写一些回忆性的文字，不如跳出“自我”的范畴，以一种比较全局的角度和大家一起分享一些我对OI的认知和看法。目的是让初三高一的学弟学妹看清眼前的路，让高二高三的人了解自己走过的足迹。</p>
<h2 id="一-独特的模式"><a href="#一-独特的模式" class="headerlink" title="一.独特的模式"></a>一.独特的模式</h2><h3 id="知识的更新"><a href="#知识的更新" class="headerlink" title="知识的更新"></a>知识的更新</h3><p>我们先从OI的比赛日程谈起。选手获得NOIP一等奖后，可以报名参加WC（时间为1-2月）。而在5月，选手即使没有通过省选进入省队，也可以报名参加CTS(C)。其中WC和CTS(C)不仅是信息集训队的两轮选拔，也是非集训队选手得奖的机会。而每年的WC，都会安排集训队选手和前集训队选手进行授课。每年的CTS(C)，会安排候选队选手（去年是候选队前6）来进行英语自我介绍和论文答辩，这一项的分数是要按一定权重计入集训选拔分数的。对于一个集训队选手来说，他不仅需要完成题目，还必须写一篇关于集训队作业某些题的解题报告，甚至可能需要写命题报告。如果他进入候选队，那么他必须写一篇候选队论文。有时候选队15人会组成小组互相出题给对方做，这被称为候选队互测。</p>
<p>撇去“收钱”的原因，为什么CCF要这么安排？因为CCF明白<strong>OI的知识范围的更新只能靠水平较高的优秀选手来完成，之后服务OI的主力军也是他们</strong>，而WC和CTS正是新的知识点向各个选手普及的过程。例如：2008年陈丹琪论文中出现了cdq分治，WC2012的陈立杰的《后缀自动机》讲稿，在2013候选队论文《浅谈数据结构的几个非经典解法》中出现的二进制分组的思想，在2015集训队论文出现的多项式求逆、ln、exp等技巧，以及在2019年WC讲授的模拟费用流问题。硬性规定的解题报告、命题报告，是对他们之后出题工作的一个很好的训练。</p>
<p>那些新潮的知识点会借助互联网的平台逐步往下传。一开始在那些大佬们的博客中出现，然后是一些高层次的比赛的题目（比如WC，CTS），接着是很多强校的模拟赛，最后就是NOI、省选、NOIP的真题了。在传递过程中，这些idea会经历一定时间的考验和衡量。最后我们留下那些能简化代码量的、对某些问题非常适用的、具有考察价值的知识点，在1-5年的时间内成为我们必须要学习的内容。</p>
<p>这样的安排无疑带来了非常好的效果，给OI的知识体系增添了活力。唯一美中不足的是：缺少能看懂候选队论文的评委。每次答辩的时候，评委总是会问一些质量不高、无关紧要的问题。也许是因为CCF也知道这一点，除了一些极端情况外，候选队论文答辩的分数不影响最终国家队的名单。</p>
<h3 id="命题的故事"><a href="#命题的故事" class="headerlink" title="命题的故事"></a>命题的故事</h3><p>那些集训队选手毕业后一部分会加入清华或北大的算法协会，在1-5年后成为比赛出题人。命题的工作需要寻找一个“灵感”，就是这道题的核心想法。在那之后还要经历撰写题面，编写标程，设计部分分，验证数据正确性和强度等一系列步骤才能真正完成一道题目的命制过程。一般而言，为NOI系列赛事命题有数百至上千元的报酬，但这些费用只是一种“辛苦费”。<strong>如果单从功利的角度来说，讲课或者专心学术是更好的选择。他们这么做完全是出自于一种对于OI的情怀。</strong></p>
<p>但命题质量和数量的保障，甚至保密性都只能由他们自己来保证。如果在NOI附近正好处于出题人们idea的枯竭期，那么NOI的质量势必不高。如果出题人正好要准备大学的期中考试等事情，那么他很难全副身心地去做出题的工作。就算出题人很用心的出了一道题，但是这道题也有可能因为难度不合适等问题而不适合出现在比赛中。也可能是因为这些原因，OI历史上出现过很多设计不合理的比赛。ZJOI2018的难度过高、区分度过低，CTSC2018的题目出错，NOIP2018的原题现象，CTS2019的知识点分布不合理都是鲜活的例子。</p>
<p>改进质量的方法，很大程度上仰仗于OIer与命题人的反馈交流，迫使出题人做出调整。你会在知乎上看到“如何评价xxxx（某比赛）”问题，就是出题人与选手的互动。底下这些评论往往表达选手的做题体验和出题人的出题经历，例如 [1]。最近还出现一些选手在自己出模拟赛的过程中探讨出题的准则，比如 [2] 。 出题人了解某道题的得分情况和选手对这道题的评价后，他才能了解选手的普遍水平，才能了解哪些类型的题是对当下选手最具有考察价值的。在2017年某个出题人出过一道名为《挑战》的题，正解是使用底层优化（卡常）使理论复杂度很高的算法通过匪夷所思的范围$ (O(n^2) $跑$ 3e5,O(n) $跑$ 2e8) $。这场比赛当天该题被批判的声音就层出不穷了。之后这位出题人出的题，质量就有了很大的改观。</p>
<h3 id="学习的过程"><a href="#学习的过程" class="headerlink" title="学习的过程"></a>学习的过程</h3><p>作为一个选手，你最关心的可能是学习OI的过程。在NOIP提高组以下的层面，学习知识点可以通过看书，但是在这以上，尤其是针对较新的知识点的学习，就要依靠网上的博客了。博客一般是由现役的选手来完成的。但博客的质量鱼龙混杂，良莠不齐，你在百度上搜lct，10篇里面有6篇的findroot后没有splay。即使是水平较高的选手，他们写的题解也不一定能让别人容易看懂，很多时候简略到只有一句话。一个普遍的问题是讲解知识点或题目的时候单单着重于结论、算法过程，没有把这个结论为什么是正确的、这个算法为什么要想到这两个问题讲清楚。[3] 表达了和我类似的想法。你有时看到题解大呼”太巧妙了”，“太神仙了”，其实是因为没有体会到思考的全过程。为了解决博客质量的问题，我们建立了OI-wiki，shareOI，洛谷的题解拥有严格的审核机制。</p>
<p>洛谷、LOJ、UOJ上的学习资料是免费的，网上的博客是可以直接搜到的，是面对所有OIer的。在这个资源共享化的时代，你只要肯下功夫学，就有丰富的资料和题目可供学习。这一定程度上拉平了强校与弱校的差距。但是由于我上一段提到的原因，学习不能完全依靠于博客等资料，需要有选手来带，需要有优质的模拟题来增加比赛经验。往往只有强校能请的了上一届的优秀选手、教练来讲课，能拥有不对外公开的模拟题和OJ，所以强校与弱校的差距也将长期存在。</p>
<p>另一个重要的方面是讲课，这一工作也由高水平选手承担。讲课一种是在机构受聘讲课，另一种是在自己的母校讲课（这种包括现役选手和退役选手）。前者的特点是受惠面积广，能够让更多人学习。后者的特点是学生较少，容易通过调整自己的讲课方式来满足本校学生的需求。相比于前者，后者带有更多的自愿性。前者推动了OI资源的共享，而后者起到推动一个学校发展的作用。这并不是说前者优于后者或后者优于前者，事实上两者都是必不可少的。特别是对我们学校来说，让上一届去带下一届是向外省强校追赶的必不可少的环节。而一个小集体的发展与一个大集体的发展是相互联系的，有时一个学校的优秀选手可以带动一个省的崛起。</p>
<h3 id="一条从未走过的路"><a href="#一条从未走过的路" class="headerlink" title="一条从未走过的路"></a>一条从未走过的路</h3><p>OI的知识与我们小学中学所学的东西是无关的，甚至与大学所学的算法和主流的计算机科学界关系都不是很大，它是一个相对独立而封闭的体系。我们缺少完全理解OI知识体系的老师，我们缺少能够长期命题的出题人，我们缺少专业的研究者。我们面临了种种不利的客观条件，这些是其它四大竞赛所没有的困难。</p>
<p>但我们不曾放弃，我们不曾退缩。我们竭尽全力探索出一种符合OI竞赛特点的模式。这往大里说，是“计算机普及要从娃娃抓起”的践行；往小里说，是为适应时代做出的努力。</p>
<p>我们终究探索出了一条从未走过的路，那便是<strong>以OIer本身为主导的OI模式！</strong>我们用已经培养出来的OI选手去担任知识引入、命题、授课的工作，用上一届OIer带动下一届OIer，再让下一届带动更下一届。我们借助互联网的平台，发挥它传播信息迅速的优势，把所有的OI选手们连接成一个整体。把而竞赛教练的作用，更多的是去维持这种模式，带动这种模式。</p>
<p>这样的模式是偏向于“用爱发电”的，它的核心基础是<strong>OIer们对OI本身持久的情怀</strong>。它的优点是让OI界具有很强的活力，给选手学习很大的自由度，也对OI的过度商业化，功利化形成了很好的保护。它也使得”OIer群体“这个概念有了很大的地位。</p>
<p>不过也容易想到它是脆弱的、不成熟的，在前面你可以看到它的缺陷。一旦OIer们全都由于一些现实上的原因没有继续服务于OI，必然会使这个体系有崩塌的风险。但它具有很强的<strong>不可替代性</strong>，无论是知识引入还是出题、授课，都只有OIer能胜任。这种模式在现实条件下几乎是唯一的解，所以它是很难撼动的。所以我们应该想的是<strong>在方式方法层面上做一些改进</strong>，让OI的未来变得更好。</p>
<h2 id="二-OIer的价值"><a href="#二-OIer的价值" class="headerlink" title="二.OIer的价值"></a>二.OIer的价值</h2><h3 id="开拓者"><a href="#开拓者" class="headerlink" title="开拓者"></a>开拓者</h3><p>你打开OJ，思考一道题目。你满足于OJ页面的精致，你陶醉于算法世界的美妙。你可曾想过这些题目是谁出出来的，你可曾想过OJ的搭建和维护者是谁？他们是某一个特别的OIer的群体。他们中有洛谷的创办者kkksc03，LOJ的创办者menci和UOJ的创办者vfk。</p>
<p>你可以从 [4]、[5] 和 [6] 中窥探出当年他们创办UOJ、LOJ的一些理念。我们在第一篇文章中截取两段：</p>
<p>“不得不说今天是个伤感的夜晚。我们此时站在这里，连接过去和未来。曾以为我们的计划会成为我们的未来，却不知道大浪拍击沙滩的力量比飓风更有力。UOJ从哪里来？今晚的UOJ还是一年前发布时的那个UOJ吗？为什么我们慢慢忘了那最虔诚的最初，渐行渐远……于是我意识到，我们应该回去，回头看看那最初的原点。最初我是怀着对OI界题目的不满，最初我和业界毒瘤有很多比较难的脑洞想出给大家玩，最初的最初是那场引发我对OI比赛的思考的NOI2013……我们想建立的是，一个能自由评测各种类型题目的OJ，一个题题高质量的OJ，一个定期举办高质量的比赛的OJ —— 一个能带给OIer思考与收获的OJ。”</p>
<p>“我想起了我最初的一句’宁缺毋滥’，我想起了激励了我很长时间的洛克菲勒与协和医院的故事：我们要以最高标准建一所医院，成为中国医学界的一座标杆 —— 而我们清楚地知道，论题目的数量，世界上千万万OJ不缺我们UOJ一家，我们要做的就是聚集最优秀最热爱信息学的OIer，建立一个题目质量难以企及的OJ。”</p>
<p>500多道UOJ题目，上千道LOJ题目，数万个OIer……今天你会看到各个学校的OJ如雨后春笋般增长，就归功于他们用一行行代码缔造的平台。今天你会听到OIer对比赛、对题目的广泛讨论，而那些新潮的想法其实来源于vfk在那几篇博客上阐述的”好题“、“毒瘤题”的定义。今天我们从自己的成长之路向前追朔，也总能够追朔到他们的所创造的资源。</p>
<p>他们是灯塔，他们是引路人。他们开拓了一条OI资源共享化的道路，他们以数十人之力创造了数万人的价值。在之后的社会上，你很难看到像他们一样完全坚持自己的初心、梦想，无私地奉献自己的一切而不求任何回报的人了。我们希望他们的那些文字能够在OI的历史上熠熠生辉。</p>
<h3 id="不可或缺的角色"><a href="#不可或缺的角色" class="headerlink" title="不可或缺的角色"></a>不可或缺的角色</h3><p>诚然，我们很难像他们一样对整个OI界做出很大的贡献，对他们的态度也只是停留在“虽不能至，心向往之”的层面。那么我们的价值又在何处呢？</p>
<p>很多学校的教练都会在我们还是初三或高一时请高二的学长给我们来讲课。一年过后，我们欢送他们退役，但我们站在他们的肩膀上，经过各种比赛的磨练，使自己变得更强。当我们磨练得差不多时候，我们就成了学长，就被要求给下一届的学弟学妹们讲课。WC2018的两首改编歌词《我的一个OIer朋友》，《退役的你》（详见 [7] 、 [8] ）是这段时光的真实写照。我们从第一首里面截取一段：</p>
<blockquote>
<p>“他们说的退役太沉重，你在路上追着你的梦。                                     </p>
<p>​         前路会与过往不同，但精彩纷呈。                                    </p>
<p>而我深夜刷题至三更，大赛过后睡眼正惺忪。                                    </p>
<p>恍然之间终于看懂，当年你笑容，谈何轻松？                                    </p>
<p>不如将你镌刻在心中，以足迹为路以背影为灯。                                    </p>
<p>​       去年今日你的歌声，由我来传承……”</p>
</blockquote>
<p>在这一段OI的旅途中，我们送走了一批人，又迎接了新的一批人。 我们把从学长那里得到的东西，经过自己的再加工、再整理，传递给下一届，然后由知识的接受者变为了知识的传播者。我们成了手握接力棒的人，成了连接过去和未来的人。这段旅途中难免有送别的伤感，但薪火相传的使命与责任，才是主旋律。</p>
<p>如果我们中出现了一个优秀选手，那么就会产生更大的贡献。一是会吸引更多的OIer来这所学校学习，然后进一步提高下一届选手的水平。比如我在初三时选择进入华二而非上中，是因为看到2017年华二CMO进了5个集训队，而上中只进了一个。二是会使整个省的目标提高，进而带动整个省的水平。在2016年前，可能上海的目标是争取更多银牌选手。但因为像吕时清、何文阳之类的优秀选手出现，特派员开始朝着金牌这个目标努力了。他会亲自那些不错的OIer下发题目，亲自评测、会在NOIP/CSP前安排几次针对全市选手的模拟赛，会请外省的集训队选手来讲课。最终上海在CTS，APIO，NOI上实现了这一目标。</p>
<p>哪怕你只是初二、初三、高一的OIer，还没有达到给学弟学妹讲课的阶段，你也会不知不觉中影响很多人。在这个资源高度共享的时代，你不经意间说的话，写的东西就可能会被数百人看到，然后数百人传给更多人。就像我博客里面写的“JOISC 2020自闭记”，阅读量已经达到了530人，而我认识的OIer也不过100人。也许这530人还会传给他们的朋友、他们的下一届选手，说不定就有1000人直接或间接地看到了我写的题解了。</p>
<h3 id="另一种价值"><a href="#另一种价值" class="headerlink" title="另一种价值"></a>另一种价值</h3><p>由于OI竞赛本身这种独特的模式，OIer群体的概念与个体的概念，拥有同等的地位。所以一个OIer在他的生涯中，不仅存在个人价值（比如拿一等奖，进省队，进集训队），还存在着另一种价值，那便是个人对OIer群体的价值。</p>
<p>很多时候实现个人价值也是实现这种价值，这种价值是个人价值的延续，因为高水平选手给OI界可能创造的价值越多。但和个人价值不同的是，这种价值所影响的时间更长，所影响的范围更广。也许我们退役过后，我们所获得的奖项，只是OIerdb上那一条条数字了。<strong>个人价值是一个OIer退役后所带走的，但这种价值是一个OIer退役后留下的东西</strong>，它是不会过时的。你为你身边的OIer所做的事情，像是埋下一粒种子，它会在几年之内生根、发芽，长成一棵大树，甚至繁殖出更多的生命。vfk那一代的OIer很难想到他所创办的UOJ能使这么多人受益，王聿中、吕时清、王润泽那一代的OIer也没有想到他们的努力会使上海在NOI2019进入3个集训队。但这一切，都在不久的将来发生了。</p>
<p>所以我们在学习知识之余，也要想一想我能为我身边的OIer做些什么，我能为整个学校做些什么，我能为整个市做些什么，我能为整个OI界做些什么？知识层面上的贡献有：出题、讲课、写论文等。另一种贡献是文、史、哲层面上的，比如Tangenter写《整型溢出》一书整理2016-2019年的OI历史。即使我们还没有达到为别的OIer做事情的阶段，我们也要了解别人给OI界带来的贡献，我们也要对那些为我们付出过的前辈们怀以感激，怀以敬意。</p>
<h2 id="三-渺小而卑微的坚持"><a href="#三-渺小而卑微的坚持" class="headerlink" title="三.渺小而卑微的坚持"></a>三.渺小而卑微的坚持</h2><p>时间、运气、命运对OIer们来说是残酷的字眼。再强的OIer，也有退役的时刻。再努力的OIer，也难以保证他在省选或NOI一定能够有和他的付出对等的回报。这是很多OIer心知肚明的事实，也是我们无力感的根源。</p>
<p>也正因为此，有的人选择了把OI当成生命中的过客，没有对它付出过多的精力和情感。但另外一些人仍然把OI当作自己的归宿，甚至当成生活的全部。究其原因，是因为他们给OI这个词赋予了太多的意义和价值。</p>
<p>他们坚持停课，坚持与班主任老师、甚至家长“对抗”，坚持自己心中的目标。他们舍弃了睡觉时间来打cf，舍弃了文化课来刷模拟赛。有时，他们要面对的是孤独、不理解和对自己前途的恐惧。你可以说，这是坚持、执着、勇往直前，但在命运面前，这是渺小、卑微的。一场考试的结果是难以预料的，一个字符之差就可能是100分与0分之差，一个部分分之差就可能是20多名的差距。最勤奋的人，也不敢说，自己能够掌握自己的未来。</p>
<p>OIer之外的人对他们有两种极端的态度。一种是以竞赛的风险为理由，劝说（甚至逼迫）他们放弃OI竞赛而去搞高考。这些人否认OI给他们带来的意义，没有看到他们在OI方面的付出。也许从数学期望的角度，这是较优解，我们不必做过多的批判。但这种态度杀灭了他们的纯粹的梦想，给他们的青春留下无法抹去的遗憾，甚至伤痕。另一种是盲目地支持，为了走这条路而断绝他们的一切后路，放弃一切OI之外的事务。人不是机器，过度的、长时间的投入是否会产生和这种投入成正比的收获，是不好说的。即使成功了，它能否补偿他们所失去的东西，也是不好说的。这种态度产生的根源是没有客观地认识到OI的风险，把竞赛和高考的两套评价体系完全地割裂开来，甚至当成对立面。</p>
<p>我们应有的态度是怎样的呢？应该是一个朋友的角色。我们可以在他们考砸的时候予以安慰，可以在他们考好的时候予以鼓励。我们可以和他们一起讨论题目，一起学习算法，一起打模拟赛，甚至在空闲时刻聊一些游戏、漫画的内容。我们既要提供助力他们成功的实质性帮助，也要想方设法缓解他们的压力感和孤独感。当然，我个人认为，不必对他们的选择做过多的干预，因为我们很难完全理解他们的内心想法，很难影响也不应去影响他们的命运。至于决定他们是选择坚持还是放弃，应该是老师和家长所做的事情。</p>
<p>如果你觉得他们离你很遥远，<strong>请你不要像某些人一样用好坏利弊简单地评判他们的选择，请你不要抱着“与我无关”的态度。</strong></p>
<p><strong>如果你正好就是那些选择孤注一掷的OIer，请你相信有无数的OIer是支持你的，请你相信你的付出终将会在某个时刻回报你，请你相信无论怎样，你在这个过程中成长了、收获了。但也要告诉你，既然有勇气坚持走下去，也要有勇气承担它带来的一切结果。</strong></p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实我写这篇博客的想法，可以追溯到北大集训期间LCA给我们讲的一些话。在他的讲话过后，我了解到了OI diary，我了解到了OI survey。我看到了有一位前OIer去主动地查找资料，以一个选手的视角记录前几年OI界发生的事情，甚至有一个人想编撰一部完整的OI史。我发现OIer们做了很多学习知识之外的事情，例如对自身价值的探索，对学习竞赛的意义、乃至生命的意义的探讨。这种东西既体现在某一小群OIer所写的长篇的文章里面，又渗透到了很多OIer博客里的随感。于是我也对OI界的一些现状做了简单的思考，整理成了这篇博客。</p>
<p>如果从写文章的角度来说，第一、第二节可以构成一个完整的主题，而第三节显得有点画蛇添足。但是在我身边真的有很多选择孤注一掷地搞OI的人，其实在我的学校里就有，而他们面临的环境并不乐观。我特别想为他们说一些话，却不知道何时能说，却不知道从何说起。所以我就在这个机会为他们说出我的心里话。</p>
<p>最后，感谢你能够读完这篇博客，也希望这份思想的火炬永不熄灭！</p>
]]></content>
      <tags>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>计算几何选讲</title>
    <url>/articles/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95%E9%80%89%E8%AE%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="计算几何选讲"><a href="#计算几何选讲" class="headerlink" title="计算几何选讲"></a>计算几何选讲</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信大家都已经<strong>很熟悉</strong>这些知识点了，我们就<strong>简要说明</strong>一下即可</p>
<p>对于计算几何，其实<strong>原理</strong>都<strong>很简单</strong>，只是比较难想。</p>
<h2 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>在平面上能<strong>包含所有给定点</strong>的<strong>最小凸多边形</strong>叫做<strong>凸包</strong>。</p>
<p>或：对于给定集合$X$，所有包含$ X $的<strong>凸集的交集</strong>$S$被称为$X$的 <strong>凸包</strong> 。</p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>常用算法为<strong>Graham扫描法</strong>和<strong>Andrew算法</strong>。</p>
<p>对Graham扫描法有兴趣的大佬可以自行了解一下</p>
<p><strong>蒟蒻</strong>我只学过Andrew算法。。。</p>
<h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>凸包是一个凸多边形，证明显然</p>
<p><img src="https://i.loli.net/2020/08/15/HP1Kd9MoyOitrwq.png" alt="计算几何选讲-1.png"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>将所有的平面点<strong>按照</strong>$x$大小来排序</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>将$ p_1,p_2 $放入凸包，从$p_3$开始，若当前点在<strong>栈顶两点</strong>所在直线的左侧，则加进栈，否则弹出栈顶，接受新点</p>
<p>参考上边的图</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P2742</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">1e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Top,Stack[MAXn],Ans;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXn];</span><br><span class="line"><span class="keyword">double</span> Res;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> Fir,Sec;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) &#123; </span><br><span class="line">		<span class="keyword">if</span>(A.Fir==B.Fir) <span class="keyword">return</span> A.Sec&lt;B.Sec; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> A.Fir&lt;B.Fir;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Num[MAXn],Bag[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node X,Node Y)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">double</span>)<span class="built_in">sqrt</span>((<span class="keyword">double</span>)(X.Fir-Y.Fir)*(X.Fir-Y.Fir)+(<span class="keyword">double</span>)(X.Sec-Y.Sec)*(X.Sec-Y.Sec)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Node X,Node Y)</span> </span>&#123; <span class="keyword">return</span> X.Fir*Y.Sec-X.Sec*Y.Fir; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Side</span><span class="params">(Node X,Node Y,Node Z)</span> </span>&#123; </span><br><span class="line">    Node A=Node&#123;Y.Fir-X.Fir,Y.Sec-X.Sec&#125;;</span><br><span class="line">    Node B=Node&#123;Z.Fir-X.Fir,Z.Sec-X.Sec&#125;;</span><br><span class="line">    <span class="keyword">return</span> Cross(A,B);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Num[i].Fir,&amp;Num[i].Sec);</span><br><span class="line">    sort(Num+<span class="number">1</span>,Num+Total+<span class="number">1</span>); Top=<span class="number">0</span>;</span><br><span class="line">    Stack[++Top]=<span class="number">1</span>;</span><br><span class="line">    FOR(i,<span class="number">2</span>,Total) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Top&gt;=<span class="number">2</span> &amp;&amp; Side(Num[Stack[Top<span class="number">-1</span>]],Num[Stack[Top]],Num[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">        Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Temp=Top;</span><br><span class="line">    BOR(i,Total<span class="number">-1</span>,<span class="number">1</span>) </span><br><span class="line">        <span class="keyword">if</span>(!Vis[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(Top&gt;Temp &amp;&amp; Side(Num[Stack[Top<span class="number">-1</span>]],Num[Stack[Top]],Num[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">            Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Top<span class="number">-1</span>) Res+=Distance(Num[Stack[i]],Num[Stack[i+<span class="number">1</span>]]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>,Res);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="旋转卡壳"><a href="#旋转卡壳" class="headerlink" title="旋转卡壳"></a>旋转卡壳</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>旋转卡壳可以用于求<strong>凸包的直径、宽度，两个不相交凸包间的最大距离和最小距离等</strong></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p><img src="https://i.loli.net/2020/08/15/zr5DjhAw3MWV1lN.gif" alt="计算几何选讲-2.gif"></p>
<p>被一对卡壳正好卡住的对应点对称为<strong>对踵点</strong></p>
<p>可以证明对踵点个数<strong>不会超过$ \frac{3}{2} N $个</strong>，也就是说对踵点个数是$O(N)$的</p>
<p>所以，我们可以模仿凸包的<strong>栈思想</strong></p>
<p>因为，每次最优解必然存在于对踵点对集合中</p>
<p><img src="https://i.loli.net/2020/08/15/LKQ6JRl9WjHU5X7.png" alt="计算几何选讲-4.png"></p>
<p>所以每次比较</p>
<p><img src="https://i.loli.net/2020/08/15/uP8v3ziGJnBfpQr.png" alt="计算几何选讲-3.png"></p>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1452 POJ 2187</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">5e4</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sign</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(Temp)&lt;Eps ? <span class="number">0</span> : (Temp&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (Point A,Point B) &#123; Point Temp; Temp.X=A.X-B.X; Temp.Y=A.Y-B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> + (Point A,Point B) &#123; Point Temp; Temp.X=A.X+B.X; Temp.Y=A.Y+B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> * (<span class="keyword">double</span> A,Point B) &#123; Point Temp; Temp.X=A*B.X; Temp.Y=A*B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> * (Point A,Point B) &#123; <span class="keyword">return</span> A.X*B.X+A.Y*B.Y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> ^ (Point A,Point B) &#123; <span class="keyword">return</span> A.X*B.Y-A.Y*B.X; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Point A,Point B) &#123;</span><br><span class="line">        <span class="keyword">return</span> A.X!=B.X ? A.X&lt;B.X : A.Y&lt;B.Y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Dot[MAXn];</span><br><span class="line"><span class="keyword">int</span> Total,Top,u,v,w,Cnt=<span class="number">2</span>,Stack[MAXn];</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXn];</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Point A,Point B,Point T)</span> </span>&#123; <span class="keyword">return</span> (B-A)^(T-A); &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> Temp*Temp; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Point A,Point B)</span> </span>&#123; <span class="keyword">return</span> (Power(A.X-B.X)+Power(A.Y-B.Y)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Andrew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stack[++Top]=<span class="number">1</span>;</span><br><span class="line">    FOR(i,<span class="number">2</span>,Total) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Top&gt;=<span class="number">2</span> &amp;&amp; Cross(Dot[Stack[Top<span class="number">-1</span>]],Dot[Stack[Top]],Dot[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">        Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Temp=Top;</span><br><span class="line">    BOR(i,Total<span class="number">-1</span>,<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!Vis[i]) &#123;</span><br><span class="line">            <span class="keyword">while</span>(Top&gt;Temp &amp;&amp; Cross(Dot[Stack[Top<span class="number">-1</span>]],Dot[Stack[Top]],Dot[i])&lt;=(<span class="keyword">double</span>)<span class="number">0</span>) Vis[Stack[Top--]]=<span class="literal">false</span>;</span><br><span class="line">            Vis[i]=<span class="literal">true</span>; Stack[++Top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[i].X,&amp;Dot[i].Y);</span><br><span class="line">    sort(Dot+<span class="number">1</span>,Dot+Total+<span class="number">1</span>);</span><br><span class="line">    Andrew();</span><br><span class="line">    FOR(i,<span class="number">1</span>,Top<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Cross(Dot[Stack[i]],Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt]])&lt;Cross(Dot[Stack[i]],Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt+<span class="number">1</span>]])) &#123; Cnt++; <span class="keyword">if</span>(Cnt&gt;Top<span class="number">-1</span>) Cnt=<span class="number">1</span>; &#125;</span><br><span class="line">      Ans=<span class="built_in">max</span>(Ans,<span class="built_in">max</span>(Distance(Dot[Stack[i]],Dot[Stack[Cnt]]),Distance(Dot[Stack[i+<span class="number">1</span>]],Dot[Stack[Cnt]])));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.0lf\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="半平面交"><a href="#半平面交" class="headerlink" title="半平面交"></a>半平面交</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一条直线和直线的一侧。半平面是一个<strong>点集</strong>，因此是一条直线和直线的一侧构成的点集。当包含直线时，称为<strong>闭半平面</strong>；当不包含直线时，称为<strong>开半平面</strong>。</p>
<p>解析式类似于<strong>线性规划</strong>$ \Rightarrow Ax+By+X \geq 0 $</p>
<p>通常会<strong>统一</strong>以向量的左侧或者右侧作为半平面</p>
<p><img src="https://i.loli.net/2020/08/15/eSgtrfZN4R6dbLx.gif" alt="计算几何选讲-5.gif"></p>
<h3 id="思想-1"><a href="#思想-1" class="headerlink" title="思想"></a>思想</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>我们维护每一条直线为一个向量，并利用函数<strong>atan2(double y,double x)</strong>，返回$ \theta \in (- \pi,\pi], \theta=arctan \frac{y}{x} $</p>
<p>进行<strong>极角排序</strong>，得到新的边集</p>
<p>温馨提示：</p>
<p>排序时，如果遇到<strong>共线向量</strong>（且方向相同），则取<strong>靠近可行域</strong>的一个。比如两个向量的极角相同，而我们要的是向量的左侧半平面，那么我们只需要保留左侧的向量。判断方法是取其中一个向量的起点或终点与另一个比较，检查是在左边还是在右边。</p>
<h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>我们维护一个<strong>单调队列</strong></p>
<p>即维护一个凸壳，同理，进行队首队次首和新直线的对比</p>
<p>当然，我们维护一个<strong>交点数组</strong></p>
<p>对于当前向量，如果上一个交点在这条向量表示的半平面交的 <strong>异侧</strong> ，那么上一条边就没有意义了。</p>
<p><img src="https://i.loli.net/2020/08/15/W7bLrfyn2RgG1q9.png" alt="计算几何选讲-6.png"></p>
<h4 id="注"><a href="#注" class="headerlink" title="注"></a>注</h4><p>当出现一个可以把队列里的点<strong>全部弹出去</strong>的向量（即所有队列里的点都在该向量的右侧），则我们 <strong>必须</strong> <strong>先处理队尾，再处理队首</strong>。因此在循环中，我们先枚举 <code>--r;</code> 的部分，再枚举 <code>++l;</code> 的部分，才不会错。原因如下。</p>
<p><img src="https://i.loli.net/2020/08/15/WjdGPueO41YngFk.png" alt="计算几何选讲-7.png"></p>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4196</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;windows.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXn=<span class="number">5e2</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Eps=<span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Head=<span class="number">1</span>,Tail=<span class="number">0</span>,Cnt,Side,Tot;</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> - (Point A, Point B) &#123; Point Temp; Temp.X=A.X-B.X; Temp.Y=A.Y-B.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> + (Point A, Point B) &#123; Point Temp; Temp.X=B.X+A.X; Temp.Y=B.Y+A.Y; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> * (Point A, Point B) &#123; <span class="keyword">return</span> A.X*B.X+A.Y*B.Y; &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">double</span> <span class="keyword">operator</span> ^ (Point A, Point B) &#123; <span class="keyword">return</span> A.X*B.Y-A.Y*B.X; &#125;</span><br><span class="line">    <span class="keyword">friend</span> Point <span class="keyword">operator</span> * (<span class="keyword">double</span> K, Point B) &#123; Point Temp; Temp.X=B.X*K; Temp.Y=B.Y*K; <span class="keyword">return</span> Temp; &#125;</span><br><span class="line">&#125;Dot[MAXn];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sign</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">fabs</span>(Temp)&lt;=Eps ? <span class="number">0</span> : (Temp&gt;<span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>); &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    Point S,E;</span><br><span class="line">    <span class="keyword">double</span> Slope;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A, Node B) &#123;</span><br><span class="line">        <span class="keyword">return</span> Sign(A.Slope-B.Slope)==<span class="number">0</span> ? Sign((A.E-A.S)^(B.E-A.S))&gt;<span class="number">0</span> : Sign(A.Slope-B.Slope)&lt;<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;Line[MAXn],Mine[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Point <span class="title">Inter</span><span class="params">(Node A,Node B)</span> </span>&#123;</span><br><span class="line">    Point S1=A.S,S2=B.S,E1=A.E,E2=B.E;</span><br><span class="line">    E1=E1-S1,E2=E2-S2;</span><br><span class="line">    Point Temp=S2-S1;</span><br><span class="line">    <span class="keyword">return</span> S2+((Temp^E1)/(E1^E2))*E2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">inline Point Inter(Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">    Point S1=A.S,S2=B.S,E1=A.E,E2=B.E;</span></span><br><span class="line"><span class="comment">    E1=E1-S1;E2=E2-S2;</span></span><br><span class="line"><span class="comment">    Point Temp=S2-S1;</span></span><br><span class="line"><span class="comment">    return S2+((Temp^E1)/(E1^E2))*E2;</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(Node A,Node B,Node X)</span> </span>&#123;</span><br><span class="line">    Point Temp=Inter(A,B);</span><br><span class="line">    <span class="keyword">return</span> Sign((X.E-X.S)^(Temp-X.S))&lt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Half_Plane</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sort(Line+<span class="number">1</span>,Line+Cnt+<span class="number">1</span>); </span><br><span class="line">    FOR(i,<span class="number">1</span>,Cnt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Sign(Line[i].Slope-Line[i<span class="number">-1</span>].Slope)!=<span class="number">0</span>) Tot++;</span><br><span class="line">        Line[Tot]=Line[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Mine[++Tail]=Line[<span class="number">1</span>];Mine[++Tail]=Line[<span class="number">2</span>];</span><br><span class="line">    FOR(i,<span class="number">3</span>,Tot) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Tail<span class="number">-1</span>],Mine[Tail],Line[i])) Tail--;</span><br><span class="line">        <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Head+<span class="number">1</span>],Mine[Head],Line[i])) Head++;</span><br><span class="line">        Mine[++Tail]=Line[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Tail<span class="number">-1</span>],Mine[Tail],Line[Head])) Tail--;</span><br><span class="line">    <span class="keyword">while</span>(Head&lt;Tail &amp;&amp; Check(Mine[Head+<span class="number">1</span>],Mine[Head],Line[Tail])) Head++;</span><br><span class="line">    Mine[Tail+<span class="number">1</span>]=Mine[Head]; Cnt=<span class="number">0</span>;</span><br><span class="line">    FOR(i,Head,Tail) Dot[++Cnt]=Inter(Mine[i],Mine[i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Side);</span><br><span class="line">        FOR(j,<span class="number">1</span>,Side) <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[j].X,&amp;Dot[j].Y);</span><br><span class="line">        Dot[Side+<span class="number">1</span>]=Dot[<span class="number">1</span>];</span><br><span class="line">        FOR(j,<span class="number">1</span>,Side) Line[++Cnt]=Node&#123; Dot[j],Dot[j+<span class="number">1</span>] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Cnt) &#123; Line[i].Slope=<span class="built_in">atan2</span>(Line[i].E.Y-Line[i].S.Y,Line[i].E.X-Line[i].S.X); &#125;</span><br><span class="line">    Half_Plane();</span><br><span class="line">    Dot[Cnt+<span class="number">1</span>]=Dot[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(Cnt&gt;<span class="number">2</span>) FOR(i,<span class="number">1</span>,Cnt) Ans+=(Dot[i]^Dot[i+<span class="number">1</span>]);</span><br><span class="line">    Ans=<span class="built_in">fabs</span>(Ans)/<span class="number">2.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>递归求逆元</title>
    <url>/articles/%E9%80%92%E5%BD%92%E6%B1%82%E9%80%86%E5%85%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性求逆元"><a href="#线性求逆元" class="headerlink" title="线性求逆元"></a>线性求逆元</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个内容只是作为一个补充,所以就<strong>简要</strong>记录一下</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>如果对于每个数都进行<strong>单次求解逆元</strong>$ O(nlog(mod)) $,当$n$<strong>非常大</strong>的时候,当然就不行了,所以此时需要进行$ O(n) $<strong>快速求解</strong></p>
<h2 id="推导"><a href="#推导" class="headerlink" title="推导"></a>推导</h2><p>１.首先很显然由<strong>费马小定理</strong>知$ 1^{-1} \equiv 1 (mod\,\,\,p) $</p>
<p>２.然后,设$ p=ki+j,j&lt;i,1&lt;i&lt;p $,再放到$ mod\,\,\,p $意义下就会得到:$ ki+j \equiv 0 (mod\,\,\,p) $</p>
<p>３.两边<strong>同时乘</strong> $ i^{-1},j^{-1} $</p>
<p>４.可得:</p>
<script type="math/tex; mode=display">
kj^{-1}+i^{-1} \equiv 0 (mod\,\,\,p) \\
i^{-1} \equiv -kj^{-1} (mod\,\,\,p) \\
i^{-1} \equiv -( \frac{p}{i}) (p\,\,\,mod\,\,\,i)^{-1}</script><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">FOR(i,<span class="number">2</span>,Limit) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;</span><br></pre></td></tr></table></figure>
<h2 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h2><ul>
<li><p>使用$ p- \frac{p}{i} $是为了<strong>防止出现负数</strong></p>
</li>
<li><p>根据线性求解逆元的方法的式子:$ i^{-1} \equiv -kj^{-1} (mod\,\,\,p) $ </p>
<p>可以<strong>递归</strong>求解就$ j^{-1} $,直到$ j=1 $<strong>直接返回1</strong></p>
<p>中间优化可以加入<strong>记忆化</strong>来避免多次递归导致重复,这样求解$ 1,2, \cdots,n $所有的数时间<strong>复杂度</strong>还是$ O(n) $</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>随机增量法</title>
    <url>/articles/%E9%9A%8F%E6%9C%BA%E5%A2%9E%E9%87%8F%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随机增量法"><a href="#随机增量法" class="headerlink" title="随机增量法"></a>随机增量法</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>随机增量法</strong>是一个有手就行的算法,对<strong>理论知识的要求不高</strong>,且算法的<strong>时间复杂度低</strong>,<strong>应用范围广</strong></p>
<p><strong>增量法</strong>思想与<strong>数学归纳法</strong>相似,<strong>本质</strong>是将问题转化为规模<strong>正好小一层</strong>的<strong>子问题</strong>,<strong>递归</strong>解答</p>
<script type="math/tex; mode=display">
T(n)=T(n-1)+G(n)</script><p><strong>温馨提示</strong>:为了防止题目的<strong>毒瘤卡法</strong>,一般需要<strong>初始随机化</strong>,比如:random_shuffle()等</p>
<h2 id="经典回顾"><a href="#经典回顾" class="headerlink" title="经典回顾"></a>经典回顾</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p><a href="https://www.luogu.com.cn/problem/P1742" target="_blank" rel="noopener">最小圆覆盖</a></p>
<h3 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h3><p>在一个平面上有$n$个点，求一个<strong>半径最小</strong>的圆，能覆盖所有的点。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>假设圆$O$是前$i-1$个点得最小覆盖圆，加入第$i$个点，如果在圆内或边上则什么也不做。否，新得到的最小覆盖圆<strong>肯定经过第$i$个点</strong>。</p>
<p>然后以第$i$个点为基础（半径为0），重复以上过程依次加入第$j$个点，若第$j$个点在圆外，则最小覆盖圆<strong>必经过第$j$个点</strong>。</p>
<p>重复以上步骤。（因为最多需要三个点来确定这个最小覆盖圆，所以<strong>重复三次</strong>）</p>
<p>遍历完所有点之后，所得到的圆就是覆盖所有点得<strong>最小圆</strong>。</p>
<h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p><strong>时间复杂度</strong>:$O(n)$</p>
<p><strong>空间复杂度</strong>:$O(n)$</p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>由于一堆点最多只有3个点确定了最小覆盖圆，因此$n$个点中每个点参与确定最小覆盖圆的概率<strong>不大于</strong>$ \frac{3}{n} $</p>
<p>所以，每一层循环在第$i$个点处调用下一层的概率<strong>不大于</strong>$ \frac{3}{i} $</p>
<p>那么设算法的三个循环的复杂度分别为$ T_1(n),T_2(n),T_3(n) $，则有</p>
<script type="math/tex; mode=display">
T_1(n)=O(n)+ \sum^{n}_{i=1} \frac{3}{i}T_2(i) \\
T_2(n)=O(n)+ \sum^{n}_{i=1} \frac{3}{i}T_3(i) \\
T_3(n)=O(n)</script><p>解得:$ T_1(n)=T_2(n)=T_3(n)=O(n) $</p>
<h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1742</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">double</span> X,Y; &#125;Dot[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Round</span> &#123;</span> <span class="keyword">double</span> R,X,Y; &#125;Circle;</span><br><span class="line"><span class="keyword">int</span> Total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Round <span class="title">Get</span><span class="params">(Node A,Node B,Node C)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> X1=A.X,Y1=A.Y,X2=B.X,Y2=B.Y,X3=C.X,Y3=C.Y;</span><br><span class="line">    <span class="keyword">double</span> Dy=((X1*X1+Y1*Y1-X3*X3-Y3*Y3)*(X1-X2)-(X1*X1+Y1*Y1-X2*X2-Y2*Y2)*(X1-X3))/(<span class="number">2.0</span>*((Y1-Y3)*(X1-X2)-(Y1-Y2)*(X1-X3)));</span><br><span class="line">    <span class="keyword">double</span> Dx=(X1*X1+Y1*Y1-X2*X2-Y2*Y2<span class="number">-2.0</span>*Dy*(Y1-Y2))/(<span class="number">2.0</span>*(X1-X2));</span><br><span class="line">    <span class="keyword">double</span> Dr=<span class="built_in">sqrt</span>((Dx-X1)*(Dx-X1)+(Dy-Y1)*(Dy-Y1));</span><br><span class="line">	Round Res=&#123;Dr,Dx,Dy&#125;;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Check</span><span class="params">(Node A,Round New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Dist=<span class="built_in">sqrt</span>((A.X-New.X)*(A.X-New.X)+(A.Y-New.Y)*(A.Y-New.Y));</span><br><span class="line">    <span class="keyword">return</span> Dist&lt;=New.R;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Distance</span><span class="params">(Node A,Node B)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>((A.X-B.X)*(A.X-B.X)+(A.Y-B.Y)*(A.Y-B.Y)); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Dot[i].X,&amp;Dot[i].Y); &#125;</span><br><span class="line">    random_shuffle(Dot+<span class="number">1</span>,Dot+Total+<span class="number">1</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="keyword">if</span>(!Check(Dot[i],Circle)) &#123;</span><br><span class="line">        Circle=Round&#123;<span class="number">0.0</span>,Dot[i].X,Dot[i].Y&#125;;</span><br><span class="line">        FOR(j,<span class="number">1</span>,i<span class="number">-1</span>) <span class="keyword">if</span>(!Check(Dot[j],Circle)) &#123;</span><br><span class="line">            Circle=Round&#123;Distance(Dot[i],Dot[j])/<span class="number">2.0</span>,(Dot[i].X+Dot[j].X)/<span class="number">2.0</span>,(Dot[i].Y+Dot[j].Y)/<span class="number">2.0</span>&#125;;</span><br><span class="line">            FOR(k,<span class="number">1</span>,j<span class="number">-1</span>) <span class="keyword">if</span>(!Check(Dot[k],Circle)) </span><br><span class="line">                Circle=Get(Dot[i],Dot[j],Dot[k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n%.10lf %.10lf\n"</span>,Circle.R,Circle.X,Circle.Y);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>随机算法</title>
    <url>/articles/%E9%9A%8F%E6%9C%BA%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><h2 id="种子"><a href="#种子" class="headerlink" title="种子"></a>种子</h2><p>使用<strong>srand(seed)函数</strong>可以作为一个<strong>随机化种子</strong></p>
<p>当<strong>相同的seed</strong>两次运行<strong>同一程序</strong>生成的结果是<strong>相同</strong>的</p>
<p><strong>srand(time(NULL))</strong>使用<strong>当前系统时间</strong>作为随机种子</p>
<p>可以生成一个<strong>随机非负整数</strong></p>
<p><strong>温馨提示</strong>：<strong>Windows系统</strong>rand()返回值取值范围为$ [0,2^{15}) $，<strong>Linux系统</strong>范围为$ [0,2^{31}) $</p>
<p>当然，还有一些神奇的随机种子，比如：<strong>srand(19491001)，srand(19260817)，srand(114514) </strong>$ \cdots $</p>
<h2 id="随机函数"><a href="#随机函数" class="headerlink" title="随机函数"></a>随机函数</h2><p><strong>random_shuffle()</strong></p>
<p>用于<strong>打乱指定序列</strong>，使用时存入指定区间的<strong>首尾指针或迭代器</strong>即：random_shuffle(first,last)</p>
<p>还有一些，比如：<strong>shuffle(),random_device()</strong> $ \cdots $</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><a href="https://loj.ac/problem/2100" target="_blank" rel="noopener">[TJOI2015]线性代数</a> </p>
<p>这是OI-Wiki上推荐的一道”水题”</p>
<p>由于<strong>数据比较水</strong>，我们每次<strong>随机一个位置</strong>，<strong>取反</strong>即可<strong>统计答案</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LOJ 2100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Ans,Cop[MAXN];</span><br><span class="line"><span class="keyword">int</span> A[MAXN],C[MAXN],B[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="comment">//struct Node &#123;</span></span><br><span class="line"><span class="comment">//    int Squ[MAXN][MAXN];</span></span><br><span class="line"><span class="comment">//    int Row,Line;</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//    inline void Clean(int X) &#123; FOR(i,1,Row) FOR(j,1,Line) Squ[i][j]=X; &#125;</span></span><br><span class="line"><span class="comment">//    inline void Transpose() &#123;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Row) FOR(j,1,Line) Cop[i][j]=Squ[i][j];</span></span><br><span class="line"><span class="comment">//        int Temp=Row; Row=Line; Line=Temp;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Row) FOR(j,1,Line) Squ[i][j]=Cop[j][i];</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    friend Node operator * (Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">//        Node Temp;</span></span><br><span class="line"><span class="comment">//        Temp.Clean(0);</span></span><br><span class="line"><span class="comment">//        Temp.Row=A.Row; Temp.Line=B.Line;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Temp.Row) FOR(j,1,Temp.Line) FOR(k,1,A.Line)</span></span><br><span class="line"><span class="comment">//        Temp.Squ[i][j]+=A.Squ[i][k]*B.Squ[k][j];</span></span><br><span class="line"><span class="comment">//        return Temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    friend Node operator - (Node A,Node B) &#123;</span></span><br><span class="line"><span class="comment">//        Node Temp;</span></span><br><span class="line"><span class="comment">//        Temp.Clean(0);</span></span><br><span class="line"><span class="comment">//        Temp.Row=A.Row; Temp.Line=A.Line;</span></span><br><span class="line"><span class="comment">//        FOR(i,1,Temp.Row) FOR(j,1,Temp.Line)</span></span><br><span class="line"><span class="comment">//        Temp.Squ[i][j]=A.Squ[i][j]-B.Squ[i][j];</span></span><br><span class="line"><span class="comment">//        return Temp;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;A,B,C;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Cop,<span class="number">0</span>); <span class="keyword">int</span> Res=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) FOR(k,<span class="number">1</span>,Total) Cop[i]+=A[k]*B[k][i];</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Cop[i]-=C[i];</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Res+=Cop[i]*A[i];</span><br><span class="line">	Ans=<span class="built_in">max</span>(Ans,Res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) FOR(j,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;B[i][j]);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;C[i]),A[i]=<span class="number">1</span>;</span><br><span class="line">    Find();</span><br><span class="line">    FOR(i,<span class="number">1</span>,<span class="number">500</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> Temp=(rand()%Total)+<span class="number">1</span>;</span><br><span class="line">        A[Temp]^=<span class="number">1</span>;</span><br><span class="line">        Find();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">   <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="爬山算法"><a href="#爬山算法" class="headerlink" title="爬山算法"></a>爬山算法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p> 爬山算法是一个<strong>局部择优</strong>的方法，采用的是<strong>启发式仿函</strong>，对<strong>深度优先搜索</strong>的一种改进</p>
</blockquote>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>爬山算法主要应用于<strong>单峰函数</strong>，<strong>收敛速度快</strong></p>
<p>无法应用于<strong>多峰函数</strong>，如图</p>
<p><img src="https://i.loli.net/2020/08/15/rgBkqUYLnHI1TdO.png" alt="随机算法-1.png"></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>[转载] {</p>
<p>爬山算法一般会引入<strong>温度参数</strong>（类似模拟退火）。类比地说，爬山算法就像是一只兔子喝醉了在山上跳，它每次都会朝着它所认为的更    高的地方（这往往只是个不准确的趋势）跳，显然它有可能一次跳到山顶，也可能跳过头翻到对面去。不过没关系，兔子翻过去之后还    会跳回来。显然这个过程很没有用，兔子永远都找不到出路，所以在这个过程中兔子冷静下来并在每次跳的时候更加谨慎，少跳一点，    以到达合适的最优点。</p>
<p>兔子逐渐变得清醒的过程就是降温过程，即温度参数在爬山的时候会不断减小。</p>
<p>关于降温：降温参数是略小于1的常数，一般在<strong>[0.985,0,999]</strong>中选取。</p>
<p>}</p>
<p><strong>注</strong>：一般在调答案的时候，会用到<strong>向量的合并</strong>。</p>
<h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P4035" target="_blank" rel="noopener">[JSOI2008]球形空间产生器</a></p>
<p>由于绝对是<strong>单峰函数</strong>，所以直接由向量合并，逐次更新答案</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P4035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Dist[MAXN],Ave,Dot[MAXN][MAXN],Vec[MAXN],Round[MAXN];</span><br><span class="line"><span class="keyword">int</span> Base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Ave=<span class="number">0.0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) &#123;</span><br><span class="line">        Dist[i]=<span class="number">0.0</span>; Vec[i]=<span class="number">0.0</span>;</span><br><span class="line">        FOR(j,<span class="number">1</span>,Base) Dist[i]+=(Dot[i][j]-Round[j])*(Dot[i][j]-Round[j]);</span><br><span class="line">        Dist[i]=<span class="built_in">sqrt</span>(Dist[i]);</span><br><span class="line">        Ave+=Dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Ave/=(<span class="keyword">double</span>)(Base+<span class="number">1</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) FOR(j,<span class="number">1</span>,Base) </span><br><span class="line">        Vec[j]+=(Dot[i][j]-Round[j])*(Dist[i]-Ave)/Ave;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Base);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base+<span class="number">1</span>) FOR(j,<span class="number">1</span>,Base) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;Dot[i][j]); Round[j]+=Dot[i][j]; &#125; </span><br><span class="line">    FOR(i,<span class="number">1</span>,Base) &#123; Round[i]/=(<span class="keyword">double</span>)(Base+<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> Temp=<span class="number">1000</span>;Temp&gt;=<span class="number">0.0001</span>;Temp*=<span class="number">0.99995</span>) &#123;</span><br><span class="line">        Check();</span><br><span class="line">        FOR(i,<span class="number">1</span>,Base) &#123; Round[i]+=Vec[i]*Temp; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Base) &#123; <span class="built_in">printf</span>(<span class="string">"%.3lf "</span>,Round[i]); &#125; </span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">    <span class="comment">//system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模拟退火"><a href="#模拟退火" class="headerlink" title="模拟退火"></a>模拟退火</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>百度百科</p>
<p><strong>什么是退火？</strong></p>
<p>退火是一种金属热处理工艺，指的是将金属缓慢加热到一定温度，保持足够时间，然后以适宜速度冷却。目的是降低硬度，改善切削加工性；消除残余应力，稳定尺寸，减少变形与裂纹倾向；细化晶粒，调整组织，消除组织缺陷。准确的说，退火是一种对材料的热处理工艺，包括金属材料、非金属材料。而且新材料的退火目的也与传统金属退火存在异同。</p>
<p>模拟退火是一种随机化算法。当一个问题的方案数量极大（甚至是无穷的）而且不是一个单峰函数时，我们常使用模拟退火求解。</p>
</blockquote>
<p>因为退火算法引入了更多的<strong>随机因素</strong>，所以我们有<strong>更大的概率</strong>得到<strong>最优解</strong></p>
<h3 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h3><p>如果新状态的解更优则修改答案，否则以<strong>一定概率</strong>接受新状态</p>
<p>[转载]</p>
<p><img src="https://i.loli.net/2020/08/15/BecCiVwvjRE8mhy.gif" alt="随机算法-2.gif"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p><strong>随机挑选</strong>一个单元$k$，并给他一个随机的位移，求出系统因此而产生的<strong>能量变化</strong>$ \Delta E_k $</p>
<h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>若$ \Delta E_k \leq 0 $，该位移<strong>可接纳</strong>，而变化后的系统状态可作为<strong>下一次变化的起点</strong></p>
<p>若$ \Delta E_k &gt; 0 $，位移后的状态<strong>可采纳的概率</strong>为$ P_k= \frac{1}{1+e^{- \Delta E_k /T}} $</p>
<p>式子中的$T$为温度，然后从$ (0,1) $区间均匀分布的随机数中挑选一个数$R$，若$ R &lt; P_k $，则将变化后的状态作为下次的起点，否则，将变化前的状态作为下次的起点</p>
<h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>转第$(1)$步继续执行，直到达到<strong>平衡状态</strong>为止</p>
<h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题"></a>例题</h3><p><a href="https://www.luogu.com.cn/problem/P1337" target="_blank" rel="noopener">[BZOJ 3680]吊打 XXX</a> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//P1337</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Weight[MAXN];</span><br><span class="line"><span class="keyword">double</span> X[MAXN],Y[MAXN],Dist[MAXN],Ansx,Ansy,Vecx,Vecy;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Power_D</span><span class="params">(<span class="keyword">double</span> Temp)</span> </span>&#123; <span class="keyword">return</span> Temp*Temp; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Ave=<span class="number">0.0</span>;</span><br><span class="line">    Vecx=<span class="number">0.0</span>; Vecy=<span class="number">0.0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        Dist[i]=<span class="built_in">sqrt</span>(Power_D(X[i]-Ansx)+Power_D(Y[i]-Ansy));</span><br><span class="line">        Vecx+=(<span class="keyword">double</span>)Weight[i]*(X[i]-Ansx)/Dist[i];</span><br><span class="line">        Vecy+=(<span class="keyword">double</span>)Weight[i]*(Y[i]-Ansy)/Dist[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//File();</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf %lf %d"</span>,&amp;X[i],&amp;Y[i],&amp;Weight[i]); Ansx+=X[i]; Ansy+=Y[i]; &#125;</span><br><span class="line">    <span class="keyword">if</span>(Total==<span class="number">1</span>) &#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf\n"</span>,X[<span class="number">1</span>],Y[<span class="number">1</span>]);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Ansx/=(<span class="keyword">double</span>)Total; Ansy/=(<span class="keyword">double</span>)Total;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">double</span> Temp=<span class="number">1000</span>;Temp&gt;=<span class="number">0.0000001</span>;Temp*=<span class="number">0.997</span>) &#123;</span><br><span class="line">        Check();</span><br><span class="line">        Ansx+=Vecx*Temp; Ansy+=Vecy*Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.3lf %.3lf\n"</span>,Ansx,Ansy);</span><br><span class="line">    <span class="comment">//fclose(stdin); fclose(stdout);</span></span><br><span class="line">  <span class="comment">//  system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Courseware</tag>
      </tags>
  </entry>
  <entry>
    <title>Burnside引理 &amp; Polay定理</title>
    <url>/articles/Burnside%E5%BC%95%E7%90%86-Polay%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Burnside引理-amp-Polay定理"><a href="#Burnside引理-amp-Polay定理" class="headerlink" title="Burnside引理 &amp; Polay定理"></a>Burnside引理 &amp; Polay定理</h1><h2 id="置换"><a href="#置换" class="headerlink" title="置换"></a>置换</h2><p>即：对元素进行<strong>重排列</strong>，是所有元素的<strong>一一映射</strong></p>
<script type="math/tex; mode=display">
[1 , n] \Rightarrow [1 , n]</script><p>比如：我们将一个<strong>正方形绕中心旋转90°</strong>，可以看作是<strong>四个顶点的一个置换</strong></p>
<p><img src="https://i.loli.net/2020/09/08/8RnfCwydMZIx7ba.jpg" alt="Burnside引理 _ Polay定理-1.jpg"></p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>置换可以构成<strong>环</strong>：对于元素连一条<strong>有向边</strong>，连到置换中<strong>映射的元素</strong>，会构成<strong>$n$个环（循环）</strong></li>
<li>如果一个状态$S$经过置换后<strong>与原来相同</strong>，即：</li>
</ul>
<script type="math/tex; mode=display">
S[1]=S[a_1],S[2]=S[a_2], \cdots ,S[n]=S[a_n]</script><p>​        那么称这个状态$S$为<strong>不动点</strong></p>
<ul>
<li>本质不同的方案数一般指<strong>方案类的种数</strong>，等价关系通常是一个<strong>置换集合</strong>，如果一个置换能把其中一个方案映射到另一个方案，那么他们是<strong>等价</strong>的。置换构成的<strong>置换群</strong>就是<strong>交换排序顺序</strong>而已</li>
<li>多个置换构成<strong>置换群</strong></li>
</ul>
<h2 id="Burnside引理"><a href="#Burnside引理" class="headerlink" title="Burnside引理"></a>Burnside引理</h2><h3 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h3><p>对于一个置换群$G$，$G$是<strong>目标集</strong>$ [1,n] $上的<strong>置换群</strong>，若一个<strong>染色方案$S$</strong>经过置换后不变，称$S$为$G$的<strong>不动点</strong>，将不动点的<strong>数目</strong>记为$C(G)$ ，则<strong>等价类</strong>$l$数目为$C(G)$的<strong>平均值</strong></p>
<script type="math/tex; mode=display">
l= \frac{1}{|G|} [C(a_1)+C(a_2)+ \cdots + C(a_g)] \\
l= \frac{1}{|G|} \times \sum C(i)</script><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>设$G$为<strong>置换集合</strong>，$|G|$为<strong>置换种数</strong>，$ T_i $是第$i$类置换中的<strong>不动点的个数</strong></p>
<p>由于我们需要求的是等价类的个数</p>
<p>所有<strong>手摸</strong>一下上边的例子可以知道</p>
<ul>
<li>每一种等价类都在置换上是<strong>不动点</strong>（至少0°是）</li>
<li>同一个等价类的所有元素，会<strong>同时作为/不作为</strong>某一个置换的<strong>不动点</strong></li>
<li>每一个等价类的<strong>所有元素</strong>，对<strong>不动点总数</strong>的贡献<strong>和</strong>恰好为$ |G| $</li>
</ul>
<hr>
<p>$ e.g: $</p>
<p>​        <strong>元素15</strong>，在<strong>置换1,3</strong>中为不动点，和它<strong>同构</strong>的共有$ [[1,2]]=2 $个元素</p>
<p>​        所以<strong>不动点贡献$ =4 $</strong></p>
<p>​        <strong>元素$i$：</strong>在<strong>置换$ 1,k+1,2k+1, \cdots ,(p-1)k+1 $</strong>中为<strong>不动点</strong>，和他<strong>同构</strong>的有$ [[1,k]]=k $个元素</p>
<p>​        所以<strong>不动点贡献</strong>$ =p \times k = |G|(p=|G|/k) $</p>
<hr>
<p>由此，我们可以得到<strong>公式</strong>：</p>
<script type="math/tex; mode=display">
l= \frac{1}{|G|} \times \sum T_i</script><p><strong>证毕！</strong></p>
<h2 id="Polay定理"><a href="#Polay定理" class="headerlink" title="Polay定理"></a>Polay定理</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>我们可以利用Burnside引理列出<strong>所有的$ m^n $中可能的染色方案</strong>，然后找出每个置换下保持不变的方案数，显然在<strong>$m$或者$n$很大</strong>时，<strong>复杂度直接爆掉</strong></p>
<p>所以Polay定理其实就是对Burnside引理的<strong>具体化</strong>，提供了计算不动点的集体方法</p>
<h3 id="内容-1"><a href="#内容-1" class="headerlink" title="内容"></a>内容</h3><p>假设一个置换有$ \sigma_k $个<strong>循环</strong></p>
<p>易知每个循环对应的<strong>所有位置颜色需要一致</strong>，而<strong>任意两个循环</strong>之间选什么颜色<strong>互不影响</strong>。因此，如果有$m$中可选颜色，则置换对应的<strong>不动点个数</strong>为$m^{ \sigma_k}$</p>
<p>用其代替Burnside引理中的$C(G)$，即$ C(G)=m_{ \sigma^k} $</p>
<p>则<strong>等价类个数</strong>为：</p>
<script type="math/tex; mode=display">
l= \frac{1}{|G|} \sum_{k=1}^{|G|} m^{ \sigma_k}</script><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/sssy/p/8427745.html" target="_blank" rel="noopener">Burnside引理与polay定理</a></p>
<p><a href="https://www.cnblogs.com/maomao9173/p/10596368.html" target="_blank" rel="noopener">Burnside引理的感性证明</a></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Dilworth定理</title>
    <url>/articles/Dilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Dilworth定理"><a href="#Dilworth定理" class="headerlink" title="Dilworth定理"></a>Dilworth定理</h1><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><p><strong>偏序集上最小链划分中链的数量等于其反链长度的最大值</strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="偏序集"><a href="#偏序集" class="headerlink" title="偏序集"></a>偏序集</h3><p><code>Dilworth</code>定理是定义在<strong>偏序集</strong>上的，什么是偏序集？我们定义一种<strong>比较关系</strong>，使得两种元素之间进行比较，例如对于元素为<strong>二元组</strong>$ (a,b),(c,d) $我们定义$ (a,b)&lt;=(c,d) $当且仅当$ a&lt;=c,b&lt;=d $，那么这两个元素就<strong>可比</strong>了，但是如果$ a&gt;c,b&lt;=d $，那么这两个元素就<strong>不可比</strong>了</p>
<h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><ul>
<li><strong>自反性</strong>：$ \forall a \in S,a \leq a $</li>
<li><strong>对称性</strong>：$ \forall a,b \in S $若$ a \leq b $则$ b \leq a $</li>
<li><strong>传递性</strong>：若$ a \leq b,b \leq c $则$ a \leq c $</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>如果对于每个$ a,b $，若$ a&lt;=b $，我们连一条$ a \rightarrow b $的边，那么显然，整个<strong>偏序集</strong>构成一个<strong><code>DAG</code></strong></p>
<h3 id="链"><a href="#链" class="headerlink" title="链"></a>链</h3><p>我们假设在若干元素构成一个集合，那么，这个集合是链<strong>当且仅当</strong>这个集合的所有元素<strong>两两是可比</strong>的。换句话说，你可以看成是<strong><code>DAG</code>上的一条路径上的一些元素</strong></p>
<p><strong>温馨提示：</strong>这个集合中的元素可能只是这条路径上的<strong>一部分</strong>，中间挖掉几个点也是有可能的</p>
<h3 id="反链"><a href="#反链" class="headerlink" title="反链"></a>反链</h3><p>正如名字一样，反链和链的定义<strong>恰好相反</strong>，对于一个集合，它是反链当且仅当这个集合里的元素两两都是<strong>不可比的</strong>。换句话说，这个集合里的<strong>任何</strong>两个元素<strong>无法联通</strong>（在一张<code>DAG</code>上）</p>
<h3 id="链划分"><a href="#链划分" class="headerlink" title="链划分"></a>链划分</h3><p>我们将$ S $中的所有元素划分成若干条链，使每个元素都在且<strong>仅在唯一一条链</strong>中，叫<strong>链划分</strong></p>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>设偏序集$ S $。$ S $能划分成的<strong>最少的全序集</strong>的个数为$ K $，$ S $的<strong>最大反链</strong>的元素个数为$M$</p>
<h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>先证明$ K \geq M $。设反链</p>
<script type="math/tex; mode=display">
 A={a_1,a_2, \cdots,a_M}</script><p>假设$ K&lt;M $，那么由<strong>抽屉原理</strong>，必然有两个元素$ a_i,a_j $在同一个<strong>全序集</strong>中。那么$ a_i,a_j $可比。与$ a_i,a_j $不可比<strong>矛盾</strong>。</p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p> 再证明$ K=M $。用<strong>第二数学归纳法</strong></p>
<p>设全序集$S$中有$m$个元素</p>
<h4 id="1-gt"><a href="#1-gt" class="headerlink" title="1&gt;"></a>1&gt;</h4><p>当$m=0$和$m=1$时，对于命题结论<strong>显然成立</strong>。</p>
<h4 id="2-gt"><a href="#2-gt" class="headerlink" title="2&gt;"></a>2&gt;</h4><p><strong>假设</strong></p>
<script type="math/tex; mode=display">
 m<n(n \in \mathbb{N})</script><p>时命题成立，现在证$ m=n $时，命题也成立。</p>
<p>设$x$为$S$中的一个<strong>极大元</strong>。考虑</p>
<script type="math/tex; mode=display">
S'=S-{x}</script><p>这个偏序集。由于$ |S’|&lt;n $，由<strong>归纳假设</strong>，$S’$满足命题。设$S’$能划分成的<strong>最小的全序集</strong>个数为$k$，<strong>最大反链</strong>的元素个数也为$k$。那么我们设$S’$被划分成了$k$个链分别为$ C_1,C_2, \cdots,C_k $。设所有长度为$k$的<strong>反链</strong>分别为$ A_1,A_2, \cdots,A_r $。（假设有$r$条长度为$k$的反链）</p>
<p>那么对于<strong>任意</strong>一个$A_i$，$A_i$的元素必定是$k$条链上，每条链取一个元素。设为</p>
<script type="math/tex; mode=display">
 a_{i1},a_{i2}, \cdots,a_{ik}</script><p>那么我们考虑集合</p>
<script type="math/tex; mode=display">
 B= {b_1,b_2, \cdots ,b_k}={ max(a_{i1}), max(a_{i2}), max(a_{i3}), \cdots , max(a_{ik}) }</script><p>这个集合<strong>一定也是一条反链</strong>。（用<strong>反证法</strong>很容易证明：假设存在两个元素$b<em>i,b_j$可比，不妨设$ b_i \leq b_j $，其中$b_i$和$b_j$分别位于链$C_i$和$C_j$上。那么$b_i$所在链的每个$a</em>{ix}$都与$b<em>j$可比，与**$C_i$上存在一个$a</em>{ix}$与$b_j$不可比<strong>矛盾。）</strong>（加粗的地方之所以是正确的，是因为$C_i$与$C_j$上肯定有两个元素属于同一条反链）**</p>
<p>现在考虑加入元素$x$的集合$S$。一个显然的事实是，<strong>加入一个极大元，不可能让划分的最少链个数更少，但是也不能让链的个数增加2及以上（否则肯定不满足最少链）。也不能让反链的最大长度更小</strong></p>
<p>分<strong>两种情况</strong>：</p>
<h5 id="①"><a href="#①" class="headerlink" title="①"></a>①</h5><p>如果$x$这个<strong>极大元</strong>与B中每个元素都<strong>不可比</strong>。那么考虑$ B \cup {x} $，就是一个长度为$ k+1 $的反链。那么最少能划分的链的个数至少是$ k+1 $。而加入一个元素，链的条数至多增加1。因此，链的<strong>最少条数</strong>就是$ k+1 $。这样，对于这种情况，命题对于$ m=n $时也成立了。</p>
<h5 id="②"><a href="#②" class="headerlink" title="②"></a>②</h5><p>如果$x$与$B$中的某个元素可比，假设$x$与$b_i$可比，那么显然$ x \geq bi $</p>
<p>考虑集合 </p>
<script type="math/tex; mode=display">
 D={a_{i1},a_{i2}, \cdots ,a_{ir}} \cup {x}</script><p>$D$显然也是一条链。 现在考虑$ S’’=S-D $这个集合。由于每个长度为$k$的链都被我们抽掉了一个元素，所以集合$ S’’ $不会有长度为$k$的反链了，而长度为$k-1$的反链显然是<strong>存在</strong>的（按照原来的构造）。由<strong>归纳</strong>假设，$S’’$最少能划分成的链也是$k-1$。不妨设划分为了</p>
<script type="math/tex; mode=display">
C'_1，C'_2，\cdots ,C'_{k-1}</script><p>那么，我们对$S$就构造出了$k$条链的情况：</p>
<script type="math/tex; mode=display">
 C'_1，C'_2，\cdots ,C'_{k-1},D</script><p>所以反链的长度<strong>最大</strong>为$k$了。而去掉$x$就已经可以构造出长度为$k$的反链，因此$S$的最大反链至少是$k$。因此<strong>最大反链</strong>就是$k$。</p>
<p><strong>证毕！</strong></p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p><a href="https://cmwqf.github.io/2019/12/17/%E6%B5%85%E8%B0%88Dilworth%E5%AE%9A%E7%90%86/" target="_blank" rel="noopener">浅谈Dilworth定理</a></p>
<p><a href="https://www.cnblogs.com/itlqs/p/6636222.html" target="_blank" rel="noopener">Dilworth定理证明</a></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>K-NIM问题</title>
    <url>/articles/K-NIM%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="K-NIM问题"><a href="#K-NIM问题" class="headerlink" title="K-NIM问题"></a>K-NIM问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>有$n$堆石子，每堆有$a_i$个，每次可以选$ 1 \sim m $堆，从中<strong>各取若干</strong>石子，每堆<strong>至少取一个</strong>。若轮到某人时，所有的石子都已经<strong>取完了</strong>，这个人就<strong>输</strong></p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>当前状态为<strong>必败态</strong>，<strong>当且仅当</strong>将所有的$a_i$转换成<strong>二进制</strong>后，<strong>每一位</strong>的<strong>1的个数</strong>$ Cnt_i \equiv 0 (mod\,\,\,(m+1)) $</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul>
<li>$ N \Rightarrow $<strong>必败状态</strong></li>
<li>$ P \Rightarrow $<strong>必胜状态</strong></li>
</ul>
<h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p><strong>全为0</strong>的局面一定为<strong>必败态</strong></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>任何一个$N$状态，经过一次操作以后<strong>必然</strong>会到达一个$P$状态</p>
<p>在某一次移动中，至少有一堆被改变，也就是说<strong>至少有一个二进制位发生了改变</strong></p>
<p>由于最多只能改变$m$堆石子，所以对于一个二进制位，1的个数<strong>最多改变$m$次</strong></p>
<p>而由于原先总数位$ m+1 $的整数倍，所以改变之后必然<strong>不可能</strong>是$ m+1 $的整数倍</p>
<p><strong>故</strong>，在$N$状态下的一次操作结果必然为$P$状态 </p>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p><strong>任何</strong>$P$状态，<strong>总有</strong>一种操作使得变为$N$状态</p>
<p>我们<strong>从高位到低位</strong>考虑所有的二进制位</p>
<p>假设用了某种方式，我们改变了$k$堆，使得<strong>第$i$位之前的所有位</strong>的1的个数都变成了$ m+1 $的整数倍</p>
<p>现在要证明中有一种方法使得第$i$位也变成$ m+1 $的整数倍</p>
<p>显然，对于已经改变了的那$k$堆，当前位$i$可以在$1/0$中选择</p>
<p>设出去已经改变的$k$堆，剩下的堆第$i$位上的1总数为$ mod(m+1) = sum $</p>
<p><strong>分类讨论</strong></p>
<h4 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h4><p>$ sum \leq m-k $ </p>
<p>此时可以将<strong>这些堆上的1全部拿掉</strong>，然后让<strong>那$k$堆的第$i$为全部置换成0</strong></p>
<h4 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h4><p>$ sum &gt; m-k $</p>
<p>此时我们在<strong>之前改变的$k$堆中选择$ m+1-sum $堆</strong>，将他们的<strong>第$i$位置换成1</strong>，<strong>剩下的置换成0</strong></p>
<p>由于$ m+1-sum \leq k $，故<strong>可以达到</strong></p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200817赛后总结</title>
    <url>/articles/T20200817%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200817赛后总结"><a href="#T20200817赛后总结" class="headerlink" title="T20200817赛后总结"></a>T20200817赛后总结</h1><h2 id="成绩排行：T20200817成绩"><a href="#成绩排行：T20200817成绩" class="headerlink" title="成绩排行：T20200817成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.17/result20200817.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.17/result20200817.html">T20200817成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，还是和想象中的差一点</p>
<p>我认为主要是几点，其中重要的一点就是$ \rightarrow $<strong>没睡好觉</strong></p>
<p>感觉一上午都是在<strong>zks</strong>。。。</p>
<p>还是的是，能把肯定<strong>能拿到的分</strong>拿到</p>
<p>但可惜状态不好，没有把自己感觉应有的实力发挥出来。。。</p>
<p>当场<strong>%范巨，哲哥 Orz</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>KMP（或SA）</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/17/m8H2JnplGrTMsix.png" alt="T20200817-gene.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，这是一道<strong>模板KMP</strong></p>
<p>就是那种没有什么改变的KMP</p>
<p>题意是说找到有多少个子串，与<strong>前缀</strong>相同</p>
<p>那么很自然就可以想到在<strong>Lost数组上做DP</strong></p>
<p>在求Lost数组的时候，<code>DP[i+1]=DP[Lost[i+1]]+1;</code>即可</p>
<p>但要注意的是，最后统计答案的时候需要加上<strong>所有的前缀</strong>数目，也就是$n$</p>
<p>还有一点，<strong>只有当</strong><code>Lost[i+1]</code>的时候可以DP</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gene</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Temp[MAXN];</span><br><span class="line">LL Len,Lost[MAXN],Loc;</span><br><span class="line">LL Ans,DP[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get_Lost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Loc=<span class="number">0</span>;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Len<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(Loc &amp;&amp; Temp[i]!=Temp[Loc]) Loc=Lost[Loc];</span><br><span class="line">        Lost[i+<span class="number">1</span>]=(Temp[i]==Temp[Loc] ? ++Loc : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(Lost[i+<span class="number">1</span>]) DP[i+<span class="number">1</span>]=DP[Lost[i+<span class="number">1</span>]]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"gene.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"gene.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,Temp); Len=<span class="built_in">strlen</span>(Temp);</span><br><span class="line">    Get_Lost();</span><br><span class="line">    FOR(i,<span class="number">0</span>,Len) Ans+=DP[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans+Len);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>叉积+二分+DP</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/17/VtZsL7Qkf4YzoIP.png" alt="T20200817-sheild.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>先认定这个绝对和<strong>坐标轴</strong>的改变有关</p>
<p>然后我就死磕了1h+，最后倒是有思路了，只是有点乱</p>
<p>好在，还是调出来了</p>
<p>我们可以发现，对于$j$若可以接在$i$后边，<strong>当且仅当**</strong></p>
<p>$ Distance(i,line_1) \leq Distance(j,line_1) $并且$ Distance(i,line_2) \leq Distance(j,line_2) $</p>
<p>所以，我们就可以通过这个思路进行<strong>点坐标的改变</strong></p>
<p>最后就变成了一个标准的<strong>二维偏序</strong>+<strong>最长不下降子序列</strong></p>
<p>利用<strong>二分优化</strong>后者即可</p>
<p><strong>时间复杂度</strong>:$ O(nlogn) $</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//shield</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> X,Y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Vector A,Vector B)</span><br><span class="line">    &#123; <span class="keyword">return</span> A.X&lt;B.X || (A.X==B.X &amp;&amp; A.Y&lt;B.Y); &#125;</span><br><span class="line">&#125;Dot[MAXN],F,S,Temp;</span><br><span class="line">LL Ans,Total;</span><br><span class="line"><span class="keyword">double</span> DP[MAXN]=&#123;<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"sheild.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"sheild.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">Cross</span><span class="params">(Vector A,Vector B)</span> </span>&#123; <span class="keyword">return</span> A.X*B.Y-A.Y*B.X; &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;F.X,&amp;F.Y);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;S.X,&amp;S.Y);</span><br><span class="line">    <span class="keyword">if</span>(Cross(F,S)&lt;<span class="number">0</span>) swap(F,S);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>,&amp;Temp.X,&amp;Temp.Y);</span><br><span class="line">        Dot[i].X=Cross(Temp,F);</span><br><span class="line">        Dot[i].Y=-Cross(Temp,S);</span><br><span class="line">    &#125;<span class="comment">//转化坐标系</span></span><br><span class="line">    sort(Dot+<span class="number">1</span>,Dot+Total+<span class="number">1</span>);<span class="comment">//二位偏序，先按X排序</span></span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        LL L=<span class="number">0</span>,R=Ans;</span><br><span class="line">		<span class="keyword">while</span>(L&lt;R)&#123;</span><br><span class="line">			LL Mid=(L+R+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(DP[Mid]&lt;=Dot[i].Y) L=Mid;</span><br><span class="line">			<span class="keyword">else</span> R=Mid<span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DP[L+<span class="number">1</span>]=(Dot[i].Y);</span><br><span class="line">		Ans=<span class="built_in">max</span>(Ans,L+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="comment">// system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>拓扑序+堆</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/17/7MBcQH9emjZnbh2.png" alt="T20200817-chronosphere.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题为这套题的<strong>压轴题</strong>，但还是很好偏分的</p>
<p>我当时脑阔乔了，以为是<strong>一棵树+无向边</strong></p>
<p>导致我磕了接近一个小时，心态炸裂。。。</p>
<p>最后10分钟才都清楚题意。。。</p>
<p>本题主要是<strong>状态更新</strong></p>
<p>假如我们有一个图</p>
<p><img src="https://i.loli.net/2020/08/17/YL2emDFbnhSJip4.png" alt="T20200817-2.png"></p>
<p>因为我们需要求出满足条件的<strong>全局最短的最长路</strong></p>
<p>所以我们可以考虑对于<strong>每一个点</strong>的最长路（可以当作<strong>超级源汇</strong>）</p>
<p>设$F(x)$为<strong>终点</strong>是$x$的最长路，$G(x)$为<strong>起点</strong>是$x$的最长路</p>
<p>易知：经过当前<strong>点</strong>的最长路为$ F(x)+G(x) $,对于每条<strong>边</strong>的最长路$ F(s)+G(t)+1 $</p>
<p>所以我们可以考虑<strong>动态删除插入元素</strong>，使得每次返回的都是删除当前点的最长路长度，可以结合<code>multiset</code>进行erase,insert,find操作</p>
<p>具体的，每次<strong>到达</strong>当前点，就把与当前点有关的所有可能结果<strong>删除</strong></p>
<p>同理在<strong>离开</strong>当前点时，将可能成为答案的有关结果<strong>加入</strong>堆即可</p>
<p><img src="https://i.loli.net/2020/08/17/ctAwVdM1JZvB58m.png" alt="T20200817-3.png"></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chronosphere</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Side;</span><br><span class="line"><span class="keyword">int</span> Next[MAXN],Head[MAXN],End[MAXN],Cur;</span><br><span class="line"><span class="keyword">int</span> RNext[MAXN],RHead[MAXN],REnd[MAXN],RCur;</span><br><span class="line"><span class="keyword">int</span> F[MAXN],G[MAXN],RD[MAXN],Dot[MAXN],Cnt,ID,Ans=INF;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;Temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"chronosphere.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"chronosphere.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">    Next[++Cur]=Head[From]; </span><br><span class="line">    Head[From]=Cur;</span><br><span class="line">    End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Re_Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">    RNext[++RCur]=RHead[From]; </span><br><span class="line">    RHead[From]=RCur;</span><br><span class="line">    REnd[RCur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Topo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) <span class="keyword">if</span>(!RD[i]) Dot[++Cnt]=i;</span><br><span class="line">    <span class="keyword">int</span> Loc=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Loc&lt;Cnt) &#123;</span><br><span class="line">    	Loc++;</span><br><span class="line">        FOR_SIDE(i,Dot[Loc]) </span><br><span class="line">            <span class="keyword">if</span>(!--RD[End[i]]) Dot[++Cnt]=End[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Side);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Side) &#123;</span><br><span class="line">    	<span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">        RD[v]++;</span><br><span class="line">        Add_Edge(u,v); Re_Add_Edge(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">    Topo();</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) FOR_SIDE(j,Dot[i]) F[End[j]]=<span class="built_in">max</span>(F[End[j]],F[Dot[i]]+<span class="number">1</span>);</span><br><span class="line">    BOR(i,Total,<span class="number">1</span>) <span class="keyword">for</span>(<span class="keyword">int</span> j=RHead[Dot[i]];j;j=RNext[j]) G[REnd[j]]=<span class="built_in">max</span>(G[REnd[j]],G[Dot[i]]+<span class="number">1</span>);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) Temp.insert(G[i]);</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=RHead[Dot[i]];j;j=RNext[j]) </span><br><span class="line">            Temp.erase(Temp.<span class="built_in">find</span>(F[REnd[j]]+<span class="number">1</span>+G[Dot[i]]));</span><br><span class="line">        Temp.erase(Temp.<span class="built_in">find</span>(G[Dot[i]]));</span><br><span class="line">        <span class="keyword">int</span> Res=*(--Temp.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">if</span>(Ans&gt;Res) &#123; Ans=Res; ID=Dot[i]; &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(Ans==Res &amp;&amp; Dot[i]&lt;ID) &#123; ID=Dot[i]; &#125;</span><br><span class="line">        FOR_SIDE(j,Dot[i]) Temp.insert(F[Dot[i]]+<span class="number">1</span>+G[End[j]]);</span><br><span class="line">        Temp.insert(F[Dot[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,ID,Ans);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">//    system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200820赛后总结</title>
    <url>/articles/T20200820%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200820赛后总结"><a href="#T20200820赛后总结" class="headerlink" title="T20200820赛后总结"></a>T20200820赛后总结</h1><h2 id="成绩排行：T20200820成绩"><a href="#成绩排行：T20200820成绩" class="headerlink" title="成绩排行：T20200820成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.20/result20200820.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.20/result20200820.html">T20200820成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次比赛考场上发挥还是比较稳定，就是<strong>写挂了</strong>，曰[$ yu \bar{e} $]（文明一点）</p>
<p>T2是真的简单，但树剖的时候<strong>Dep[Top[L]]</strong>写成Dep[L]了，害。。。</p>
<p>直接<strong>220$ \rightarrow $120</strong>。。。</p>
<p>吐槽一下：<strong>哲哥</strong>最近似乎迷恋上<strong>二分图 &amp; 网络流</strong>了，看啥题<strong>都是</strong>。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/20/wA89HsQlWFgPjEm.png" alt="T20200820-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>作为本套题的<strong>签到题</strong>，自然是灰常简单的。。。</p>
<p>我们可以想到，对于$a_i \leq a_j$，那么$a_i$能直接消灭的敌人，$a_j$也能直接消灭，虽然这题需要有一个$c_i$，我们也可以顺理而下</p>
<p>若$ c_i&gt;a_i $那么直接让$a_i$消灭$c_i$肯定<strong>不会影响</strong>并且<strong>可能</strong>会使结果<strong>更优</strong></p>
<p>因为此时比$a_i$大的数仍可以消灭比$a_i$小的，但若果$a_i$不消灭$c_i$，后边的$a_j$就不一定可以消灭$c_i$</p>
<p><img src="https://i.loli.net/2020/08/20/Nt2pWkYXRDgUdwO.png" alt="T20200820-1.png"></p>
<p>所以，我们可以直接对两个数组<strong>排序</strong>，之后用<strong>指针移动</strong>即可</p>
<p>遇到已经被消灭的，则<strong>跳过</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//guard</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e4</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL N,M,Test;</span><br><span class="line">LL Kill[MAXN],Rev[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL ID,Val;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B)</span><br><span class="line">	&#123; <span class="keyword">return</span> A.Val&lt;B.Val; &#125;</span><br><span class="line">&#125;Num[MAXN],Ene[MAXN];</span><br><span class="line"><span class="keyword">bool</span> Jud[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"guard.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"guard.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL Temp=<span class="number">0</span>,Fac=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> Ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;<span class="string">'9'</span> || Ch&lt;<span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Ch==<span class="string">'-'</span>) Fac=<span class="number">-1</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;=<span class="string">'0'</span> &amp;&amp; Ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">		Temp=(Temp&lt;&lt;<span class="number">1</span>)+(Temp&lt;&lt;<span class="number">3</span>)+Ch-<span class="string">'0'</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fac*Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	Test=Read();</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		Cl(Jud,<span class="literal">false</span>); Cl(Num,<span class="number">0</span>); Cl(Ene,<span class="number">0</span>); Cl(Rev,<span class="number">0</span>); Cl(Kill,<span class="number">0</span>);</span><br><span class="line">		N=Read(); M=Read();</span><br><span class="line">		<span class="keyword">if</span>(N&lt;M) &#123; <span class="built_in">printf</span>(<span class="string">"Fail\n"</span>); <span class="keyword">continue</span>; &#125;</span><br><span class="line">		FOR(i,<span class="number">1</span>,N) &#123; Num[i].Val=Read(); Num[i].ID=i; &#125;</span><br><span class="line">		FOR(i,<span class="number">1</span>,M) &#123; Ene[i].Val=Read(); Ene[i].ID=i; &#125;</span><br><span class="line">		FOR(i,<span class="number">1</span>,N) &#123; Kill[i]=Read(); &#125;</span><br><span class="line">		sort(Num+<span class="number">1</span>,Num+N+<span class="number">1</span>);</span><br><span class="line">		sort(Ene+<span class="number">1</span>,Ene+M+<span class="number">1</span>);</span><br><span class="line">		FOR(i,<span class="number">1</span>,M) &#123; Rev[Ene[i].ID]=i; &#125;</span><br><span class="line">		LL Pos=<span class="number">1</span>;</span><br><span class="line">		FOR(i,<span class="number">1</span>,N) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Ene[Rev[Kill[Num[i].ID]]].Val&gt;Num[i].Val &amp;&amp; !Jud[Rev[Kill[Num[i].ID]]]) &#123; Jud[Rev[Kill[Num[i].ID]]]=<span class="literal">true</span>; <span class="keyword">continue</span>; &#125; </span><br><span class="line">			<span class="keyword">if</span>(Num[i].Val&gt;=Ene[Pos].Val) &#123; </span><br><span class="line">				Jud[Pos]=<span class="literal">true</span>;  </span><br><span class="line">				<span class="keyword">while</span>(Jud[Pos]) Pos++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(Pos&gt;M) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">bool</span> Flag=<span class="literal">true</span>;</span><br><span class="line">		FOR(i,<span class="number">1</span>,M) &#123; <span class="keyword">if</span>(!Jud[i]) Flag=<span class="literal">false</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span>(Flag) &#123; <span class="built_in">printf</span>(<span class="string">"Success\n"</span>); &#125;</span><br><span class="line">		<span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"Fail\n"</span>); &#125;</span><br><span class="line">	&#125;	</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 </span></span><br><span class="line"><span class="comment">4 4 </span></span><br><span class="line"><span class="comment">2 3 4 5 </span></span><br><span class="line"><span class="comment">4 5 6 7 </span></span><br><span class="line"><span class="comment">3 4 3 4 </span></span><br><span class="line"><span class="comment">4 4 </span></span><br><span class="line"><span class="comment">2 3 4 5 </span></span><br><span class="line"><span class="comment">4 5 6 7 </span></span><br><span class="line"><span class="comment">2 2 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>树链剖分</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/20/oT1tJCiBNshpn4b.png" alt="T20200820-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>一看到这两个操作，是个<strong>人</strong>应该都知道这是一个树链剖分吧</p>
<p>由于<strong>异或</strong>满足<strong>结合律</strong>，所以我们在处理线段树更新时直接判断<strong>长度</strong>时候为<strong>奇数</strong>，是则<strong>异或</strong>上新的值，否则只修改Tag</p>
<p>对于区间查询，就直接<strong>异或到底</strong>就可以了。。。</p>
<p>（模板题，不说了，就怪我考试时手残，直接<strong>RE</strong>到底）</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//phase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Num[MAXN],Dot[MAXN];</span><br><span class="line">LL Total,Test,u,v,dfn_num;</span><br><span class="line"><span class="keyword">char</span> Opt[<span class="number">5</span>];</span><br><span class="line">LL Next[MAXN&lt;&lt;<span class="number">1</span>],End[MAXN&lt;&lt;<span class="number">1</span>],Head[MAXN],Cur;</span><br><span class="line">LL Dep[MAXN]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,Son[MAXN],Top[MAXN],Fa[MAXN],Size[MAXN],ID[MAXN];</span><br><span class="line">LL Tree[MAXN&lt;&lt;<span class="number">2</span>],Tag[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"phase.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"phase.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL Temp=<span class="number">0</span>,Fac=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> Ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;<span class="string">'9'</span> || Ch&lt;<span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Ch==<span class="string">'-'</span>) Fac=<span class="number">-1</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;=<span class="string">'0'</span> &amp;&amp; Ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">		Temp=(Temp&lt;&lt;<span class="number">1</span>)+(Temp&lt;&lt;<span class="number">3</span>)+Ch-<span class="string">'0'</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fac*Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(LL From,LL To)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_one</span><span class="params">(LL New,LL Pre)</span> </span>&#123;</span><br><span class="line">	Fa[New]=Pre;</span><br><span class="line">	Size[New]=<span class="number">1</span>;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		Dep[End[i]]=Dep[New]+<span class="number">1</span>;</span><br><span class="line">		DFS_one(End[i],New);</span><br><span class="line">		<span class="keyword">if</span>(Size[End[i]]&gt;Res) &#123; Res=Size[End[i]]; Son[New]=End[i]; &#125;</span><br><span class="line">		Size[New]+=Size[End[i]];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_two</span><span class="params">(LL New,LL Pre,LL Front)</span> </span>&#123;</span><br><span class="line">	Top[New]=Front;</span><br><span class="line">	ID[New]=++dfn_num;</span><br><span class="line">	Dot[dfn_num]=Num[New];</span><br><span class="line">	<span class="keyword">if</span>(Son[New]) DFS_two(Son[New],New,Front);</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre || End[i]==Son[New]) <span class="keyword">continue</span>;</span><br><span class="line">		DFS_two(End[i],New,End[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123; Tree[X]=Tree[Lson]^Tree[Rson]; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L==R) &#123; Tree[X]=Dot[L]; <span class="keyword">return</span> ; &#125;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Tag[X]) &#123;</span><br><span class="line">		LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		Tag[Lson]^=Tag[X];</span><br><span class="line">		Tag[Rson]^=Tag[X];</span><br><span class="line">		<span class="keyword">if</span>((Mid-L+<span class="number">1</span>)%<span class="number">2</span>) &#123; Tree[Lson]^=Tag[X]; &#125;	</span><br><span class="line">		<span class="keyword">if</span>((R-Mid)%<span class="number">2</span>) &#123; Tree[Rson]^=Tag[X]; &#125;</span><br><span class="line">		Tag[X]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">		Tag[X]^=Temp;</span><br><span class="line">		<span class="keyword">if</span>((R-L+<span class="number">1</span>)%<span class="number">2</span>) &#123; Tree[X]^=Temp; &#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Push_down(X,L,R);</span><br><span class="line">	<span class="keyword">if</span>(From&lt;=Mid) &#123; Update(Lson,L,Mid,From,To,Temp); &#125;</span><br><span class="line">	<span class="keyword">if</span>(To&gt;Mid) &#123; Update(Rson,Mid+<span class="number">1</span>,R,From,To,Temp); &#125;</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) <span class="keyword">return</span> Tree[X];</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">	Push_down(X,L,R);</span><br><span class="line">	<span class="keyword">if</span>(From&lt;=Mid) &#123; Res^=Get(Lson,L,Mid,From,To); &#125;</span><br><span class="line">	<span class="keyword">if</span>(To&gt;Mid) &#123; Res^=Get(Rson,Mid+<span class="number">1</span>,R,From,To); &#125;</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Query</span><span class="params">(LL L,LL R)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(Top[L]!=Top[R]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Dep[Top[L]]&lt;Dep[Top[R]]) swap(L,R);</span><br><span class="line">		Res^=Get(<span class="number">1</span>,<span class="number">1</span>,Total,ID[Top[L]],ID[L]);</span><br><span class="line">		L=Fa[Top[L]];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Dep[L]&lt;Dep[R]) swap(L,R);</span><br><span class="line">	Res^=Get(<span class="number">1</span>,<span class="number">1</span>,Total,ID[R],ID[L]);</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">(LL New,LL Val)</span> </span>&#123; Update(<span class="number">1</span>,<span class="number">1</span>,Total,ID[New],ID[New]+Size[New]<span class="number">-1</span>,Val); &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	Total=Read();</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total<span class="number">-1</span>) &#123;</span><br><span class="line">		u=Read(); v=Read();</span><br><span class="line">		Add_Edge(u,v); Add_Edge(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; Num[i]=Read(); &#125;</span><br><span class="line">	Test=Read();</span><br><span class="line">	DFS_one(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	DFS_two(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,Opt);</span><br><span class="line">		u=Read(); v=Read();</span><br><span class="line">		<span class="keyword">if</span>(Opt[<span class="number">0</span>]==<span class="string">'C'</span>) Change(u,v);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Query(u,v));</span><br><span class="line">	&#125;	</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">1 3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">2</span></span><br><span class="line"><span class="comment">C 1 1</span></span><br><span class="line"><span class="comment">Q 2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>期望DP+背包+容斥原理</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/20/n1LUK4XJIY652uH.png" alt="T20200820-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>本题作为压轴题，确实很优秀</p>
<p>（想不到，考试的时候这道题得分的只有我一个。。。）</p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>由于数据灰常小</p>
<p>我们考虑DP[State]表示当前状压之后为State时还<strong>需要多少步才能复活</strong></p>
<script type="math/tex; mode=display">
DP[State]=DP[State] \times \frac{Cnt[State]}{Sta} + DP[State \rightarrow New] \times \frac{Cnt[State \rightarrow New]}{Sta}</script><p>所以关键是求Cnt[State]，我们可以直接<strong>暴力DFS</strong>求可以复活时的所有状态的<strong>Cnt</strong>即可</p>
<p><strong>期望得分：20分</strong></p>
<p><strong>时间复杂度：$ O(2^{nm} nm) $ </strong></p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>50分我们考虑优化状态和转移</p>
<p>表示出<strong>行列</strong>是否被覆盖时的期望步数即可成功</p>
<p><strong>期望得分：50分</strong></p>
<p><strong>时间复杂度：$ O(能得50分) $ </strong></p>
<h4 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h4><p>我们在得50分时，已经考虑了行列的状态，差的就是<strong>亿点点</strong></p>
<p>我们设$P(i)$表示，取了$i$次，我们<strong>还没有复活的概率</strong></p>
<p>由：</p>
<script type="math/tex; mode=display">
Ans=P(0)+P(1)+P(2)+ \cdots P( \infin)</script><p>设我们的状态为$S$</p>
<p>因为$i$次还没有复活的概率是$ (1-P(S))^i $</p>
<p>所以</p>
<script type="math/tex; mode=display">
P(i)= \sum_{|S| \equiv 1(mod\,\,\,2)} (1-P(S))^i - \sum_{|S| \equiv 0(mod\,\,\,2)} (1-P(S))^i</script><p>进一步</p>
<script type="math/tex; mode=display">
Ans= \sum_{i=0}^{ \infin} ( \sum_{|S| \equiv 1 (mod\,\,\,2)} (1-P(S))^i \sum_{|S| \equiv 0 (mod\,\,\,2)} (1-P(S))^i) \\
=\sum_{|S| \equiv 1 (mod\,\,\,2)} \frac{1}{P(S)} - \sum_{|S| \equiv 0 (mod\,\,\,2)} \frac{1}{P(S)}</script><p>设Dot[S]表示S集合中有的点数，Sta表示总的点数</p>
<p>因为$ P(S)= \frac{Dot[S]}{Sta} $，所以</p>
<script type="math/tex; mode=display">
Ans= \sum_{|S| \equiv 1 (mod\,\,\,2)} \frac{Sta}{Dot[S]} - \sum_{|S| \equiv 0(mod\,\,\,2)} \frac{Sta}{Dot[S]}</script><p>这样的话还是不够优秀，考虑稍微优化一下</p>
<p>设Num[X]表示集合大小是X的S有多少个（<strong>奇数集合数-偶数集合数</strong>后的Num[X]）</p>
<p>所以</p>
<script type="math/tex; mode=display">
Ans= \sum_{X=1}^{Sta} Num[X] \times \frac{Sta}{X}</script><p>最终我们的瓶颈就在求Num[X]上了，由于$ nm \leq 200 $所以一定有$n$或$m$ $ \leq 14 $，我们直接暴力枚举这一维，另一维做一个<strong>背包</strong>求出集合大小为X时的方案数，暴力加到Num中即可</p>
<p>吐槽一波：改题时，<code>freopen(&quot;refuse.in&quot;...)</code>写成了<code>freopen(&quot;refuse,in&quot;...)</code>改了2个多小时，扎心了<strong>（JK.jpg）</strong></p>
<p><strong>期望得分：100分</strong></p>
<p><strong>时间复杂度：$ O(2^{n+m} n^2m) $ </strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//refuse</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">210</span>;</span><br><span class="line"></span><br><span class="line">LL Row,Line;</span><br><span class="line">LL Num[MAXN],Sta,Map[MAXN][MAXN];</span><br><span class="line">LL DP[MAXN][<span class="number">2</span>][MAXN];</span><br><span class="line"><span class="keyword">bool</span> Jud[MAXN];</span><br><span class="line"><span class="keyword">double</span> Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Calc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(DP,<span class="number">0</span>);</span><br><span class="line">	DP[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	LL New=<span class="number">0</span>,Temp=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Line) &#123;</span><br><span class="line">		Temp=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">1</span>,Row) <span class="keyword">if</span>(Map[j][i] &amp;&amp; !Jud[j]) Temp++;</span><br><span class="line">		FOR(j,<span class="number">0</span>,New) &#123; DP[i][<span class="number">0</span>][j]+=DP[i<span class="number">-1</span>][<span class="number">0</span>][j]; DP[i][<span class="number">1</span>][j+Temp]+=DP[i<span class="number">-1</span>][<span class="number">0</span>][j]; &#125;</span><br><span class="line">		FOR(j,<span class="number">0</span>,New) &#123; DP[i][<span class="number">1</span>][j]+=DP[i<span class="number">-1</span>][<span class="number">1</span>][j]; DP[i][<span class="number">0</span>][j+Temp]+=DP[i<span class="number">-1</span>][<span class="number">1</span>][j]; &#125;</span><br><span class="line">		New+=Temp;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Opt=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) Opt^=Jud[i];</span><br><span class="line">	Temp=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Row) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!Jud[i]) <span class="keyword">continue</span>;</span><br><span class="line">		FOR(j,<span class="number">1</span>,Line) <span class="keyword">if</span>(Map[i][j]) Temp++;</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">0</span>,New) Num[i+Temp]+=(LL)(((LL)(Opt^<span class="number">0</span>)*<span class="number">2</span>)<span class="number">-1</span>)*(DP[Line][<span class="number">0</span>][i]);</span><br><span class="line">	FOR(i,<span class="number">0</span>,New) Num[i+Temp]+=(LL)(((LL)(Opt^<span class="number">1</span>)*<span class="number">2</span>)<span class="number">-1</span>)*(DP[Line][<span class="number">1</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(LL Loc)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Loc&gt;Row) &#123; Calc(); <span class="keyword">return</span> ; &#125;</span><br><span class="line">	Jud[Loc]=<span class="number">0</span>; DFS(Loc+<span class="number">1</span>); </span><br><span class="line">	Jud[Loc]=<span class="number">1</span>; DFS(Loc+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"refuse.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"refuse.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Row,&amp;Line);</span><br><span class="line">	<span class="keyword">if</span>(Row&lt;Line) &#123; FOR(i,<span class="number">1</span>,Row) FOR(j,<span class="number">1</span>,Line) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Map[i][j]); Sta+=Map[i][j]; &#125; &#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; FOR(j,<span class="number">1</span>,Row) FOR(i,<span class="number">1</span>,Line) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Map[i][j]); Sta+=Map[i][j]; &#125; swap(Row,Line); &#125;</span><br><span class="line">	DFS(<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Sta) Ans+=((<span class="keyword">double</span>)(Num[i])*Sta/i);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%.5lf"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200821赛后总结</title>
    <url>/articles/T20200821%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200821赛后总结"><a href="#T20200821赛后总结" class="headerlink" title="T20200821赛后总结"></a>T20200821赛后总结</h1><h2 id="成绩排行：T20200821成绩"><a href="#成绩排行：T20200821成绩" class="headerlink" title="成绩排行：T20200821成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.21/result20200821.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.21/result20200821.html">T20200821成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>考试策略上无了。。。</p>
<p><strong>死磕</strong>T1，最终实现还是错误，靠T2的<strong>暴力分</strong></p>
<p>勉强没有<strong>爆零</strong>。。。</p>
<p>想到的一定要充分挖掘性质！</p>
<p><strong>在线膜喹啉巨佬%%%</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>Dijkstra+最短路树</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/SyhdLlwH78AIX19.png" alt="T20200821-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们必须想到的就是，可以<strong>暴力</strong>做<strong>Dijkstra的全源最短路</strong></p>
<p>之后我们考虑在生成之后可以干嘛</p>
<p>是一颗最短路树？</p>
<p>不！由于题目中的特殊性质—长度一样经过的边不一样的也算不一样的最短路</p>
<p>所以生成的一个图是一个<strong>最短路DAG</strong></p>
<p>手摸之后可以知道对于一条边，它被经过的次数是<strong>进入的方案数$ \times $出去的方案数</strong></p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/08/23/G4eqKMm786Qoyxv.png" alt="T20200821-1.png"></p>
<p>所以我们可以直接分别两遍<strong>拓扑</strong>之后将每一条边的进入方案数与出去方案数相乘加入答案即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这个代码好像还是有点问题，对于重边需要加特殊处理</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//path</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i]) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e3</span>+<span class="number">10</span>,MAXM=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Side,u,v,w,Cnt[MAXN],Sig[MAXN];</span><br><span class="line">LL Next[MAXM],Head[MAXN],End[MAXM],Val[MAXM],Cur;</span><br><span class="line">LL RNext[MAXM],RHead[MAXN],REnd[MAXM],RVal[MAXM],RCur;</span><br><span class="line">LL Dist[MAXN],Ans[MAXM],RD[MAXN],CD[MAXN];</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN],Jud[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL Len,ID;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (Node A,Node B)</span><br><span class="line">	&#123; <span class="keyword">return</span> A.Len&lt;B.Len; &#125;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B)</span><br><span class="line">	&#123; <span class="keyword">return</span> A.Len&gt;B.Len; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt;Queue;</span><br><span class="line"><span class="built_in">queue</span>&lt;LL&gt;Mine;</span><br><span class="line"><span class="built_in">queue</span>&lt;LL&gt;Rev;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	RNext[++RCur]=RHead[To];</span><br><span class="line">	RHead[To]=RCur;</span><br><span class="line">	REnd[RCur]=From;</span><br><span class="line">	RVal[RCur]=Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(LL Temp)</span> </span>&#123;</span><br><span class="line">	Dist[Temp]=<span class="number">0</span>;</span><br><span class="line">	Queue.push(Node&#123; <span class="number">0</span>,Temp &#125;);</span><br><span class="line">	<span class="keyword">while</span>(!Queue.empty()) &#123;</span><br><span class="line">		Node New=Queue.top();</span><br><span class="line">		Queue.pop();</span><br><span class="line">		<span class="keyword">if</span>(Vis[New.ID]) <span class="keyword">continue</span>;</span><br><span class="line">		Vis[New.ID]=<span class="literal">true</span>;</span><br><span class="line">		FOR_SIDE(i,New.ID) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dist[End[i]]&gt;New.Len+Val[i]) &#123;</span><br><span class="line">				Dist[End[i]]=New.Len+Val[i];</span><br><span class="line">				Queue.push(Node&#123; Dist[End[i]],End[i] &#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) FOR_SIDE(j,i) </span><br><span class="line">		<span class="keyword">if</span>(Dist[i]+Val[j]==Dist[End[j]]) Jud[End[j]][i]=<span class="literal">true</span>,RD[End[j]]++,CD[i]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!RD[i]) Mine.push(i),Cnt[i]=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(!CD[i]) Rev.push(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) &#123;</span><br><span class="line">		LL New=Mine.front();</span><br><span class="line">		Mine.pop();</span><br><span class="line">		FOR_SIDE(i,New) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!Jud[End[i]][New]) <span class="keyword">continue</span>;</span><br><span class="line">			(Cnt[End[i]]+=Cnt[New])%=MOD;</span><br><span class="line">			<span class="keyword">if</span>(!(--RD[End[i]])) Mine.push(End[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Dist,<span class="number">0x3f</span>); Cl(RD,<span class="number">0</span>); Cl(Sig,<span class="number">0</span>); Cl(CD,<span class="number">0</span>);</span><br><span class="line">	Cl(Vis,<span class="literal">false</span>); Cl(Jud,<span class="literal">false</span>); Cl(Cnt,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">while</span>(!Queue.empty()) Queue.pop();</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) Mine.pop();</span><br><span class="line">	<span class="keyword">while</span>(!Rev.empty()) Rev.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Sig[i]=<span class="number">1</span>;	</span><br><span class="line">	<span class="keyword">while</span>(!Rev.empty()) &#123;</span><br><span class="line">		LL New=Rev.front();</span><br><span class="line">		Rev.pop();</span><br><span class="line">		<span class="keyword">for</span>(LL i=RHead[New];i;i=RNext[i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!Jud[New][REnd[i]]) <span class="keyword">continue</span>;</span><br><span class="line">			(Sig[REnd[i]]+=Sig[New])%=MOD;</span><br><span class="line">			(Ans[i]+=(Cnt[REnd[i]]*Sig[New])%MOD)%=MOD;</span><br><span class="line">			<span class="keyword">if</span>(!(--CD[REnd[i]])) Rev.push(REnd[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"path.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"path.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Side);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;u,&amp;v,&amp;w); Add_Edge(u,v,w); &#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		Clean();</span><br><span class="line">		Dijkstra(i);</span><br><span class="line">		Solve();</span><br><span class="line">		DFS();</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Cur) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans[i]%MOD);</span><br><span class="line"><span class="comment">//	fclose(stdin); fclose(stdout);</span></span><br><span class="line">	system(<span class="string">"pause"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4 </span></span><br><span class="line"><span class="comment">1 2 5 </span></span><br><span class="line"><span class="comment">2 3 5 </span></span><br><span class="line"><span class="comment">3 4 5 </span></span><br><span class="line"><span class="comment">1 4 8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 10</span></span><br><span class="line"><span class="comment">1 2 7</span></span><br><span class="line"><span class="comment">1 3 1</span></span><br><span class="line"><span class="comment">1 4 6</span></span><br><span class="line"><span class="comment">2 5 8</span></span><br><span class="line"><span class="comment">3 5 10</span></span><br><span class="line"><span class="comment">4 5 5</span></span><br><span class="line"><span class="comment">5 6 2</span></span><br><span class="line"><span class="comment">6 7 5</span></span><br><span class="line"><span class="comment">6 8 6</span></span><br><span class="line"><span class="comment">6 9 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">9 10</span></span><br><span class="line"><span class="comment">1 2 4</span></span><br><span class="line"><span class="comment">1 3 5</span></span><br><span class="line"><span class="comment">2 4 4</span></span><br><span class="line"><span class="comment">2 8 5</span></span><br><span class="line"><span class="comment">2 5 4</span></span><br><span class="line"><span class="comment">5 8 5</span></span><br><span class="line"><span class="comment">5 9 4</span></span><br><span class="line"><span class="comment">3 5 5</span></span><br><span class="line"><span class="comment">3 6 4</span></span><br><span class="line"><span class="comment">3 7 5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 4</span></span><br><span class="line"><span class="comment">1 2 2</span></span><br><span class="line"><span class="comment">1 3 2</span></span><br><span class="line"><span class="comment">2 4 2</span></span><br><span class="line"><span class="comment">3 4 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>分块</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/c3Z4REfKSN2TOVr.png" alt="T20200821-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看到这个不大不小的数据范围<strong>直接</strong>就可以想到<strong>分块</strong>！</p>
<p>所以，我们这道题直接分块秒杀？</p>
<p>对于每一个块维护<strong>左右递增序列</strong>即可</p>
<p>其他的无需多言</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; T <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	T x=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=getchar())<span class="keyword">if</span>(c==<span class="string">'-'</span>) w=-w; </span><br><span class="line">	<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=getchar()) x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">	<span class="keyword">return</span> x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; T <span class="title">read</span><span class="params">(T&amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x=<span class="built_in">read</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> co const</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">co <span class="keyword">int</span> N=<span class="number">50000</span>+<span class="number">10</span>,B=<span class="number">883</span>+<span class="number">10</span>,M=<span class="number">56</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> A[N],bel[N];</span><br><span class="line"><span class="keyword">int</span> L[M],R[M],st[M][B],top[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> st[],<span class="keyword">int</span>&amp;top)</span></span>&#123;</span><br><span class="line">	top=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=r;i&gt;=l;--i)&#123;</span><br><span class="line">		<span class="keyword">while</span>(top&amp;&amp;A[st[top]]&lt;A[i]) --top;</span><br><span class="line">		st[++top]=i;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> bl=bel[p],mx=A[p];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=p+<span class="number">1</span>;i&lt;=R[bl];++i)&#123;</span><br><span class="line">		mx=<span class="built_in">max</span>(mx,A[i]);</span><br><span class="line">		<span class="keyword">if</span>(mx&lt;=<span class="built_in">max</span>(A[p],A[i])) ++ans;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=bl+<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">		<span class="keyword">int</span> l=<span class="number">0</span>,r=top[i];</span><br><span class="line">		<span class="keyword">if</span>(mx==A[p])&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">				<span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(A[st[i][mid]]&gt;mx) l=mid;</span><br><span class="line">				<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(l==<span class="number">0</span>) ans+=R[i]-L[i]+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				ans+=st[i][l]<span class="number">-1</span>-L[i]+<span class="number">1</span>;</span><br><span class="line">				ans+=l<span class="number">-1</span>+<span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">				<span class="keyword">int</span> mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span>(A[st[i][mid]]&gt;=mx) l=mid;</span><br><span class="line">				<span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans+=l<span class="number">-1</span>+<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mx=<span class="built_in">max</span>(mx,A[st[i][<span class="number">1</span>]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	freopen(<span class="string">"seq.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>),freopen(<span class="string">"seq.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">int</span> n=<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;(),m=<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">	<span class="keyword">int</span> siz=<span class="built_in">sqrt</span>(n*log2(n)),num=(n+siz<span class="number">-1</span>)/siz;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">read</span>(A[i]),bel[i]=(i+siz<span class="number">-1</span>)/siz;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;++i)&#123;</span><br><span class="line">		L[i]=R[i<span class="number">-1</span>]+<span class="number">1</span>,R[i]=<span class="built_in">min</span>(i*siz,n);</span><br><span class="line">		change(L[i],R[i],st[i],top[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">char</span> opt[<span class="number">2</span>];m--;)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,opt);</span><br><span class="line">		<span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">'C'</span>)&#123;</span><br><span class="line">			<span class="keyword">int</span> p=<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			A[p]=<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">			<span class="keyword">int</span> bl=bel[p];</span><br><span class="line">			change(L[bl],R[bl],st[bl],top[bl]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,query(<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;(),num));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>计算几何+扫描线</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/6zPZUJTtp4u7avC.png" alt="T20200821-C.png"></p>
<h3 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h3><p><strong>冷静分析.jpg</strong></p>
<p>在看上一届大佬的Blog的时候了解到，这TM的可以直接作<strong>world final</strong>的题了，好吧！</p>
<p>这道题<strong>又臭又长</strong>，直接放弃！当然，数据似乎比较水？</p>
<p>全机房直接放弃改这道题？</p>
<p><strong>是人性的扭曲，还是道德的沦丧</strong></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200822赛后总结</title>
    <url>/articles/T20200822%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200822赛后总结"><a href="#T20200822赛后总结" class="headerlink" title="T20200822赛后总结"></a>T20200822赛后总结</h1><h2 id="成绩排行：T20200822成绩"><a href="#成绩排行：T20200822成绩" class="headerlink" title="成绩排行：T20200822成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.22/result20200822.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.22/result20200822.html">T20200822成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写赛后总结之前先膜一把<strong>喹啉巨佬%%%</strong></p>
<p><strong>T1</strong>日常爆炸。。。</p>
<p>自认为写了一个$ O(n \sqrt{n}) $的好算法</p>
<p>没想到还是哲哥的$ O(n \sqrt{n} logn) $算法过得好。。。</p>
<p><strong>蒟蒻</strong>在线求<strong>翻盘</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>分块+树链剖分</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/D3jS1KW5LdXTyAx.png" alt="T20200822-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>发现纯树链剖分是<strong>无法维护</strong>的，所以我们可以考虑对于初始化的数列进行<strong>分块</strong>操作</p>
<p>在查询的时候无需赘述</p>
<p>修改时我们需要我们记录$Cnt$直接一个块一个块得更改即可</p>
<p>因为每次都只会更改当前节点的<strong>父亲节点的所在块</strong>的信息</p>
<p><img src="https://i.loli.net/2020/08/23/2Jt9xi4ulNBsUYj.png" alt="T20200822-1.png"></p>
<p>关于我写挂的原因，改题时想了很久，发现是<strong>Tag</strong>的更改无法做到随时用随时有，所以这个一定要考虑周全</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>此处贴一个哲哥的代码，因为我实在是改的心态炸裂。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">LL <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	LL x = <span class="number">0</span>,f = <span class="number">0</span>;<span class="keyword">char</span> ch = getchar();</span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span>(ch == <span class="string">'-'</span>)f = <span class="number">1</span>;ch=getchar();&#125;</span><br><span class="line">	<span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch)) &#123;x = x * <span class="number">10</span> + ch - <span class="string">'0'</span>;ch = getchar();&#125;</span><br><span class="line">	<span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> rt,nxt[N&lt;&lt;<span class="number">1</span>],to[N&lt;&lt;<span class="number">1</span>],head[N],fa[N],Cnt,n,m,dfn[N],Tim,si[N],S,f[N][<span class="number">350</span>];</span><br><span class="line">ull sum[N&lt;&lt;<span class="number">2</span>],val[N],Ans[<span class="number">350</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> pos,ull k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">		sum[u] = k;<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(pos &lt;= mid) update(u&lt;&lt;<span class="number">1</span>,l,mid,pos,k);</span><br><span class="line">	<span class="keyword">else</span> update(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,pos,k);</span><br><span class="line">	sum[u] = sum[u &lt;&lt; <span class="number">1</span>] + sum[u &lt;&lt; <span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">ask</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt; R || r &lt; L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R) <span class="keyword">return</span> <span class="number">1u</span>ll*sum[u];</span><br><span class="line">	<span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1u</span>ll * ask(u&lt;&lt;<span class="number">1</span>,l,mid,L,R) + ask(u&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,L,R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> F)</span></span>&#123;</span><br><span class="line">	fa[x] = F;</span><br><span class="line">	si[x] = <span class="number">1</span>;</span><br><span class="line">	dfn[x] = ++Tim;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= S;i++) f[x][i] = f[F][i];</span><br><span class="line">	f[x][(x<span class="number">-1</span>)/S]++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = head[x];i;i = nxt[i])&#123;</span><br><span class="line">		<span class="keyword">if</span>(to[i] ^ F) &#123;</span><br><span class="line">			dfs(to[i],x);</span><br><span class="line">			si[x] += si[to[i]];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(ull x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x &gt;= <span class="number">10</span>) Print(x / <span class="number">10</span>);</span><br><span class="line">	<span class="built_in">putchar</span>(x % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	freopen(<span class="string">"common.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"common.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	n = <span class="built_in">read</span>();m = <span class="built_in">read</span>();</span><br><span class="line">	S = <span class="built_in">sqrt</span>(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//	S = 325;</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; S &lt;&lt; endl;</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++) val[i] = <span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="built_in">read</span>(),b = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(a == <span class="number">0</span>) rt = b;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			to[++Cnt] = b;nxt[Cnt] = head[a];head[a] = Cnt;</span><br><span class="line">			to[++Cnt] = a;nxt[Cnt] = head[b];head[b] = Cnt;</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(rt,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		update(<span class="number">1</span>,<span class="number">1</span>,n,dfn[i],val[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n;i++)&#123;</span><br><span class="line">		Ans[(i<span class="number">-1</span>)/S] += ask(<span class="number">1</span>,<span class="number">1</span>,n,dfn[i],dfn[i]+si[i]<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> opt = <span class="built_in">read</span>(),x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(opt == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;= S;i++) Ans[i] -= f[x][i] * val[x] , Ans[i] += f[x][i] * y;</span><br><span class="line">			update(<span class="number">1</span>,<span class="number">1</span>,n,dfn[x],y);val[x] = y;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			ull ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">int</span> l = x,r = y;</span><br><span class="line">			<span class="keyword">if</span>((l<span class="number">-1</span>)/S == (r<span class="number">-1</span>)/S) &#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = l;i &lt;= r;i++)&#123;</span><br><span class="line">					ans += ask(<span class="number">1</span>,<span class="number">1</span>,n,dfn[i],dfn[i]+si[i]<span class="number">-1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = l;(i<span class="number">-1</span>)/S == (l<span class="number">-1</span>)/S;i++) ans += ask(<span class="number">1</span>,<span class="number">1</span>,n,dfn[i],dfn[i]+si[i]<span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = (l<span class="number">-1</span>)/S + <span class="number">1</span>;i &lt; (r<span class="number">-1</span>)/S;i++) ans += Ans[i];</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> i = r;(i<span class="number">-1</span>)/S == (r<span class="number">-1</span>)/S;i--) ans += ask(<span class="number">1</span>,<span class="number">1</span>,n,dfn[i],dfn[i]+si[i]<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			Print(ans);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>Prufer序列</strong></p>
<p><strong>（生成树计数？）</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/d2hZfk1QVGoltHY.png" alt="T20200822-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>这道题对于没有学过Prufer序列的大佬们来说，可能还是很难的</p>
<p>（因为真的摸不着头绪）</p>
<p>但对于我这种学过的蒟蒻，<strong>手推一下</strong>就出来了</p>
<p>考虑完全二分图的生成树Prufer序列长度为$ n+m-1 $，并且每一侧的点是<strong>互相独立</strong>的，也就是说我处理了当前节点，若在左图，则下一个处理的点一定在右图</p>
<p>类比于<strong>完全图</strong>的生成树个数$ n^{n-2} $，我们就可以直接写出这个<strong>完全二分图</strong>的生成树个数为$ n^{m-1} \times m^{n-1} $</p>
<p><strong>温馨提示：</strong>这道题由于<strong>模数</strong>十分的大，需要<strong>龟速乘</strong>才可以</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//art</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL N,M,MOD;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Mul</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; (Res+=A)%=MOD; &#125;</span><br><span class="line">		(A+=A)%=MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Res%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; Res=(Mul(A,Res))%MOD; &#125;</span><br><span class="line">		A=(Mul(A,A))%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Res%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"art.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"art.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;N,&amp;M,&amp;MOD);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Mul(Fast(N,M<span class="number">-1</span>),Fast(M,N<span class="number">-1</span>))%MOD+MOD)%MOD);</span><br><span class="line"><span class="comment">//	system("pause");</span></span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>（高斯消元？）+组合数学+容斥原理</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/23/SHOdpNamtrEJoyL.png" alt="T20200822-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>我们注意到数据范围第三行的部分分，我们可以断定这道题绝对是需要<strong>转换坐标系</strong>的</p>
<p>若我们当前可以走$ (A_x,A_y),(B_x,B_y) $</p>
<p>那么我们可以列出方程</p>
<script type="math/tex; mode=display">
A_x \times u + B_x \times v =Endx \\
A_y \times u + B_y \times v =Endy</script><p>所以，$ u,v $其实是<strong>唯一解</strong>（因为$ A_x \cdot B_y -A_y \cdot B_x \neq 0 $）</p>
<p>那么我们就可以转化新的坐标系，$ (Endx,Endy) \Rightarrow (Newx,Newy) $，并且我们只能走$ (1,0),(0,1) $</p>
<p>所以我们直接<strong>容斥</strong>即可</p>
<p>$ F_{i} $表示从原点到$i$<strong>不经过障碍</strong>的方案数</p>
<p>$ G_{j,i} $表示从$j$到$i$的方案数</p>
<script type="math/tex; mode=display">
F_{i} = G_{0,i} - \sum^{i-1}_{j=1} F_{j} \times G_{j,i}</script><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> Ex,Ey,n,Ax,Ay,Bx,By,inv[N],jc[N],jcn[N],f[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> x,y;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x==b.x?y&lt;b.y:x&lt;b.x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a1=x*By-y*Bx,a2=Ax*By-Ay*Bx;</span><br><span class="line">	<span class="keyword">int</span> b1=x*Ay-y*Ax,b2=Ay*Bx-Ax*By;</span><br><span class="line">	<span class="keyword">if</span> (!a2||!b2) &#123;x=y=<span class="number">-1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">if</span> (a1/a2*a2!=a1||b1/b2*b2!=b1) &#123;x=y=<span class="number">-1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">	x=a1/a2;y=b1/b2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1l</span>l*jc[n]*jcn[m]%mod*jcn[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x&lt;<span class="number">0</span>||y&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> C(x+y,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Ex,&amp;Ey,&amp;n);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d"</span>,&amp;Ax,&amp;Ay,&amp;Bx,&amp;By);</span><br><span class="line">	work(Ex,Ey);<span class="keyword">if</span> (Ex&lt;<span class="number">0</span>&amp;&amp;Ey&lt;<span class="number">0</span>) &#123; <span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		a[i].x=gi(),a[i].y=gi();work(a[i].x,a[i].y);</span><br><span class="line">		<span class="keyword">if</span> (a[i].x&lt;<span class="number">0</span>||a[i].y&lt;<span class="number">0</span>||a[i].x&gt;Ex||a[i].y&gt;Ey) --n,--i;</span><br><span class="line">	&#125;</span><br><span class="line">	a[++n]=(node)&#123;Ex,Ey&#125;;sort(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">	jc[<span class="number">0</span>]=jcn[<span class="number">0</span>]=inv[<span class="number">0</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;N;++i) inv[i]=<span class="number">1l</span>l*inv[mod%i]*(mod-mod/i)%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i) jc[i]=<span class="number">1l</span>l*jc[i<span class="number">-1</span>]*i%mod,jcn[i]=<span class="number">1l</span>l*jcn[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">		f[i]=cal(a[i].x,a[i].y);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;i;++j)</span><br><span class="line">			f[i]=(f[i]<span class="number">-1l</span>l*f[j]*cal(a[i].x-a[j].x,a[i].y-a[j].y)%mod+mod)%mod;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,f[n]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200824赛后总结</title>
    <url>/articles/T20200824%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200824赛后总结"><a href="#T20200824赛后总结" class="headerlink" title="T20200824赛后总结"></a>T20200824赛后总结</h1><h2 id="成绩排行：T20200824成绩"><a href="#成绩排行：T20200824成绩" class="headerlink" title="成绩排行：T20200824成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.24/result_20200824.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.24/result_20200824.html">T20200824成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正常发挥，就是最后一个多小时有点<strong>浮躁</strong>，没有静心思考T3，说不定能拿分呢。。。</p>
<p>有个大佬在看完题之后直接说T3是个插头DP，吓得我一激灵。。。</p>
<p>对于实现，一定要多<strong>对拍</strong>，这次和机房大佬们一起造数据对拍贼带感！</p>
<p>当然，对于<strong>数据范围</strong>把握还是非常重要的，对于想正解很有帮助</p>
<p>翻了一下学长们的Blog，发现学长们的原题大战太阔怕了<strong>/jk</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>回文自动机+动态规划</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/24/wUacKzMIeBOYSVu.png" alt="T20200824-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先，在考试的时候没人学了回文自动机，所以都<strong>咕咕</strong>了。。。</p>
<p>但学了之后，感觉还是灰常好的！</p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>对于$ 60 \% $的数据，我们考虑$ O(|S|^{3}T) $的做法</p>
<p>因为生成一个子串的可能方案只有三种</p>
<ul>
<li>在<strong>左侧</strong>加一个</li>
<li>在<strong>右侧</strong>加一个</li>
<li>若是回文串，可以直接<strong>对称变化</strong>一次</li>
</ul>
<p>所以我们直接<strong>区间DP</strong>即可</p>
<p>时间复杂度：$ O(|S|^3) $</p>
<p>期望得分：60分</p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>因为生成串一定是只有两种可能方案</p>
<ul>
<li>由一个长度$ \geq \frac{Len_i}{2} $的子串在两侧加得</li>
<li>有一个长度$ &lt; \frac{Len_i}{2} $的子串翻折再加上两侧的得到</li>
</ul>
<p>且因为串中可以由2得到的，只是<strong>偶数长度的回文串</strong></p>
<p>所以我们可以考虑回文自动机，设<code>Trans</code>为当前串中长度不超过$ \frac{Len}{2} $的<strong>最长后缀回文串</strong>。动态规划对于<code>DP[i]</code>表示$i$对应的回文串生成需要的<strong>最少步数 </strong></p>
<h4 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h4><p>对于自动机的遍历我们一般有三种方式</p>
<ul>
<li>DFS</li>
<li>Topo</li>
<li>基数排序</li>
</ul>
<p>这道题<strong>直接否定</strong>1，3种，至于为什么，请大佬们自己思考</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dna</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test,Len,Size,Pos,Cop[MAXN];</span><br><span class="line"><span class="keyword">int</span> DP[MAXN],Ans,Last;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Str</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> Link,Trans,Len;</span><br><span class="line">	<span class="keyword">int</span> Ch[<span class="number">5</span>];</span><br><span class="line">&#125;State[MAXN];</span><br><span class="line"><span class="keyword">char</span> Num[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;Mine;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Change</span><span class="params">(<span class="keyword">char</span> Temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Temp==<span class="string">'A'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Temp==<span class="string">'G'</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Temp==<span class="string">'C'</span>) <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(State,<span class="number">0</span>);</span><br><span class="line">	Cl(DP,<span class="number">0</span>);</span><br><span class="line">	Size=<span class="number">1</span>; Pos=<span class="number">0</span>; Ans=Len; Last=<span class="number">0</span>;</span><br><span class="line">	State[<span class="number">1</span>].Len=<span class="number">-1</span>;</span><br><span class="line">	State[<span class="number">1</span>].Link=<span class="number">1</span>;</span><br><span class="line">	State[<span class="number">0</span>].Link=<span class="number">1</span>;</span><br><span class="line">	Cop[<span class="number">0</span>]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get_Last</span><span class="params">(<span class="keyword">int</span> New)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Cop[Pos]!=Cop[Pos-State[New].Len<span class="number">-1</span>]) </span><br><span class="line">		New=State[New].Link;</span><br><span class="line">	<span class="keyword">return</span> New;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> New)</span> </span>&#123;</span><br><span class="line">	Cop[++Pos]=New;</span><br><span class="line">	<span class="keyword">int</span> Cur=Get_Last(Last);</span><br><span class="line">	<span class="keyword">if</span>(!State[Cur].Ch[New]) &#123;</span><br><span class="line">		State[++Size].Len=State[Cur].Len+<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">int</span> Loc=Get_Last(State[Cur].Link);</span><br><span class="line">		State[Size].Link=State[Loc].Ch[New];</span><br><span class="line">		<span class="keyword">if</span>(State[Size].Len&lt;=<span class="number">2</span>) State[Size].Trans=State[Size].Link;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> To=State[Cur].Trans;</span><br><span class="line">			<span class="keyword">while</span>(Cop[Pos]!=Cop[Pos-State[To].Len<span class="number">-1</span>] || (State[To].Len+<span class="number">2</span>)*<span class="number">2</span>&gt;State[Size].Len) </span><br><span class="line">				To=State[To].Link;</span><br><span class="line">			State[Size].Trans=State[To].Ch[New];</span><br><span class="line">		&#125;</span><br><span class="line">		State[Cur].Ch[New]=Size;</span><br><span class="line">	&#125;</span><br><span class="line">	Last=State[Cur].Ch[New];</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"dna.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"dna.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inline void DFS(int New) &#123;</span></span><br><span class="line"><span class="comment">//	FOR(k,1,4) &#123;</span></span><br><span class="line"><span class="comment">//		if(!State[New].Ch[k]) continue;</span></span><br><span class="line"><span class="comment">//		int Temp=State[New].Ch[k];</span></span><br><span class="line"><span class="comment">//		DP[Temp]=DP[New]+1;</span></span><br><span class="line"><span class="comment">//		DP[Temp]=min(DP[Temp],State[Temp].Len/2-State[State[Temp].Trans].Len+DP[State[Temp].Trans]+1);</span></span><br><span class="line"><span class="comment">//		Ans=min(Ans,Len-State[Temp].Len+DP[Temp]);</span></span><br><span class="line"><span class="comment">//		DFS(Temp);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Test);</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%s"</span>,Num+<span class="number">1</span>);</span><br><span class="line">		Len=<span class="built_in">strlen</span>(Num+<span class="number">1</span>);</span><br><span class="line">		Init(); </span><br><span class="line">		FOR(i,<span class="number">1</span>,Len) Update(Change(Num[i]));</span><br><span class="line"><span class="comment">//		FOR(i,0,Size) printf("i:%d Link:%d Trans:%d Len:%d\n",i,State[i].Link,State[i].Trans,State[i].Len);</span></span><br><span class="line">		FOR(i,<span class="number">2</span>,Size) <span class="keyword">if</span>(State[i].Len &amp; <span class="number">1</span>) DP[i]=State[i].Len;</span><br><span class="line">		DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//		DFS(0);</span></span><br><span class="line">		<span class="keyword">while</span>(!Mine.empty()) Mine.pop();</span><br><span class="line">		Mine.push(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">while</span>(!Mine.empty()) &#123;</span><br><span class="line">			<span class="keyword">int</span> New=Mine.front();</span><br><span class="line">			Mine.pop();</span><br><span class="line">			FOR(i,<span class="number">1</span>,<span class="number">4</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span>(State[New].Ch[i]) &#123;</span><br><span class="line">					<span class="keyword">int</span> Temp=State[New].Ch[i];</span><br><span class="line">					DP[Temp]=DP[New]+<span class="number">1</span>;</span><br><span class="line">					DP[Temp]=<span class="built_in">min</span>(DP[Temp],State[Temp].Len/<span class="number">2</span>-State[State[Temp].Trans].Len+DP[State[Temp].Trans]+<span class="number">1</span>);</span><br><span class="line">					Ans=<span class="built_in">min</span>(Ans,Len-State[Temp].Len+DP[Temp]);</span><br><span class="line">					Mine.push(Temp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		FOR(i,0,Size) cout&lt;&lt;"i:"&lt;&lt;i&lt;&lt;" "&lt;&lt;"DP:"&lt;&lt;DP[i]&lt;&lt;endl;</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Ans);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	fclose(stdin); fclose(stdout);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4</span></span><br><span class="line"><span class="comment">AAAA</span></span><br><span class="line"><span class="comment">AGCTTGCA</span></span><br><span class="line"><span class="comment">AAGGGGAAGGGGAA</span></span><br><span class="line"><span class="comment">AAACAGTCCTGACAAAAAAAAAAAAC</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">TGAGAG</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>树链剖分</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/24/IHO7xTwpZqloCAQ.png" alt="T20200824-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题为某场比赛的<strong>原题</strong>。。。（后来团队出<strong>信心赛</strong>，又考了一次）</p>
<p>因为两点的<strong>树上简单路径</strong>长度为</p>
<script type="math/tex; mode=display">
Dep[i]+Dep[j]-2 \times Dep[LCA(i,j)]</script><p>所以我们只需要处理出这个式子中的<strong>每一个元素</strong>即可</p>
<p><img src="https://i.loli.net/2020/08/24/MSqHbRwPgtFQfJu.png" alt="T20200824-1.png"></p>
<p>这里就不赘述了。。。</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//color</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXn=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Test,u,v,w,Opt,Cnt_Q;</span><br><span class="line">LL Son[MAXn],Top[MAXn],Size[MAXn],Dep[MAXn],Fa[MAXn];</span><br><span class="line">LL Sig[MAXn];</span><br><span class="line">LL Range[MAXn],Edge[MAXn];</span><br><span class="line">LL Next[MAXn],End[MAXn],Head[MAXn],Val[MAXn],Cur;</span><br><span class="line">LL Dfn[MAXn],Cnt;</span><br><span class="line">LL Now,Tree[MAXn&lt;&lt;<span class="number">2</span>],Con[MAXn&lt;&lt;<span class="number">2</span>],Tag[MAXn&lt;&lt;<span class="number">2</span>],Tot[MAXn];</span><br><span class="line"><span class="keyword">bool</span> Jud[MAXn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">    Next[++Cur]=Head[From];</span><br><span class="line">    Head[From]=Cur;</span><br><span class="line">    End[Cur]=To; Val[Cur]=Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">    Tree[X]=Tree[Lson]+Tree[Rson];</span><br><span class="line">    Con[X]=Con[Lson]+Con[Rson];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build_Tree</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L==R) &#123; Tree[X]=Edge[L]; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Build_Tree(Lson,L,Mid); Build_Tree(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">    Push_up(X);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Tag[X]) &#123;</span><br><span class="line">        Tag[Lson]+=Tag[X];</span><br><span class="line">        Tag[Rson]+=Tag[X];</span><br><span class="line">        Con[Lson]+=Tag[X]*Tree[Lson];</span><br><span class="line">        Con[Rson]+=Tag[X]*Tree[Rson];</span><br><span class="line">        Tag[X]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; Tag[X]++; Con[X]+=Tree[X]; <span class="keyword">return</span> ; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) Update(Lson,L,Mid,From,To);</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) Update(Rson,Mid+<span class="number">1</span>,R,From,To);</span><br><span class="line">    Push_up(X);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123; <span class="keyword">return</span> Con[X]; &#125;</span><br><span class="line">    LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    LL Res=<span class="number">0</span>;</span><br><span class="line">    Push_down(X);</span><br><span class="line">    <span class="keyword">if</span>(From&lt;=Mid) Res+=Get(Lson,L,Mid,From,To);</span><br><span class="line">    <span class="keyword">if</span>(To&gt;Mid) Res+=Get(Rson,Mid+<span class="number">1</span>,R,From,To);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_one</span><span class="params">(LL New,LL Pre)</span> </span>&#123;</span><br><span class="line">    Size[New]=<span class="number">1</span>; Dep[New]=Dep[Pre]+<span class="number">1</span>; Fa[New]=Pre;</span><br><span class="line">    LL Res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(LL i=Head[New];i;i=Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">        DFS_one(End[i],New);</span><br><span class="line">        Size[New]+=Size[End[i]];</span><br><span class="line">        <span class="keyword">if</span>(Size[End[i]]&gt;Res) Son[New]=End[i],Res=Size[End[i]],Range[New]=Val[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_two</span><span class="params">(LL New,LL Pre,LL Cost)</span> </span>&#123;</span><br><span class="line">    Dfn[New]=++Cnt;</span><br><span class="line">    Edge[Cnt]=Cost;</span><br><span class="line">    Tot[New]=Tot[Fa[New]]+Cost;</span><br><span class="line">    Top[New]=Pre;</span><br><span class="line">    <span class="keyword">if</span>(Son[New]) DFS_two(Son[New],Pre,Range[New]);</span><br><span class="line">    <span class="keyword">for</span>(LL i=Head[New];i;i=Next[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(End[i]==Fa[New] || End[i]==Son[New]) <span class="keyword">continue</span>;</span><br><span class="line">        DFS_two(End[i],End[i],Val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL New)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Top[New]!=<span class="number">1</span>) &#123;</span><br><span class="line">        Update(<span class="number">1</span>,<span class="number">1</span>,Total,Dfn[Top[New]],Dfn[New]);</span><br><span class="line">        New=Fa[Top[New]];</span><br><span class="line">    &#125;</span><br><span class="line">    Update(<span class="number">1</span>,<span class="number">1</span>,Total,Dfn[<span class="number">1</span>],Dfn[New]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL New)</span> </span>&#123;</span><br><span class="line">    LL Res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Top[New]!=<span class="number">1</span>) &#123;</span><br><span class="line">        Res+=Get(<span class="number">1</span>,<span class="number">1</span>,Total,Dfn[Top[New]],Dfn[New]);</span><br><span class="line">        New=Fa[Top[New]];</span><br><span class="line">    &#125;</span><br><span class="line">    Res+=Get(<span class="number">1</span>,<span class="number">1</span>,Total,Dfn[<span class="number">1</span>],Dfn[New]);</span><br><span class="line">    <span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"color.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"color.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Test);</span><br><span class="line">    FOR(i,<span class="number">2</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;u); Sig[i]=u+<span class="number">1</span>; &#125;</span><br><span class="line">	FOR(i,<span class="number">2</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;u); Add_Edge(Sig[i],i,u); &#125;</span><br><span class="line">    DFS_one(<span class="number">1</span>,<span class="number">0</span>); DFS_two(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    Build_Tree(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">    <span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Opt,&amp;u); u++;</span><br><span class="line">        <span class="keyword">if</span>(Opt==<span class="number">1</span> &amp;&amp; Jud[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(Opt==<span class="number">1</span>) &#123; Jud[u]=<span class="literal">true</span>; Update(u); Now+=Tot[u],Cnt_Q++; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Now+Cnt_Q*Tot[u]<span class="number">-2</span>*Get(u)); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">//    system("pause");</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 6 </span></span><br><span class="line"><span class="comment">0 0 0</span></span><br><span class="line"><span class="comment">2 1 3 </span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 2 </span></span><br><span class="line"><span class="comment">1 3 </span></span><br><span class="line"><span class="comment">2 2 </span></span><br><span class="line"><span class="comment">2 3 </span></span><br><span class="line"><span class="comment">2 1 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>状压DP+构造</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/24/qbtEsRxjr59Agpm.png" alt="T20200824-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>看到本题的<strong>数据范围</strong>可以知道，这个<strong>8</strong>不简单</p>
<p>并且矩阵的总大小只有$ \leq $400</p>
<p>所以，很自然的可以想到<strong>状压DP</strong></p>
<p>考虑记录行走位置$i,j$，并且由于我们<strong>不能包含陷阱</strong>而在<strong>步数最少</strong>的情况下圈到的<strong>宝藏数最少多</strong>，所以我们考虑记录陷阱和宝藏的状态共$ 2^8 \times 2^8 $的大小</p>
<p>这里有一个<strong>技巧</strong>：在题目中说了，判断一个点是否在圈内的方法是关于穿过边的条数<strong>奇偶性</strong>，所以我们可以判断奇偶来统计答案</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>这里我就直接贴<strong>大佬LMK</strong>的代码了，嘿嘿嘿</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Mx[] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> My[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> N, M, Sx, Sy;<span class="comment">//起点坐标</span></span><br><span class="line"><span class="keyword">int</span> Tx[<span class="number">10</span>], Ty[<span class="number">10</span>], TVal[<span class="number">10</span>], Tcnt;<span class="comment">//宝藏坐标、价值、计数</span></span><br><span class="line"><span class="keyword">int</span> Bx[<span class="number">10</span>], By[<span class="number">10</span>], Bcnt;<span class="comment">//陷阱坐标、计数</span></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">21</span>][<span class="number">21</span>][<span class="number">256</span>][<span class="number">256</span>], Sum[<span class="number">256</span>], Ans;</span><br><span class="line"><span class="keyword">char</span> Map[<span class="number">25</span>][<span class="number">25</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> X, Y, St, Sb;</span><br><span class="line">    Node () &#123;&#125;</span><br><span class="line">    Node (<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> St, <span class="keyword">int</span>  Sb) : X(X), Y(Y), St(St), Sb(Sb) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> &lt;Node&gt; Q;</span><br><span class="line">    F[Sx][Sy][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Q.push(Node(Sx, Sy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Node Now = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">0</span>; S &lt; <span class="number">4</span>; ++S)</span><br><span class="line">        &#123;</span><br><span class="line">            Node New = Now;</span><br><span class="line">            New.X += Mx[S];</span><br><span class="line">            New.Y += My[S];<span class="comment">//在图上随机游走</span></span><br><span class="line">            <span class="keyword">if</span> (Map[New.X][New.Y] != <span class="string">'.'</span> &amp;&amp; Map[New.X][New.Y] != <span class="string">'S'</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= Ty[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Tx[i] - <span class="number">1</span> &amp;&amp; Now.X == Tx[i]) || (New.X == Tx[i] &amp;&amp; Now.X == Tx[i] - <span class="number">1</span>))</span><br><span class="line">                    New.St ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录宝箱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Bcnt; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (New.Y &gt;= By[i]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> ((New.X == Bx[i] - <span class="number">1</span> &amp;&amp; Now.X == Bx[i]) || (New.X == Bx[i] &amp;&amp; Now.X == Bx[i] - <span class="number">1</span>)) </span><br><span class="line">                    New.Sb ^= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>));<span class="comment">//记录陷阱状态</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (F[New.X][New.Y][New.St][New.Sb] &lt;= F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            F[New.X][New.Y][New.St][New.Sb] = F[Now.X][Now.Y][Now.St][Now.Sb] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//更新答案，我们要求的是周长最小</span></span><br><span class="line">            Q.push (New);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= Tcnt; ++j)</span><br><span class="line">            <span class="keyword">if</span> (i &amp; (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))) Sum[i] += TVal[j];<span class="comment">//统计每种情况下宝箱权值之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; Tcnt); ++i)</span><br><span class="line">        Ans = <span class="built_in">max</span>(Ans, Sum[i] - F[Sx][Sy][i][<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">"%d\n"</span>, Ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">"%d %d"</span>, &amp;N, &amp;M);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span> (<span class="string">"%s"</span>, Map[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= M; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Map[i][j] == <span class="string">'S'</span>) Sx = i, Sy = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] &gt;= <span class="string">'0'</span> &amp;&amp; Map[i][j] &lt;= <span class="string">'9'</span>) </span><br><span class="line">                Tx[Map[i][j] - <span class="string">'0'</span>] = i, Ty[Map[i][j] - <span class="string">'0'</span>] = j, Tcnt++;<span class="comment">//记录宝箱的位置</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (Map[i][j] == <span class="string">'B'</span>) </span><br><span class="line">                Bx[++Bcnt] = i, By[Bcnt] = j;<span class="comment">//记录陷阱的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Tcnt; ++i) <span class="built_in">scanf</span> (<span class="string">"%d"</span>, TVal + i);</span><br><span class="line">    <span class="built_in">memset</span> (F, <span class="number">0x5f</span>, <span class="keyword">sizeof</span> F);</span><br><span class="line">    BFS();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200825-day1赛后总结</title>
    <url>/articles/T20200825-day1%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200825-day1赛后总结"><a href="#T20200825-day1赛后总结" class="headerlink" title="T20200825-day1赛后总结"></a>T20200825-day1赛后总结</h1><h2 id="成绩排行：T20200825-day1成绩"><a href="#成绩排行：T20200825-day1成绩" class="headerlink" title="成绩排行：T20200825-day1成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.25-day1/result20200825.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.25-day1/result20200825.html">T20200825-day1成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了一下往届大佬们的Blog以及得分，发现除了T3只能拿10分外，好像其他的都不难，但也都只是<strong>100+</strong>，而没有200。。。</p>
<p>T3没有<strong>理解</strong>正确，推出来一个式子以为就这么A了，结果发现题理解错了。。。</p>
<p>BL兄说这是NOIP模拟Day1，结果T2就来一个紫题。。。</p>
<p><strong>感觉人废了</strong></p>
<p>所以以后做题还是得<strong>认真分析，深度思考</strong>。。。至少题意一定要理解清楚！</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>KMP</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/25/2wWjld6KeCHpgsx.png" alt="T20200825-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这题只要一个转换就是<strong>模板题</strong>了。。。</p>
<p>由于B可以直接看成一个<strong>环</strong>之后像一个<strong>滑动窗口</strong>一样即可</p>
<p>那么我们再发现，这不就是一个<strong>KMP模板</strong>吗</p>
<p>求出每一个位置的<strong>最长公共前缀</strong>，更新答案即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//move</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Ans,Loc,Res;</span><br><span class="line">LL Link[MAXN];</span><br><span class="line"><span class="keyword">char</span> A[MAXN],B[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Get_Link</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL Loc=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Loc &amp;&amp; A[Loc]!=A[i]) Loc=Link[Loc];</span><br><span class="line">		Link[i+<span class="number">1</span>]=(A[Loc]==A[i] ? ++Loc : <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL Len=<span class="number">2</span>*Total,Loc=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">0</span>,Len<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Loc &amp;&amp; B[i]!=A[Loc]) Loc=Link[Loc];</span><br><span class="line">		<span class="keyword">if</span>(B[i]==A[Loc]) Loc++;</span><br><span class="line">		<span class="keyword">if</span>(Loc&gt;Ans) Ans=Loc,Res=i-Loc+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"move.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"move.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%s"</span>,A); <span class="built_in">scanf</span>(<span class="string">"%s"</span>,B);</span><br><span class="line">	FOR(i,<span class="number">0</span>,Total<span class="number">-1</span>) B[i+Total]=B[i]; </span><br><span class="line">	Get_Link();</span><br><span class="line">	Solve();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Res);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">15</span></span><br><span class="line"><span class="comment">bddccbddccbddcc</span></span><br><span class="line"><span class="comment">ccaddbddccbddcc</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>拓扑+贪心</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/25/auklbyzjZDwcgTI.png" alt="T20200825-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>由于有很多的<strong>单向限制</strong>条件</p>
<p>所以我们很容易想到<strong>拓扑排序</strong></p>
<p>但发现正向的拓扑正确性是错的，为什么？</p>
<p>如图：</p>
<p><img src="https://i.loli.net/2020/08/25/PwOICY6WHBsmp1M.png" alt="T20200825-1.png"></p>
<p>所以<strong>反向</strong>才是真理！！！</p>
<p>因为若对于两个序列$A,B$若$A$时<strong>最优解</strong>，$B$是满足反向拓扑的一组解</p>
<p>那么<strong>一定存在</strong>$i$满足$ B_i&gt;A_i $</p>
<p>设$ A_j=B_i $那么一定是$ j \leq i $</p>
<p>所以有子串$ A[j,j+1, \cdots ,i] $</p>
<p>因为$ A_j $不是子串中最小的，且$A_j$一定可以<strong>往后移</strong>，移到$A_i$后边</p>
<p>所以反向拓扑出来的结果一定是对的</p>
<p>每次取可行解中的<strong>最大值</strong>放到<strong>答案数组最后</strong>即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//cook </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Test,Total,Fix;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt;Temp;</span><br><span class="line"><span class="keyword">int</span> u,v,w,RD[MAXN];</span><br><span class="line"><span class="keyword">int</span> Next[MAXN],Head[MAXN],End[MAXN],Cur;</span><br><span class="line"><span class="keyword">int</span> Num[MAXN],Pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"cook.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"cook.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	RD[To]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="keyword">if</span>(!RD[i]) Temp.push(i);</span><br><span class="line">	<span class="keyword">while</span>(!Temp.empty()) &#123;</span><br><span class="line">		<span class="keyword">int</span> New=Temp.top();</span><br><span class="line">		Num[++Pos]=New;</span><br><span class="line">		Temp.pop();</span><br><span class="line">		FOR_SIDE(i,New) <span class="keyword">if</span>(!(--RD[End[i]])) Temp.push(End[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Total!=Pos) <span class="built_in">printf</span>(<span class="string">"impossible\n"</span>);</span><br><span class="line">	<span class="keyword">else</span> &#123; BOR(i,Pos,<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>,Num[i]); <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(!Temp.empty()) Temp.pop();</span><br><span class="line">	Cl(Next,<span class="number">0</span>); Cl(Head,<span class="number">0</span>); Cl(End,<span class="number">0</span>); Cur=<span class="number">0</span>;</span><br><span class="line">	Cl(RD,<span class="number">0</span>); Cl(Num,<span class="number">0</span>); Pos=<span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Test);</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Fix);</span><br><span class="line">		Clean();</span><br><span class="line">		<span class="keyword">while</span>(Fix--) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">			Add_Edge(v,u);</span><br><span class="line">		&#125;</span><br><span class="line">		Solve(); </span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>状压DP+矩阵快速幂</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/25/rBsbpVhFASw3o7C.png" alt="T20200825-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>由于没有人改出来，所以这里上一波<strong>解题报告中的题解</strong></p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><blockquote>
<p>注意到填充方块只有<strong>一维长度</strong>是2，这有什么用？</p>
<p>四维空间不好想像，但是我们可以用三维乃至二维去<strong>类比</strong>。这个四维空间相当于把 $ 2 \times 2 \times 3 $的三维空间中连续复制了$n$次。</p>
<p>我们如果把<strong>边长$2$放在第$4$维</strong>上，相当于是填充了连续两个三维空间的对应位置。否则，边长1就放在了第4维上，相当于在一个三维空间中填充$ 1 \times 1 \times 2 $的方块。</p>
<p>考虑状压 DP 。状态压缩当前三维空间的<strong>被填充状态</strong>。显然有$ 2^{2 \times 2 \times 3} =4096 $种情况。暴力转移就可以拿到这30分。</p>
</blockquote>
<p><strong>期望得分：30分</strong></p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><blockquote>
<p>这部分留给<strong>打表或者状态数化简不够好</strong>的选手</p>
</blockquote>
<p><strong>期望得分：70分</strong></p>
<h4 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h4><blockquote>
<p>显然每次的递推转移是固定的。所以如果我们能求出转移矩阵，那么用<strong>矩阵快速幂</strong>解决即可。</p>
<p>但是现在的状态数太多，矩阵乘法复杂度太高。所以需要<strong>化简状态</strong>，我们需要消掉所有等价的状态。</p>
<p>先考虑旋转和对称变换。我们对三个坐标轴分别实现一个旋转，对其中至少一个实现旋转+对称的结合，然后对每个状态进行所有可能的变换，找到状态在二进制下的最小表示即可。</p>
<p>然后我们又发现一些状态值<strong>一定是0</strong>，比如接口有奇数个块的。这个在三维空间里用$ 1 \times 1 \times 2 $的方块去填充的话接口块数奇偶性不变；用$ 1 \times 1 \times 1 $的方块去填充的话，第四维的下一层又变成奇数了。所以接口数会保持奇数，显然这是无法构造出来的</p>
<p>更进一步的，将所有块黑白染色，接口处黑色个数不等于白色个数的，这样的状态值也一定是 。证明方法同上。</p>
<p>经过这些删除后，只剩下<strong>95个状态</strong>。然后直接矩阵乘法就可以了</p>
</blockquote>
<p><strong>时间复杂度：$ O(95^3 logn) $</strong></p>
<p><strong>期望得分：100分</strong></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200826-day2赛后总结</title>
    <url>/articles/T20200826-day2%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200826-day2赛后总结"><a href="#T20200826-day2赛后总结" class="headerlink" title="T20200826-day2赛后总结"></a>T20200826-day2赛后总结</h1><h2 id="成绩排行：T20200826-day2成绩"><a href="#成绩排行：T20200826-day2成绩" class="headerlink" title="成绩排行：T20200826-day2成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/%E7%AB%9E%E8%B5%9B%E8%AF%95%E9%A2%98/2020.8.26-day2/result20200826.html](file:///C:/Users/12298/Desktop/竞赛试题/2020.8.26-day2/result20200826.html">T20200826-day2成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>感觉发挥还行，T1—10分钟，T2—30分钟，<strong>T3—3个小时？？？</strong></p>
<p>最后T3感觉是个正解，但就是调不出来大样例。。。</p>
<p>这<strong>难度梯度</strong>上升的有鬼吧</p>
<p>至少养成了<strong>随手对拍</strong>半个小时的好习惯。。。</p>
<p>T3以后还是需要先来一个<strong>暴力</strong>的，不然最后调不出来就完了。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>树形DP</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/26/uIXL4FNAYDaUECK.png" alt="T20200826-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><strong>树形DP入门题</strong>。。。</p>
<p>直接设置状态<code>DP[MAXN][2]</code>表示<strong>是否选这棵子树的最大值</strong></p>
<p>每个状态直接往<strong>父亲节点</strong>传即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Limit;</span><br><span class="line">LL Num[MAXN],DP[MAXN][<span class="number">2</span>];</span><br><span class="line">LL u,v,w;</span><br><span class="line">LL Next[MAXN&lt;&lt;<span class="number">1</span>],Head[MAXN],End[MAXN&lt;&lt;<span class="number">1</span>],Cur;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"tree.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"tree.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(LL From,LL To)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(LL New,LL Pre)</span> </span>&#123;</span><br><span class="line">	DP[New][<span class="number">0</span>]=-Limit;</span><br><span class="line">	DP[New][<span class="number">1</span>]+=Num[New];</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		DFS(End[i],New);</span><br><span class="line">	&#125;</span><br><span class="line">	DP[Pre][<span class="number">1</span>]+=<span class="built_in">max</span>(DP[New][<span class="number">1</span>],DP[New][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Limit);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]); &#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">		Add_Edge(u,v); Add_Edge(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	DFS(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,<span class="built_in">max</span>(DP[<span class="number">1</span>][<span class="number">1</span>],DP[<span class="number">1</span>][<span class="number">0</span>]));</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 5</span></span><br><span class="line"><span class="comment">1 -5 -10</span></span><br><span class="line"><span class="comment">1 2</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>数位DP</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/26/qworb4NljskhXG7.png" alt="T20200826-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><strong>数位DP入门题</strong>。。。</p>
<p>由于$ 2x=(x &lt;&lt; 1) $且$ 3x=x+2x $</p>
<p>所以$ 3x=x \bigoplus (x&lt;&lt;1) $</p>
<p>所以就是求$ 1 \sim Limit $之间的满足<strong>二进制下没有两位连续1</strong>的数的个数</p>
<p>直接<code>DP[MAXN][2][2][2]</code>转移一下即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">LL Test,Limit,Num[MAXN],Total;</span><br><span class="line">LL DP[MAXN][<span class="number">2</span>][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"xor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"xor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(Limit) &#123;</span><br><span class="line">		Num[++Total]=(Limit &amp; <span class="number">1</span>);</span><br><span class="line">		Limit&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Calc</span><span class="params">(LL Loc,LL Have,LL Top,LL Jud)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Loc&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(DP[Loc][Have][Top][Jud]!=<span class="number">-1</span>) <span class="keyword">return</span> DP[Loc][Have][Top][Jud];</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		LL End;</span><br><span class="line">		<span class="keyword">if</span>(Jud) &#123; End=<span class="number">0</span>; &#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Top) &#123; End=Num[Loc]; &#125;</span><br><span class="line">		<span class="keyword">else</span> End=<span class="number">1</span>;</span><br><span class="line">		FOR(i,<span class="number">0</span>,End) Res+=Calc(Loc<span class="number">-1</span>,Have &amp;&amp; i==<span class="number">0</span>,Top &amp;&amp; i==Num[Loc],i==<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> DP[Loc][Have][Top][Jud]=Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();	</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Test);</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		Cl(Num,<span class="number">0</span>); Total=<span class="number">0</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Limit);</span><br><span class="line">		Change();</span><br><span class="line">		Cl(DP,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Calc(Total,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>)<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">19</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">100</span></span><br><span class="line"><span class="comment">1000</span></span><br><span class="line"><span class="comment">10000</span></span><br><span class="line"><span class="comment">100000</span></span><br><span class="line"><span class="comment">1000000</span></span><br><span class="line"><span class="comment">10000000</span></span><br><span class="line"><span class="comment">100000000</span></span><br><span class="line"><span class="comment">1000000000</span></span><br><span class="line"><span class="comment">10000000000</span></span><br><span class="line"><span class="comment">100000000000</span></span><br><span class="line"><span class="comment">1000000000000</span></span><br><span class="line"><span class="comment">10000000000000</span></span><br><span class="line"><span class="comment">100000000000000</span></span><br><span class="line"><span class="comment">1000000000000000</span></span><br><span class="line"><span class="comment">10000000000000000</span></span><br><span class="line"><span class="comment">100000000000000000</span></span><br><span class="line"><span class="comment">1000000000000000000</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>这道题还有一个<strong>找规律</strong>的做法，证明不清楚</p>
<p>虽然跑下来和数位DP<strong>时间差不多</strong>，但还是很强啊！</p>
<p><strong>苏巨</strong>考场上打了一个<strong>表</strong>直接推出规律了？！</p>
<p><strong>苏巨%%%</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; T <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">	T x=<span class="number">0</span>,w=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">	<span class="keyword">for</span>(;!<span class="built_in">isdigit</span>(c);c=getchar())<span class="keyword">if</span>(c==<span class="string">'-'</span>) w=-w;</span><br><span class="line">	<span class="keyword">for</span>(;<span class="built_in">isdigit</span>(c);c=getchar()) x=x*<span class="number">10</span>+c-<span class="string">'0'</span>;</span><br><span class="line">	<span class="keyword">return</span> x*w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt; T <span class="title">read</span><span class="params">(T&amp;x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x=<span class="built_in">read</span>&lt;T&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> co const</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line">LL f[<span class="number">60</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(LL n)</span></span>&#123;</span><br><span class="line">	LL ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">59</span>;i&gt;=<span class="number">0</span>;--i)<span class="keyword">if</span>(n&gt;&gt;i&amp;<span class="number">1</span>)&#123;</span><br><span class="line">		ans+=f[i];</span><br><span class="line">		<span class="keyword">if</span>(n&gt;&gt;(i+<span class="number">1</span>)&amp;<span class="number">1</span>) &#123;--ans;<span class="keyword">break</span>;&#125;; <span class="comment">// n cannot replace 0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	f[<span class="number">0</span>]=<span class="number">1</span>,f[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;<span class="number">60</span>;++i) f[i]=f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> T=<span class="built_in">read</span>&lt;<span class="keyword">int</span>&gt;();T--;) solve(<span class="built_in">read</span>&lt;LL&gt;());</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>线性规划+对偶问题+半平面交</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/26/N8p6OJThwXxABmK.png" alt="T20200826-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>先<strong>咕</strong>这吧。。。等学了<strong>线性规划对偶问题</strong>再来（以后多半记不起来的。。。）</p>
<p><strong>吐槽</strong>一下：这道题无论是在<strong>码量</strong>还是<strong>难度</strong>上直接时<strong>陡增</strong>啊！！！</p>
<p>这里就摘一下<strong>solution</strong>胡一下吧</p>
<p><img src="https://i.loli.net/2020/08/26/MskFqHVYhLAOZwp.png" alt="T20200826-1.png"></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200827-day1赛后总结</title>
    <url>/articles/T20200827-day1%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200827-day1赛后总结"><a href="#T20200827-day1赛后总结" class="headerlink" title="T20200827-day1赛后总结"></a>T20200827-day1赛后总结</h1><h2 id="成绩排行：T20200827-day1成绩"><a href="#成绩排行：T20200827-day1成绩" class="headerlink" title="成绩排行：T20200827-day1成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/Exam/2020.8.27-day1/2020.8.27.html](file:///C:/Users/12298/Desktop/Exam/2020.8.27-day1/2020.8.27.html">T20200827-day1成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>难看</strong>的成绩。。。被高三巨佬和外校狂虐<strong>（/jk.jpg）</strong></p>
<p>还是代码<strong>实现能力</strong>太差了。。。</p>
<p>多找题目的特点，按住时间复杂度的<strong>脖颈</strong>！</p>
<p><strong>高三巨佬WLL%%%</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/27/RfGndrQPSew7FIB.png" alt="T20200827-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题作为T1，但感觉比较优秀，不容易找到正确的解题思路</p>
<p>首先，我们来看这个（我们先不管<strong>特殊情况</strong>）</p>
<p><img src="https://i.loli.net/2020/08/27/NuTpafR3v5O2Zdh.png" alt="T20200827-1.png"></p>
<p>发现，在这种情况下，影响答案的只是<strong>两个蓝色点之间从左到右</strong>的方案数</p>
<p>首先因为走法<strong>只有一种：最左边那个先走左边，再走到最右边，再回到右边点</strong></p>
<p>再手摸几个样例并验证一下特殊情况：是否有<strong>靠墙</strong>的（<strong>一个和两个</strong>）</p>
<p>发现确实是正确的思路，</p>
<p>所以，我们现在需要求得就是<strong>从一个点到另一个点的路径数</strong></p>
<p><img src="https://i.loli.net/2020/08/27/nbFd9Q3E17mDqjr.png" alt="T20200827-2.png"></p>
<p>然后，我们又观察最后一步</p>
<p>只有两种<strong>到达最后一个点</strong>的可能方式：kind 1和kind 2</p>
<p>所以可以得出一个<strong>递推式</strong>：<code>DP[i]=DP[i-1]+DP[i-3]</code>（<code>DP[0]=0; DP[1]=1; DP[2]=1</code>）</p>
<p>所以就完了！</p>
<p><strong>吐槽一下</strong>：考场上，有两位打表巨佬硬是说这应该可以是斐波那契数列，我蒽蒽。。。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//achen</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[MAXN],Test,Left,Right,Total;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LL Temp=<span class="number">0</span>,Fac=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">char</span> Ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;<span class="string">'9'</span> || Ch&lt;<span class="string">'0'</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Ch==<span class="string">'-'</span>) Fac=<span class="number">-1</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Ch&gt;=<span class="string">'0'</span> &amp;&amp; Ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">		Temp=(Temp&lt;&lt;<span class="number">1</span>)+(Temp&lt;&lt;<span class="number">3</span>)+Ch-<span class="string">'0'</span>;</span><br><span class="line">		Ch=getchar();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Fac*Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	DP[<span class="number">0</span>]=<span class="number">0</span>; DP[<span class="number">1</span>]=<span class="number">1</span>; DP[<span class="number">2</span>]=<span class="number">1</span>; DP[<span class="number">3</span>]=<span class="number">1</span>; DP[<span class="number">4</span>]=<span class="number">2</span>;</span><br><span class="line">	FOR(i,<span class="number">5</span>,MAXN<span class="number">-5</span>) DP[i]=(DP[i<span class="number">-1</span>]+DP[i<span class="number">-3</span>])%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"achen.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"achen.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	Test=Read();		</span><br><span class="line">	Init();</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Left,&amp;Right);</span><br><span class="line">		<span class="keyword">if</span>(Right&lt;Left) swap(Left,Right);</span><br><span class="line">		<span class="keyword">if</span>(Left==<span class="number">1</span> &amp;&amp; Right==Total) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,DP[Right-Left+<span class="number">1</span>]%MOD);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Left==<span class="number">1</span> || Right==Total) <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,DP[Right-Left]%MOD);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,DP[Right-Left<span class="number">-1</span>]%MOD);</span><br><span class="line">	&#125;	</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>倍增+动态规划+贪心+树上差分</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/27/kW9VLIvnsGqyC2i.png" alt="T20200827-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本题考场上没搞出来，害。。。</p>
<p>我们分析复杂度：$ O(nlogn) $</p>
<p>所以，这个$ logn $一定是给<strong>倍增</strong>的</p>
<p>因为对于一个节点，<strong>最优根</strong>只有三种情况：</p>
<ul>
<li><strong>在其除此点外子树内</strong></li>
<li><strong>就是此点</strong></li>
<li><strong>不在子树内</strong></li>
</ul>
<p>所以我们只需要判断这个子树<strong>是否有所有的颜色</strong>，然后找一个<strong>距离最长</strong>的点作为<strong>根</strong>，就得到了<strong>当前点的最优解</strong>！</p>
<p><img src="https://i.loli.net/2020/08/27/8lDL5hBJE12CwPp.png" alt="T20200827-3.png"></p>
<p>所以，我们的<strong>瓶颈</strong>在于如何快速判断当前点是否是是符合要求的子树</p>
<p>因为一个点的颜色会影响它的<strong>所有祖先</strong></p>
<p>由此考虑<strong>树上差分</strong>一下</p>
<p>所以我们考虑将这条链全部<strong>+1</strong></p>
<p>所以对于多个点的<strong>LCA</strong>我们需要<strong>-1</strong></p>
<p>So，我们只需要按照<strong>Dfn排序</strong>，再不断求出LCA，并+1或者-1即可</p>
<p>对于维护Dfn，只需要用<strong>set</strong>直接维护即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e6</span>+<span class="number">10</span>,MAXM=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Test;</span><br><span class="line"><span class="keyword">int</span> Col[MAXN];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;Temp[MAXM] ;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator Iter;</span><br><span class="line"><span class="keyword">int</span> Next[MAXN&lt;&lt;<span class="number">1</span>],End[MAXN&lt;&lt;<span class="number">1</span>],Head[MAXN],Cur;</span><br><span class="line"><span class="keyword">int</span> Dep[MAXN],Anc[MAXN][<span class="number">20</span>],Down1[MAXN],Down2[MAXN];</span><br><span class="line"><span class="keyword">int</span> Dfn[MAXN],Dot[MAXN],dfn_num;</span><br><span class="line"><span class="keyword">int</span> Sum[MAXN],Max[MAXN];</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN];</span><br><span class="line"><span class="keyword">int</span> u,v,w,LCA;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"tree.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"tree.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_one</span><span class="params">(<span class="keyword">int</span> New,<span class="keyword">int</span> Pre)</span> </span>&#123;</span><br><span class="line">	Dfn[New]=++dfn_num;</span><br><span class="line">	Dot[dfn_num]=New;</span><br><span class="line">	Dep[New]=Dep[Pre]+<span class="number">1</span>;</span><br><span class="line">	Anc[New][<span class="number">0</span>]=Pre;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">18</span>) Anc[New][i]=Anc[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		DFS_one(End[i],New);</span><br><span class="line">		<span class="keyword">if</span>(Down1[End[i]]&gt;Down1[New]) Down2[New]=Down1[New],Down1[New]=Down1[End[i]];</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Down1[End[i]]&gt;Down2[New]) Down2[New]=Down1[End[i]];</span><br><span class="line">	&#125;</span><br><span class="line">	Down1[New]++; Down2[New]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS_two</span><span class="params">(<span class="keyword">int</span> New,<span class="keyword">int</span> Pre,<span class="keyword">int</span> Len)</span> </span>&#123;</span><br><span class="line">	Max[New]=Len;</span><br><span class="line">	Len++;</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>(Down1[End[i]]+<span class="number">1</span>==Down1[New]) DFS_two(End[i],New,<span class="built_in">max</span>(Down2[New]+<span class="number">1</span>,Len));</span><br><span class="line">		<span class="keyword">else</span> DFS_two(End[i],New,<span class="built_in">max</span>(Len,Down1[New]+<span class="number">1</span>));</span><br><span class="line">		Sum[New]+=Sum[End[i]];</span><br><span class="line">		<span class="keyword">if</span>(Vis[End[i]]) Vis[New]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">DFS_three</span><span class="params">(<span class="keyword">int</span> New,<span class="keyword">int</span> Pre)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(Sum[New]==Test) Res=Max[New];</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		Res=<span class="built_in">max</span>(Res,DFS_three(End[i],New)) ;</span><br><span class="line">		<span class="keyword">if</span>(Vis[End[i]]) <span class="keyword">continue</span>;</span><br><span class="line">		Res=<span class="built_in">max</span>(Res,Down1[End[i]]+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> X,<span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Dep[X]!=Dep[Y]) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Dep[X]&lt;Dep[Y]) swap(X,Y);</span><br><span class="line">		BOR(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(Dep[Anc[X][i]]&gt;=Dep[Y]) X=Anc[X][i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(X==Y) <span class="keyword">return</span> X;</span><br><span class="line">	BOR(i,<span class="number">18</span>,<span class="number">0</span>) <span class="keyword">if</span>(Anc[X][i]!=Anc[Y][i]) </span><br><span class="line">		X=Anc[X][i],Y=Anc[Y][i];</span><br><span class="line">	<span class="keyword">return</span> Anc[X][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Test);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Col[i]); &#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total<span class="number">-1</span>) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;u,&amp;v);</span><br><span class="line">		Add_Edge(u,v); Add_Edge(v,u);</span><br><span class="line">	&#125;</span><br><span class="line">	DFS_one(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Temp[Col[i]].insert(Dfn[i]);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Test) &#123;</span><br><span class="line">		Iter=Temp[i].<span class="built_in">begin</span>(); </span><br><span class="line">		LCA=u=Dot[*Iter];</span><br><span class="line">		Sum[u]++; </span><br><span class="line">		Iter++;</span><br><span class="line">		<span class="keyword">for</span>(;Iter!=Temp[i].<span class="built_in">end</span>();Iter++) &#123;</span><br><span class="line">			v=Dot[*Iter];</span><br><span class="line">			Sum[v]++;</span><br><span class="line">			Sum[Get(u,v)]--;</span><br><span class="line">			LCA=Get(LCA,v);</span><br><span class="line">			u=v;</span><br><span class="line">		&#125;</span><br><span class="line">		Vis[LCA]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	DFS_two(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,DFS_three(<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>线段树+单调栈+（子序列自动机？）</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/27/jtGvzPIEmX1pW3w.png" alt="T20200827-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>吐槽一下</strong>：难道<strong>刘大佬</strong>的名字就是从这儿来的？？？</p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>我们直接来讨论一下对于$ a_i \neq a_j $的分（其他的都可以轻松拿分的！）</p>
<p>我们可以得出<strong>判断式</strong>：</p>
<script type="math/tex; mode=display">
Max-Min=R-L \\
\Rightarrow Max-Min+L=R</script><p>所以我们考虑直接<strong>枚举$R$</strong></p>
<p>加入$ a_R $时，可能导致$ L \sim R $区间的$Max$和$Min$发生变化，所以我们考虑使用<strong>单调栈</strong>整体修改一个线段树<strong>区间的最小值</strong>（$ Max-Min+L $）</p>
<p>在添加完成后，就可以直接统计答案了</p>
<p><strong>时间复杂度：$ O(nlogn) $</strong></p>
<p><strong>期望得分：60分（加上前边）</strong></p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>对于全部数据</p>
<p>和算法一唯一的不同就是可能有$ a_i=a_j $，所以我们需要再来一个$Cnt$表示<strong>当前区间重复的数的重复次数</strong></p>
<p>原来的<strong>表达式</strong>就变为：</p>
<script type="math/tex; mode=display">
Max-Min+Cnt=R-L \\
\Rightarrow Max-Min+Cnt+(L-R-1)=-1</script><p>所以我们只需要存一个区间的$ Max-Min+Cnt+(L-R-1) $的<strong>最小值</strong>和<strong>最小值个数</strong></p>
<p>由于我们需要<strong>快速更改</strong>一个作用范围，所以考虑类似于<strong>子序列自动机</strong>的方式</p>
<p>存入<code>Last[i]</code>表示上一个$i$的位置，直接类似于处理$L$和$R$的大段<strong>转移</strong>即可</p>
<p><strong>时间复杂度：$ O(nlogn) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//easy</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Topx,Topy;</span><br><span class="line">LL Tree[MAXN&lt;&lt;<span class="number">2</span>],Tag[MAXN&lt;&lt;<span class="number">2</span>],Cnt[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line">LL Cop[MAXN],Size,Total,Ans,Num[MAXN];</span><br><span class="line">LL Last[MAXN],New[MAXN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL ID,Val;</span><br><span class="line">&#125;Min[MAXN],Max[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"easy.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"easy.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_up</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	Tree[X]=<span class="built_in">min</span>(Tree[Lson],Tree[Rson]);</span><br><span class="line">	Cnt[X]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(Tree[X]==Tree[Lson]) Cnt[X]+=Cnt[Lson];</span><br><span class="line">	<span class="keyword">if</span>(Tree[X]==Tree[Rson]) Cnt[X]+=Cnt[Rson];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Build</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L==R) &#123; Cnt[X]=<span class="number">1</span>; <span class="keyword">return</span>; &#125; </span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Build(Lson,L,Mid); Build(Rson,Mid+<span class="number">1</span>,R);</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_down</span><span class="params">(LL X,LL L,LL R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Tag[X]) &#123;</span><br><span class="line">		Tag[Lson]+=Tag[X];</span><br><span class="line">		Tag[Rson]+=Tag[X];</span><br><span class="line">		Tree[Lson]+=Tag[X];</span><br><span class="line">		Tree[Rson]+=Tag[X];</span><br><span class="line">		Tag[X]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL X,LL L,LL R,LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">		Tag[X]+=Temp;</span><br><span class="line">		Tree[X]+=Temp;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Push_down(X,L,R);</span><br><span class="line">	<span class="keyword">if</span>(From&lt;=Mid) Update(Lson,L,Mid,From,To,Temp);</span><br><span class="line">	<span class="keyword">if</span>(To&gt;Mid) Update(Rson,Mid+<span class="number">1</span>,R,From,To,Temp);</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL X,LL L,LL R,LL From,LL To)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;=From &amp;&amp; R&lt;=To) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Tree[X]!=<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> Cnt[X];</span><br><span class="line">	&#125;</span><br><span class="line">	LL Mid=(L+R)&gt;&gt;<span class="number">1</span>,Res=<span class="number">0</span>;</span><br><span class="line">	Push_down(X,L,R);</span><br><span class="line">	<span class="keyword">if</span>(From&lt;=Mid) Res+=Get(Lson,L,Mid,From,To);</span><br><span class="line">	<span class="keyword">if</span>(To&gt;Mid) Res+=Get(Rson,Mid+<span class="number">1</span>,R,From,To);</span><br><span class="line">	Push_up(X,L,R);</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]),Cop[i]=Num[i];</span><br><span class="line">	sort(Cop+<span class="number">1</span>,Cop+Total+<span class="number">1</span>);</span><br><span class="line">	Size=unique(Cop+<span class="number">1</span>,Cop+Total+<span class="number">1</span>)-Cop<span class="number">-1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Temp=lower_bound(Cop+<span class="number">1</span>,Cop+Total+<span class="number">1</span>,Num[i])-Cop;</span><br><span class="line">		Last[i]=New[Temp];</span><br><span class="line">		New[Temp]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	Build(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">	Max[++Topx]=Node&#123;<span class="number">0</span>,INF&#125;;</span><br><span class="line">	Min[++Topy]=Node&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="keyword">while</span>(Topx&gt;<span class="number">1</span> &amp;&amp; Max[Topx].Val&lt;=Num[i]) &#123;</span><br><span class="line">			Update(<span class="number">1</span>,<span class="number">1</span>,Total,Max[Topx<span class="number">-1</span>].ID+<span class="number">1</span>,Max[Topx].ID,Num[i]-Max[Topx].Val);</span><br><span class="line">			Topx--;</span><br><span class="line">		&#125;</span><br><span class="line">		Max[++Topx]=Node&#123;i,Num[i]&#125;;</span><br><span class="line">		<span class="keyword">while</span>(Topy&gt;<span class="number">1</span> &amp;&amp; Min[Topy].Val&gt;=Num[i]) &#123;</span><br><span class="line">			Update(<span class="number">1</span>,<span class="number">1</span>,Total,Min[Topy<span class="number">-1</span>].ID+<span class="number">1</span>,Min[Topy].ID,Min[Topy].Val-Num[i]);</span><br><span class="line">			Topy--;</span><br><span class="line">		&#125;</span><br><span class="line">		Min[++Topy]=Node&#123;i,Num[i]&#125;;</span><br><span class="line">		Update(<span class="number">1</span>,<span class="number">1</span>,Total,Last[i]+<span class="number">1</span>,i,<span class="number">-1</span>);</span><br><span class="line">		Ans+=Get(<span class="number">1</span>,<span class="number">1</span>,Total,<span class="number">1</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200828-day2赛后总结</title>
    <url>/articles/T20200828-day2%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200828-day2赛后总结"><a href="#T20200828-day2赛后总结" class="headerlink" title="T20200828-day2赛后总结"></a>T20200828-day2赛后总结</h1><h2 id="成绩排行：T20200828-day2成绩"><a href="#成绩排行：T20200828-day2成绩" class="headerlink" title="成绩排行：T20200828-day2成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/Exam/2020.8.28-day2/result20200828.html](file:///C:/Users/12298/Desktop/Exam/2020.8.28-day2/result20200828.html">T20200828-day2成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>精打细算一个<strong>好空间</strong>，结果还是没有过。。。</p>
<p>不要相信每一场比赛的<strong>难度梯度排行</strong>，按自己的节奏去做</p>
<p>开学前最后一场比赛<strong>关门黑</strong>。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>Trie树+贪心</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/30/5Giw4l3cWRzJuI8.png" alt="T20200828-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由$ a_i,b_i $的取值范围</p>
<p>我们可以得出<strong>正解</strong>。。。</p>
<p>对于两串数直接建一个<strong>01Trie树</strong></p>
<p>每次最好<strong>一起取0或者一起取1</strong>，就可以得出<strong>最小值</strong></p>
<p>最后再<strong>排一个序</strong>即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//doubt</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>,MAXM=<span class="number">6e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,A[MAXN],B[MAXN],Num[MAXN],Size,Cop[<span class="number">50</span>],Two[<span class="number">50</span>]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> Ch[<span class="number">2</span>],Cnt;</span><br><span class="line">&#125;Trie[<span class="number">2</span>][MAXM];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"doubt.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"doubt.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(LL Base)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	BOR(i,<span class="number">31</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!Trie[Base][Res].Ch[Cop[i]]) Trie[Base][Res].Ch[Cop[i]]=(++Size);</span><br><span class="line">		Res=Trie[Base][Res].Ch[Cop[i]];</span><br><span class="line">		Trie[Base][Res].Cnt++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Get</span><span class="params">(LL Left,LL Right)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	BOR(i,<span class="number">31</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Trie[<span class="number">0</span>][Trie[<span class="number">0</span>][Left].Ch[<span class="number">0</span>]].Cnt &amp;&amp; Trie[<span class="number">1</span>][Trie[<span class="number">1</span>][Right].Ch[<span class="number">0</span>]].Cnt) Left=Trie[<span class="number">0</span>][Left].Ch[<span class="number">0</span>],Right=Trie[<span class="number">1</span>][Right].Ch[<span class="number">0</span>],Trie[<span class="number">0</span>][Left].Cnt--,Trie[<span class="number">1</span>][Right].Cnt--;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Trie[<span class="number">0</span>][Trie[<span class="number">0</span>][Left].Ch[<span class="number">1</span>]].Cnt &amp;&amp; Trie[<span class="number">1</span>][Trie[<span class="number">1</span>][Right].Ch[<span class="number">1</span>]].Cnt) Left=Trie[<span class="number">0</span>][Left].Ch[<span class="number">1</span>],Right=Trie[<span class="number">1</span>][Right].Ch[<span class="number">1</span>],Trie[<span class="number">0</span>][Left].Cnt--,Trie[<span class="number">1</span>][Right].Cnt--;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(Trie[<span class="number">0</span>][Trie[<span class="number">0</span>][Left].Ch[<span class="number">0</span>]].Cnt &amp;&amp; Trie[<span class="number">1</span>][Trie[<span class="number">1</span>][Right].Ch[<span class="number">1</span>]].Cnt) Left=Trie[<span class="number">0</span>][Left].Ch[<span class="number">0</span>],Right=Trie[<span class="number">1</span>][Right].Ch[<span class="number">1</span>],Trie[<span class="number">0</span>][Left].Cnt--,Trie[<span class="number">1</span>][Right].Cnt--,Res+=Two[i];</span><br><span class="line">		<span class="keyword">else</span> Left=Trie[<span class="number">0</span>][Left].Ch[<span class="number">1</span>],Right=Trie[<span class="number">1</span>][Right].Ch[<span class="number">0</span>],Trie[<span class="number">0</span>][Left].Cnt--,Trie[<span class="number">1</span>][Right].Cnt--,Res+=Two[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">31</span>) Two[i]=Two[i<span class="number">-1</span>]*<span class="number">2</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;A[i]); &#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		Cl(Cop,<span class="number">0</span>);</span><br><span class="line">		BOR(j,<span class="number">31</span>,<span class="number">0</span>) &#123; <span class="keyword">if</span>(A[i]&gt;=Two[j]) Cop[j]=<span class="number">1</span>,A[i]-=Two[j]; <span class="keyword">else</span> Cop[j]=<span class="number">0</span>; &#125; </span><br><span class="line">		Update(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;B[i]); &#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		Cl(Cop,<span class="number">0</span>);</span><br><span class="line">		BOR(j,<span class="number">31</span>,<span class="number">0</span>) &#123; <span class="keyword">if</span>(B[i]&gt;=Two[j]) Cop[j]=<span class="number">1</span>,B[i]-=Two[j]; <span class="keyword">else</span> Cop[j]=<span class="number">0</span>; &#125; </span><br><span class="line">		Update(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) </span><br><span class="line">		Num[i]=Get(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">	sort(Num+<span class="number">1</span>,Num+Total+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Num[i]);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+计数</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/30/TXR7lHzPGaEuUWC.png" alt="T20200828-B.png"></p>
<h3 id="咕咕咕"><a href="#咕咕咕" class="headerlink" title="咕咕咕"></a>咕咕咕</h3><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>组合数学+构造+分块打表</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/30/zq7T8MLR1hHAJbE.png" alt="T20200828-C.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>通过分析我们发现，这个图中的<strong>总度数</strong>为$ 2n+2 $</p>
<p>且因为每一个点的<strong>度数</strong>必须要是$ \geq 2 $才能满足是<strong>边双连通分量</strong></p>
<p>所以对于整张图，分<strong>三种情况</strong>：</p>
<ul>
<li>有<strong>两个度数为3</strong>的点，且两点<strong>直接相连</strong>，并由<strong>两条链相连</strong></li>
<li><strong>两个点度数为3</strong>，两点之间由<strong>三条链相连</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/08/30/RCgBOluFSpHf3NX.png" alt="T20200828-1.png"></p>
<p>由<strong>隔板法</strong>可得总数为：</p>
<script type="math/tex; mode=display">
\frac{ {n \choose 2} \times {n-3 \choose 2} \times (n-2)! }{3!}+ \frac{ {n \choose 2} \times {n-3 \choose 1} \times (n-2)!}{2!} \\
\Rightarrow \frac{n! \times (n-3) \times (n-4)}{24} + \frac{n! \times (n-3)}{4}</script><ul>
<li>有<strong>一个度数为4</strong>的点，且形成<strong>两条环</strong></li>
</ul>
<p><img src="https://i.loli.net/2020/08/30/FVG5spY7NkAaWbU.png" alt="T20200828-2.png"></p>
<p>同理我们可以得到：</p>
<script type="math/tex; mode=display">
\frac{n! \times (n-4)}{8}</script><p>由此，我们就可以直接得出最后结果了</p>
<p>但是，我们无法处理$1e9!$，所以我们需要<strong>分块打表</strong></p>
<p>将<strong>一定区间</strong>内的阶乘处理出来</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen (<span class="string">"road.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen (<span class="string">"road.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">LL Total,Fac[MAXN]=&#123;<span class="number">1</span>&#125;,Ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; Res=(Res*A)%MOD; &#125;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (Res%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	<span class="keyword">if</span>(Total&lt;=<span class="number">1000000</span>) &#123;</span><br><span class="line">		FOR(i,<span class="number">1</span>,Total) Fac[i]=(Fac[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line">		Ans=(((Fac[Total]*(Total<span class="number">-3</span>)%MOD)*(Total<span class="number">-4</span>)%MOD)*Fast(<span class="number">24</span>,MOD<span class="number">-2</span>)%MOD+MOD)%MOD;</span><br><span class="line">		(Ans+=((Fac[Total]*(Total<span class="number">-3</span>)%MOD)*Fast(<span class="number">4</span>,MOD<span class="number">-2</span>)%MOD+MOD)%MOD)%=MOD;</span><br><span class="line">		(Ans+=((Fac[Total]*(Total<span class="number">-4</span>)%MOD)*Fast(<span class="number">8</span>,MOD<span class="number">-2</span>)%MOD+MOD)%MOD)%=MOD;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//打表</span></span><br><span class="line">		<span class="comment">//road17:Total:733333339</span></span><br><span class="line">		<span class="comment">//road18:Total:935643442</span></span><br><span class="line">		<span class="comment">//road19:Total:957939114</span></span><br><span class="line">		<span class="comment">//road20:Total:543195297</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(Ans%MOD+MOD)%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200831赛后总结</title>
    <url>/articles/T20200831%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200831赛后总结"><a href="#T20200831赛后总结" class="headerlink" title="T20200831赛后总结"></a>T20200831赛后总结</h1><h2 id="成绩排行：T20200831成绩"><a href="#成绩排行：T20200831成绩" class="headerlink" title="成绩排行：T20200831成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/Exam/2020.8.31/result20200831.html](file:///C:/Users/12298/Desktop/Exam/2020.8.31/result20200831.html">T20200831成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发挥不错，但<strong>T1</strong>还是<strong>打挂</strong>了。。。</p>
<p><strong>在线%哲哥</strong></p>
<p>这次考试主要是考关于<strong>数学方面</strong>的<strong>（?）</strong></p>
<p>但没有考太难的计数问题，需要一些小转换</p>
<p><strong>但愿</strong>之后再也不爆T1。。。</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/31/WgzmHbEL5RxytIi.png" alt="T20200831-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr>
<p><strong>吐槽一下：</strong></p>
<p>这个数据范围挺神奇的。。。直接$ n \leq 1e7 $都是可以<strong>秒过</strong>的，为啥搞一个$ 2 \leq n \leq 1000 $。。。</p>
<hr>
<p>我们先列一个<strong>矩阵</strong></p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} 0 & a_1 + a_2 & a_1 + a_3 & \cdots & a_1 + a_n \\ a_2 + a_1 & 0 & a_2 + a_3 & \cdots & a_2 + a_n \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ a_n + a_1 & a_n + a_2 & a_n + a_3 & \cdots & 0 \end{matrix} \right]</script><p>可以发现一些<strong>性质</strong></p>
<p>对于第$i$行，加起来之后的结果是</p>
<script type="math/tex; mode=display">
(n-i) \times a_i + \sum_{j=i+1}^{n} a_j</script><p>所以我们可以直接<strong>相邻两行相减</strong>，就可以解出一个解</p>
<p>依次<strong>递推</strong>即可</p>
<p><strong>温馨提示：</strong>对于$n=2$的情况，我们需要<strong>随机输出</strong>这个<strong>不定方程</strong>的解</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//orzflower</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Sum[MAXN],Total,u;</span><br><span class="line">LL Num[MAXN],A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"orzflower.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"orzflower.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) FOR(j,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;u);</span><br><span class="line"><span class="keyword">if</span>(j==Total) A[i]=u;</span><br><span class="line">		<span class="keyword">if</span>(j&gt;i) Sum[i]+=u;</span><br><span class="line">	&#125;</span><br><span class="line">	BOR(i,Total<span class="number">-2</span>,<span class="number">1</span>) &#123;</span><br><span class="line">		LL Temp=Sum[i]-Sum[i+<span class="number">1</span>];</span><br><span class="line">		Num[i]=Temp/(Total-i);</span><br><span class="line">		Sum[i]=Sum[i+<span class="number">1</span>]+Num[i];</span><br><span class="line">	&#125;</span><br><span class="line">	Num[Total<span class="number">-1</span>]=Num[Total<span class="number">-2</span>]+(A[Total<span class="number">-1</span>]-A[Total<span class="number">-2</span>]);</span><br><span class="line">	Num[Total]=A[Total<span class="number">-1</span>]-Num[Total<span class="number">-1</span>];</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">printf</span>(<span class="string">"%lld "</span>,Num[i]);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); </span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">4 </span></span><br><span class="line"><span class="comment">0 3 6 7 </span></span><br><span class="line"><span class="comment">3 0 5 6</span></span><br><span class="line"><span class="comment">6 5 0 9 </span></span><br><span class="line"><span class="comment">7 6 9 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>SPFA+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/31/aZuecNhIvnj51Gd.png" alt="T20200831-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>本道题<strong>很简单</strong>。。。</p>
<p>很自然的想法就是求出<strong>从起点和终点开始到达第$i$个点剩的最多的油量</strong></p>
<p>那么最终的答案就是</p>
<script type="math/tex; mode=display">
Ans=max^{p}_{i=1} {(Limit-Dist[i]-BDist[i]) \times Val[i]}</script><p>但是由于这个<strong>松弛操作不是单调</strong>的，我们只能用<strong>SPFA</strong>进行多次松弛</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//chase</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_BSIDE(i,A) for(LL i=BHead[A];i;i=BNext[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e3</span>+<span class="number">10</span>,MAXM=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Side,u,v,w,Tot,Limit;</span><br><span class="line">LL Head[MAXN],Next[MAXM],Cur,End[MAXM],Val[MAXM],BHead[MAXN],BNext[MAXM],BCur,BEnd[MAXM],BVal[MAXM];</span><br><span class="line">LL Dist[MAXN],BDist[MAXN],Ans=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN],Jud[MAXN];</span><br><span class="line"><span class="built_in">queue</span>&lt;LL&gt;Mine;</span><br><span class="line"><span class="built_in">queue</span>&lt;LL&gt;BMine;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"chase.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"chase.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Dist,<span class="number">0x3f</span>);</span><br><span class="line">	Dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">	Mine.push(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">while</span>(!Mine.empty()) &#123;</span><br><span class="line">		LL New=Mine.front();</span><br><span class="line">		Mine.pop();</span><br><span class="line">		Vis[New]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Jud[New]) Dist[New]=<span class="number">0</span>;</span><br><span class="line">		FOR_SIDE(i,New) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dist[End[i]]&gt;Dist[New]+Val[i] &amp;&amp; Dist[New]+Val[i]&lt;=Limit) &#123;</span><br><span class="line">				Dist[End[i]]=Dist[New]+Val[i];</span><br><span class="line">				<span class="keyword">if</span>(!Vis[End[i]]) Mine.push(End[i]),Vis[End[i]]=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BSPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(BDist,<span class="number">0x3f</span>);</span><br><span class="line">	Cl(Vis,<span class="literal">false</span>);</span><br><span class="line">	BDist[Total]=<span class="number">0</span>;</span><br><span class="line">	BMine.push(Total);</span><br><span class="line">	<span class="keyword">while</span>(!BMine.empty()) &#123;</span><br><span class="line">		LL New=BMine.front();</span><br><span class="line">		BMine.pop();</span><br><span class="line">		Vis[New]=<span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span>(Jud[New]) BDist[New]=<span class="number">0</span>;</span><br><span class="line">		FOR_BSIDE(i,New) &#123;</span><br><span class="line">			<span class="keyword">if</span>(BDist[BEnd[i]]&gt;BDist[New]+BVal[i] &amp;&amp; BDist[New]+BVal[i]&lt;=Limit) &#123;</span><br><span class="line">				BDist[BEnd[i]]=BDist[New]+BVal[i];</span><br><span class="line">				<span class="keyword">if</span>(!Vis[BEnd[i]]) BMine.push(BEnd[i]),Vis[BEnd[i]]=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(LL From,LL To,LL Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From]; BNext[++BCur]=BHead[To];</span><br><span class="line">	Head[From]=Cur; BHead[To]=BCur;</span><br><span class="line">	End[Cur]=To; BEnd[BCur]=From;</span><br><span class="line">	Val[Cur]=Temp; BVal[BCur]=Temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Side,&amp;Limit);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Side) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;u,&amp;v,&amp;w);</span><br><span class="line">		Add_Edge(u,v,w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Tot);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Tot) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;u);</span><br><span class="line">		Jud[u]=<span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SPFA(); BSPFA();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Tot);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Tot) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;u,&amp;v);</span><br><span class="line">		<span class="keyword">if</span>(Jud[u]) Ans=<span class="built_in">max</span>(Ans,Limit*v);</span><br><span class="line">		<span class="keyword">else</span> Ans=<span class="built_in">max</span>(Ans,v*(Limit-Dist[u]-BDist[u]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); </span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 6 10 </span></span><br><span class="line"><span class="comment">1 2 4 </span></span><br><span class="line"><span class="comment">1 4 1 </span></span><br><span class="line"><span class="comment">4 3 1 </span></span><br><span class="line"><span class="comment">2 5 1 </span></span><br><span class="line"><span class="comment">4 5 2 </span></span><br><span class="line"><span class="comment">3 2 1 </span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">3 </span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">2 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>计数DP+组合数学</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/08/31/IsgJHyqY8M6nlki.png" alt="T20200831-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><strong>吐槽一下：</strong>考试的时候按照$ 70 \% $的数据去打的，结果最后<strong>90分</strong>？？？最后看了一下数据制造器，好像是<strong>随机</strong>的。。。这。。。</p>
<h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>看到本题的$ 2^{12} $的数据范围，肯定可以想到<strong>较为暴力</strong>的算法</p>
<p><strong>时间复杂度：$ O(能拿40分) $</strong></p>
<p><strong>期望得分：40分</strong></p>
<h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>首先我们可以知道，对于$ n \neq 2^i $的数，他们是<strong>不会对于生成2048有贡献</strong></p>
<p>所以我们只考虑$ n=2^i $的数</p>
<p>看到数据$ 2^{12} $考虑直接<strong>背包</strong></p>
<p><code>DP[i]</code>表示能够生成$i$的<strong>子序列个数</strong></p>
<p>最后再$ Ans \times 2^{Cnt} $即可（<code>Cnt</code>表示$ \neq 2^i $的数的个数）</p>
<p><strong>时间复杂度：$ O(n \times 2^{12}) $</strong></p>
<p><strong>期望得分：70分</strong></p>
<h4 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h4><p>我们考虑<strong>反向</strong>思考</p>
<p>计算<strong>无法生成2048的子序列个数</strong></p>
<hr>
<h5 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h5><p>对于一个集合$ {2^0,2^1,2^2, \cdots ,2^{10}} $,若</p>
<script type="math/tex; mode=display">
\sum_{i=0}^{10} 2^{i} \times Cnt_i>=2^{11}</script><p>那么这个集合<strong>一定可以生成2048</strong></p>
<p>证明<strong>显然</strong>？？？</p>
<hr>
<p>有了上边的引理，我们就可以直接求<strong>2的次方集合之和小于2048的子序列个数</strong></p>
<p>最后减掉所有<strong>无法构成2048的子序列</strong>即可</p>
<script type="math/tex; mode=display">
2^{Total}- \sum_{i=0}^{2047} DP[i] \times 2^{Cnt}</script><p><strong>时间复杂度：$ O(11^2 \times n) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">3e3</span>+<span class="number">10</span>,Limit=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[Limit]=&#123;<span class="number">1</span>&#125;,Total,Cnt[Limit],Else,Ans,Num[Limit];</span><br><span class="line">LL Fac[Limit]=&#123;<span class="number">1</span>&#125;,Inv[Limit],C[Limit];</span><br><span class="line"><span class="keyword">bool</span> Jud[Limit];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"C.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"C.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%MOD;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	<span class="keyword">for</span>(LL i=<span class="number">1</span>;i&lt;=<span class="number">2048</span>;i*=<span class="number">2</span>) Jud[i]=<span class="literal">true</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);<span class="keyword">if</span>(!Jud[Num[i]]) Else++;<span class="keyword">else</span> Cnt[Num[i]]++;&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Limit<span class="number">-5</span>) Fac[i]=(Fac[i<span class="number">-1</span>]*i)%MOD;</span><br><span class="line">	Inv[Limit<span class="number">-5</span>]=Fast(Fac[Limit<span class="number">-5</span>],MOD<span class="number">-2</span>);</span><br><span class="line">	BOR(i,Limit<span class="number">-6</span>,<span class="number">0</span>) Inv[i]=Inv[i+<span class="number">1</span>]*(i+<span class="number">1</span>)%MOD;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">2047</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!Cnt[i]) <span class="keyword">continue</span>;</span><br><span class="line">		LL Temp=Cnt[i];</span><br><span class="line">		<span class="keyword">if</span>(<span class="number">2048</span>/i&lt;Temp) Temp=<span class="number">2048</span>/i;</span><br><span class="line">		<span class="keyword">for</span>(;Temp&gt;=<span class="number">0</span>;Temp--) C[Temp]=(((Fac[Cnt[i]]*Inv[Cnt[i]-Temp])%MOD)*Inv[Temp])%MOD;</span><br><span class="line">		BOR(j,<span class="number">2047</span>,<span class="number">0</span>) &#123;<span class="comment">//倒序，类似背包 </span></span><br><span class="line">			<span class="keyword">if</span>(!DP[j]) <span class="keyword">continue</span>;</span><br><span class="line">			FOR(k,<span class="number">1</span>,Cnt[i]) &#123;</span><br><span class="line">				LL Res=k*i+j;</span><br><span class="line">				<span class="keyword">if</span>(Res&gt;=<span class="number">2048</span>) <span class="keyword">break</span>;</span><br><span class="line">				(DP[Res]+=DP[j]*C[k]%MOD)%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="comment">//因为总和超过2048一定可以组成=2048 </span></span><br><span class="line">	&#125;</span><br><span class="line">	Ans=Fast(<span class="number">2</span>,Total);</span><br><span class="line">	FOR(i,<span class="number">0</span>,<span class="number">2047</span>) Ans=((Ans-DP[i]*Fast(<span class="number">2</span>,Else))%MOD+MOD)%MOD;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;((Ans%MOD+MOD)%MOD)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200901赛后总结</title>
    <url>/articles/T20200901%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200901赛后总结"><a href="#T20200901赛后总结" class="headerlink" title="T20200901赛后总结"></a>T20200901赛后总结</h1><h2 id="成绩排行：T20200901成绩"><a href="#成绩排行：T20200901成绩" class="headerlink" title="成绩排行：T20200901成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/Exam/2020.9.1/test20200901.html](file:///C:/Users/12298/Desktop/Exam/2020.9.1/test20200901.html">T20200901成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>发挥还行。。。就是<strong>T1差点又写挂了</strong>。。。</p>
<p><strong>T3</strong>没有多去想，LBL说要给我们来一波<strong>酸爽</strong>。。。</p>
<p>结果T3就是一个<strong>树上启发式合并</strong>（虽然我多半调不出来。。。）</p>
<p>问题不大，之后的考试<strong>争取</strong>多点200+</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>期望+动态规划</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/01/9XMpuGFsL5DQS2z.png" alt="T20200901-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>本题作为T1，<strong>一定不难</strong>（emm）</p>
<p>但由于题目描述十分阔怕，导致我们的<strong>哲哥巨佬</strong>没有第一时间做出来</p>
<p>由题意可知$i-1$和$i$有一定概率合成$i+1$也有一定概率合成$i-1$</p>
<p>我们稍微转换一下，就知道$i-1$的剑<strong>不会消失</strong></p>
<p>所以我们只需要关注<strong>$i$合成$i+1$的贡献</strong></p>
<script type="math/tex; mode=display">
DP[i+1]=DP[i-1]+DP[i]* \frac{c_i}{min(c_i,b_{i-1})}</script><p>所以<strong>递推</strong>一下就欧了</p>
<p>当然我们需要<strong>线性求一下逆元</strong>（相信大家都会！）</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//forging</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e7</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Mon,P;</span><br><span class="line">LL Bx,By,Cx,Cy,B[MAXN],C[MAXN];</span><br><span class="line">LL Inv[MAXN],DP[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"forging.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"forging.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Mon);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d %d %d"</span>,&amp;Bx,&amp;By,&amp;Cx,&amp;Cy,&amp;P);</span><br><span class="line">	B[<span class="number">0</span>]=By+<span class="number">1</span>; C[<span class="number">0</span>]=Cy+<span class="number">1</span>; </span><br><span class="line">	FOR(i,<span class="number">1</span>,Total<span class="number">-1</span>) &#123; </span><br><span class="line">		B[i]=(<span class="number">1l</span>l*B[i<span class="number">-1</span>]*Bx+By)%P+<span class="number">1</span>; </span><br><span class="line">		C[i]=(<span class="number">1l</span>l*C[i<span class="number">-1</span>]*Cx+Cy)%P+<span class="number">1</span>; </span><br><span class="line">	&#125;</span><br><span class="line">	Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">2</span>,P) Inv[i]=(<span class="number">1l</span>l*Inv[MOD%i]*(MOD-(MOD/i)))%MOD;</span><br><span class="line">	DP[<span class="number">0</span>]=Mon;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) DP[i]=(((<span class="number">1l</span>l*DP[i<span class="number">-1</span>]*C[i<span class="number">-1</span>]%MOD)*<span class="number">1l</span>l*Inv[<span class="built_in">min</span>(C[i<span class="number">-1</span>],B[<span class="built_in">max</span>(i<span class="number">-2</span>,(LL)<span class="number">0</span>)])]%MOD)+DP[<span class="built_in">max</span>(i<span class="number">-2</span>,(LL)<span class="number">0</span>)])%MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,(DP[Total]%MOD+MOD)%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); </span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">p = ni + m</span></span><br><span class="line"><span class="comment">ni+m \equiv 0 (mod p)</span></span><br><span class="line"><span class="comment">ni \equiv -m (mod p)</span></span><br><span class="line"><span class="comment">m^&#123;-1&#125;*i \equiv -n^&#123;-1&#125; (mod p)</span></span><br><span class="line"><span class="comment">\so n^&#123;-1&#125; =&gt; Inv[p%n] * (-p/n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//考场上现推一下。。。</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>线性筛+枚举+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/01/1uE8LUNePzmgydO.png" alt="T20200901-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>考场上花最多时间的一道题。。。</p>
<p>结果被<strong>MK巨佬</strong>说是全场<strong>最水的题</strong>。。。</p>
<p>我们直接看数据范围，发现无论怎么凑<strong>时间复杂度</strong>都只有一种可能：$ O(ct) $</p>
<p>所以我们需要考虑的是$t$</p>
<p>我们将式子转换一下：</p>
<script type="math/tex; mode=display">
n | x^m - x \\
\Rightarrow na=x^m - x \\
\Rightarrow na + x=x^m \\
\Rightarrow x \equiv x^m (mod\,\,\,n)</script><p>推到这里，我们发现$n$是由<strong>几个互质的质数</strong>乘得这个条件十分重要</p>
<p>我们设</p>
<script type="math/tex; mode=display">
n=t_1^{e_1} \times t_2^{e_2} \times \cdots \times t_r^{e_r}</script><p>那么将$ t_1,t_2, \cdots , t_r $带入得</p>
<script type="math/tex; mode=display">
x \equiv x^m (mod\,\,\,t_i)\,\,\,i \in [1,r]</script><p>因为$t_i$互质，所以对于每一个$t_i$求出个数后<strong>直接相乘</strong>即可</p>
<p>但我们不能每次都求$x^m$（<strong>亲测</strong>只有80分）</p>
<p>所以我们需要像<strong>线性筛</strong>一样，将个别数利用<strong>已求出的数得到</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//division</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">1e4</span>+<span class="number">10</span>,MAXM=<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">LL Total,ID,Test,Num[MAXM],Mi,Ans=<span class="number">1</span>;</span><br><span class="line">LL Prime[MAXN],Cnt,Right[MAXN],Left[MAXN];</span><br><span class="line"><span class="keyword">bool</span> Jud[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"division.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"division.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B,LL P)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%P;</span><br><span class="line">		A=(A*A)%P; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%P;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">(LL New)</span> </span>&#123;</span><br><span class="line">	Jud[<span class="number">0</span>]=Jud[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">	Left[<span class="number">1</span>]=Fast(<span class="number">1</span>,Mi,New);</span><br><span class="line">	Right[<span class="number">1</span>]=(Left[<span class="number">1</span>]==<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">2</span>,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!Jud[i]) Prime[++Cnt]=i,Left[i]=Fast(i,Mi,New),Right[i]=(Left[i]==(i%New));</span><br><span class="line">		<span class="keyword">for</span>(LL j=<span class="number">1</span>;j&lt;=Cnt &amp;&amp; Prime[j]*i&lt;=New;j++) &#123;</span><br><span class="line">			Jud[i*Prime[j]]=<span class="literal">true</span>;</span><br><span class="line">			Left[i*Prime[j]]=(Left[i]*Left[Prime[j]])%New;</span><br><span class="line">			Right[i*Prime[j]]=(Left[i*Prime[j]]==((i*Prime[j])%New));</span><br><span class="line">			<span class="keyword">if</span>(!(i%Prime[j])) <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Cl(Jud,<span class="literal">false</span>); Cnt=<span class="number">0</span>; Cl(Prime,<span class="number">0</span>);</span><br><span class="line">	Cl(Right,<span class="number">0</span>); Cl(Left,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;ID);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Test);</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		Ans=<span class="number">1</span>;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Mi);</span><br><span class="line">		FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">			Clean();</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">			Init(Num[i]);</span><br><span class="line">			FOR(j,<span class="number">1</span>,Num[i]) Right[j]+=Right[j<span class="number">-1</span>];</span><br><span class="line">			<span class="keyword">if</span>(Right[Num[i]]) (Ans*=Right[Num[i]])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans%MOD);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); </span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0 </span></span><br><span class="line"><span class="comment">1 </span></span><br><span class="line"><span class="comment">2 3 </span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>倍增+树上启发式合并</strong></p>
<p>或<strong>LCT</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/01/4sjEWleCiS8Zbqh.png" alt="T20200901-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><hr>
<p><strong>吐槽一下：</strong>一个<strong>NOIP模拟题</strong>，出了一个<strong>LCT</strong>题在最后，吓人呢？</p>
<hr>
<p>冷静分析，深度思考</p>
<p>我们发现其实就是求两点能够达到得情况下的<strong>路径最小值</strong></p>
<p>所以我们会有<strong>（有根）LCT</strong>或<strong>启发式合并</strong>的想法</p>
<p>当然我这里就只讲一下启发式合并的做法</p>
<p>由于是一个<strong>DAG</strong>，所以我们在使用<strong>倍增</strong>求<code>Anc</code>和<code>Min</code>时需要记录<code>Dir</code></p>
<p>两点不能到达，当且仅当两点之间的<code>Dir</code>有<strong>相反边</strong></p>
<p>对于判断这个，我们只需要每次求倍增时用<strong>二进制记录</strong>一下或</p>
<p>所以，我们发现，好像就这么<strong>做完了</strong>。。。</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//money</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">1e5</span>+<span class="number">10</span>,MAXM=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Last,Total,Test;</span><br><span class="line"><span class="keyword">int</span> Next[MAXM&lt;&lt;<span class="number">1</span>],End[MAXM&lt;&lt;<span class="number">1</span>],Head[MAXN],Val[MAXM&lt;&lt;<span class="number">1</span>],Kind[MAXM&lt;&lt;<span class="number">1</span>],Cur;</span><br><span class="line"><span class="keyword">int</span> Root[MAXN],Dep[MAXN],Size[MAXN];</span><br><span class="line"><span class="keyword">int</span> Anc[MAXN][<span class="number">20</span>],Min[MAXN][<span class="number">20</span>],Dir[MAXN][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> u,v,w,Opt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"money.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"money.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> New,<span class="keyword">int</span> Pre,<span class="keyword">int</span> Top)</span> </span>&#123;</span><br><span class="line">	Root[New]=Top;</span><br><span class="line">	Dep[New]=Dep[Pre]+<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">17</span>) &#123;</span><br><span class="line">		Anc[New][i]=Anc[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">		Min[New][i]=<span class="built_in">min</span>(Min[New][i<span class="number">-1</span>],Min[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">		Dir[New][i]=(Dir[New][i<span class="number">-1</span>] | Dir[Anc[New][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	FOR_SIDE(i,New) &#123;</span><br><span class="line">		<span class="keyword">if</span>(End[i]==Pre) <span class="keyword">continue</span>;</span><br><span class="line">		Anc[End[i]][<span class="number">0</span>]=New;</span><br><span class="line">		Min[End[i]][<span class="number">0</span>]=Val[i];</span><br><span class="line">		Dir[End[i]][<span class="number">0</span>]=(Kind[i] ^ <span class="number">3</span>);</span><br><span class="line">		DFS(End[i],New,Top);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_Edge</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Next[++Cur]=Head[From];</span><br><span class="line">	Head[From]=Cur;</span><br><span class="line">	End[Cur]=To;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">1</span>;</span><br><span class="line">	Next[++Cur]=Head[To];</span><br><span class="line">	Head[To]=Cur;</span><br><span class="line">	End[Cur]=From;</span><br><span class="line">	Val[Cur]=Temp;</span><br><span class="line">	Kind[Cur]=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To,<span class="keyword">int</span> Temp)</span> </span>&#123;</span><br><span class="line">	Add_Edge(From,To,Temp);</span><br><span class="line">	<span class="keyword">int</span> Base=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(Size[Root[From]]&gt;Size[Root[To]]) Base=<span class="number">2</span>,swap(From,To);</span><br><span class="line">	Size[Root[To]]+=Size[Root[From]];</span><br><span class="line">	Anc[From][<span class="number">0</span>]=To;</span><br><span class="line">	Min[From][<span class="number">0</span>]=Temp;</span><br><span class="line">	Dir[From][<span class="number">0</span>]=Base;</span><br><span class="line">	DFS(From,To,Root[To]);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Get</span><span class="params">(<span class="keyword">int</span> From,<span class="keyword">int</span> To)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Base=<span class="number">1</span>,Ans=INF;</span><br><span class="line">	<span class="keyword">if</span>(Dep[From]&lt;Dep[To]) Base=<span class="number">2</span>,swap(From,To);</span><br><span class="line">	BOR(i,<span class="number">17</span>,<span class="number">0</span>) </span><br><span class="line">		<span class="keyword">if</span>(Dep[From]-(<span class="number">1</span>&lt;&lt;i)&gt;=Dep[To]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=<span class="built_in">min</span>(Ans,Min[From][i]);</span><br><span class="line">			From=Anc[From][i];</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">if</span>(From==To) <span class="keyword">return</span> Ans;</span><br><span class="line">	BOR(i,<span class="number">17</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Anc[From][i]!=Anc[To][i]) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Dir[From][i]!=Base || Dir[To][i]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			Ans=<span class="built_in">min</span>(Ans,<span class="built_in">min</span>(Min[From][i],Min[To][i]));</span><br><span class="line">			From=Anc[From][i]; </span><br><span class="line">			To=Anc[To][i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(Dir[From][<span class="number">0</span>]!=Base || Dir[To][<span class="number">0</span>]!=(Base ^ <span class="number">3</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	Ans=<span class="built_in">min</span>(Ans,<span class="built_in">min</span>(Min[From][<span class="number">0</span>],Min[To][<span class="number">0</span>]));</span><br><span class="line">	<span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Test);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) Root[i]=i,Size[i]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(Test--) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;Opt,&amp;u,&amp;v);</span><br><span class="line">		u=(u+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		v=(v+Last)%Total+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(Opt==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w);</span><br><span class="line">			w=(w+Last)%Total+<span class="number">1</span>;</span><br><span class="line">			Update(u,v,w);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Last=Get(u,v)); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>); </span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 9 </span></span><br><span class="line"><span class="comment">0 1 2 1 </span></span><br><span class="line"><span class="comment">0 0 1 2 </span></span><br><span class="line"><span class="comment">1 0 1 </span></span><br><span class="line"><span class="comment">1 2 4 </span></span><br><span class="line"><span class="comment">0 2 1 1 </span></span><br><span class="line"><span class="comment">1 2 0 </span></span><br><span class="line"><span class="comment">0 3 1 0 </span></span><br><span class="line"><span class="comment">1 4 2 </span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200902赛后总结</title>
    <url>/articles/T20200902%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200902赛后总结"><a href="#T20200902赛后总结" class="headerlink" title="T20200902赛后总结"></a>T20200902赛后总结</h1><h2 id="成绩排行：T20200902成绩"><a href="#成绩排行：T20200902成绩" class="headerlink" title="成绩排行：T20200902成绩)"></a>成绩排行：<a href="[file:///C:/Users/12298/Desktop/Exam/2020.9.2/result20200902.html](file:///C:/Users/12298/Desktop/Exam/2020.9.2/result20200902.html">T20200902成绩</a>)</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>%%%喹啉+苏巨</strong></p>
<p>日常<strong>炸裂</strong>。。。</p>
<p>考场上和哲哥对拍了接近<strong>10000</strong>组大小不一样的数据都没问题。。。</p>
<p>结果是<strong>错到一块儿去了</strong></p>
<p>至于后边的题，T2被mk带偏了，害，<strong>wtcl</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>归并+递归+贪心</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/02/3FdjcO9HpVlgUfT.png" alt="T20200902-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先我们可以直接发现</p>
<p>如果方案成立，最后的结果<strong>只有3种：P,R,S</strong></p>
<p>由于生成这3种的结果的下一层方案只有一种</p>
<script type="math/tex; mode=display">
P \Rightarrow P+R \\
R \Rightarrow R+S \\
S \Rightarrow S+P</script><p>所以我们就直接枚举最后结果，依次<strong>递归</strong>得到结果</p>
<p>最后判断$Cnt_{1,2,3}$是否等于$P,R,S$即可</p>
<p>但还有一个就是需要<strong>字典序最小</strong></p>
<p>手摸几个样例，发现，只有相邻的两个$2^i$会<strong>互相束缚</strong></p>
<p>所以我们可以直接像<strong>归并</strong>那样每次比较再<strong>交换两个区间</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//rps</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> R,P,S;</span><br><span class="line"><span class="keyword">int</span> Num[MAXN],Sum,Loc;</span><br><span class="line"><span class="keyword">int</span> Cnt[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"rps.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"rps.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> Temp,<span class="keyword">int</span> Left,<span class="keyword">int</span> Right)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(Left==Right) &#123;</span><br><span class="line">		Cnt[Num[Left]=Temp]++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> Mid=(Left+Right)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Solve(Temp,Left,Mid);</span><br><span class="line">	Solve((Temp)%<span class="number">3</span>+<span class="number">1</span>,Mid+<span class="number">1</span>,Right);</span><br><span class="line">	<span class="keyword">bool</span> Jud=<span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">int</span> Res=<span class="number">0</span>;</span><br><span class="line">	FOR(i,Left,Mid) <span class="keyword">if</span>(Num[i]!=Num[i-Left+Mid+<span class="number">1</span>]) &#123; Res=i; <span class="keyword">break</span>; &#125;</span><br><span class="line">	<span class="keyword">if</span>(Res!=<span class="number">0</span> &amp;&amp; Num[Res]&gt;Num[Res-Left+<span class="number">1</span>+Mid]) </span><br><span class="line">		FOR(i,Left,Mid) swap(Num[i],Num[i-Left+<span class="number">1</span>+Mid]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;R,&amp;P,&amp;S);</span><br><span class="line">	Sum=S+P+R;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;;(i&lt;&lt;=<span class="number">1</span>),Loc++)</span><br><span class="line">		<span class="keyword">if</span>(Sum==i) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">	Solve(<span class="number">1</span>,<span class="number">1</span>,Sum); </span><br><span class="line">	<span class="keyword">if</span>(Cnt[<span class="number">1</span>]==P &amp;&amp; Cnt[<span class="number">2</span>]==R &amp;&amp; Cnt[<span class="number">3</span>]==S) &#123;</span><br><span class="line">		FOR(i,<span class="number">1</span>,Sum) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Num[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"P"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(Num[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"S"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;Cl(Num,<span class="number">0</span>); Cl(Cnt,<span class="number">0</span>); </span><br><span class="line">	Solve(<span class="number">2</span>,<span class="number">1</span>,Sum); </span><br><span class="line">	<span class="keyword">if</span>(Cnt[<span class="number">1</span>]==P &amp;&amp; Cnt[<span class="number">2</span>]==R &amp;&amp; Cnt[<span class="number">3</span>]==S) &#123;</span><br><span class="line">		FOR(i,<span class="number">1</span>,Sum) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Num[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"P"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(Num[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"S"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;Cl(Num,<span class="number">0</span>); Cl(Cnt,<span class="number">0</span>); </span><br><span class="line">	Solve(<span class="number">3</span>,<span class="number">1</span>,Sum);</span><br><span class="line">	<span class="keyword">if</span>(Cnt[<span class="number">1</span>]==P &amp;&amp; Cnt[<span class="number">2</span>]==R &amp;&amp; Cnt[<span class="number">3</span>]==S) &#123;</span><br><span class="line">		FOR(i,<span class="number">1</span>,Sum) &#123;</span><br><span class="line">			<span class="keyword">if</span>(Num[i]==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"P"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(Num[i]==<span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">"R"</span>);</span><br><span class="line">			<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"S"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;Cl(Num,<span class="number">0</span>); Cl(Cnt,<span class="number">0</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"IMPOSSIBLE"</span>);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>期望+动态规划+贪心</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/02/8uB3xoSPrIvWTct.png" alt="T20200902-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>首先这道题的时间复杂度一定是$ O(n^2) $或者$ O(n^2 log n) $</p>
<p>所以我们考虑直接记录<strong>DP状态</strong>为<strong>2维</strong></p>
<hr>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><p>我们将$p$数组<strong>排序</strong></p>
<p>那么选择的$k$个人一定是一个<strong>前缀</strong>和一个<strong>后缀</strong></p>
<h5 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h5><p>我们假设排完序后，有一个人的前方和后方的都没有选</p>
<p>那么我们考虑这个人对答案的贡献</p>
<p>（$T$代表这个点的选<strong>“好的”</strong>的概率）</p>
<script type="math/tex; mode=display">
P_1 \times T + P_2 \times (1-T) \\
\Rightarrow T \times (P_1-P_2) + P_2</script><p>所以，我们发现无论$ P_1&gt;P_2 $或者$ P_1&lt;P_2 $</p>
<p>$T$改成$ T_1<T $或者$ T_2>T $都<strong>一定有一个是更优</strong>的</p>
<p>所以不存在这样的人</p>
<p><strong>证毕</strong></p>
<hr>
<p>有了上边的引理，我们就可以直接设置DP状态2维了</p>
<p><code>Suf[i][j],Pre[i][j]</code>分别表示<strong>前/后$i$个选$j$个”好的”</strong></p>
<p>最后枚举<strong>前/后缀长度</strong>统计答案即可</p>
<h3 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h3><blockquote>
<p><strong>printf的%f</strong>，为什么在double与float不同类型的时候，依旧是以这种格式的输出？这个根据<strong>“默认参数提升”</strong>规则，即其中有一条就是float型会被提升成double型，因此printf()只会看到<strong>双精度数</strong>，所以输出是都是<strong>%f</strong>；</p>
<p>而<strong>scanf</strong>，情况就会不同，它接受<strong>指针</strong>，这里直接通过指针指向所指的类型，float与double<strong>储存</strong>大不一样，因此<strong>区分%f以及%lf</strong>；</p>
</blockquote>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vote</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(int i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">2e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> E[MAXN],Pre[MAXN][MAXN],Suf[MAXN][MAXN],Ans;</span><br><span class="line"><span class="keyword">int</span> Total,Limit,Half;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"vote.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"vote.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;Total,&amp;Limit);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123; <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;E[i]); &#125;</span><br><span class="line">	sort(E+<span class="number">1</span>,E+Total+<span class="number">1</span>);</span><br><span class="line">	Suf[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1.0</span>;	</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		BOR(j,Total,<span class="number">1</span>) Suf[i][j]=Suf[i<span class="number">-1</span>][j<span class="number">-1</span>]*E[i]+Suf[i<span class="number">-1</span>][j]*(<span class="number">1</span>-E[i]);</span><br><span class="line">		Suf[i][<span class="number">0</span>]=Suf[i<span class="number">-1</span>][<span class="number">0</span>]*(<span class="number">1</span>-E[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Pre[Total+<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1.0</span>;</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		BOR(j,Total,<span class="number">1</span>) Pre[i][j]=Pre[i+<span class="number">1</span>][j<span class="number">-1</span>]*E[i]+Pre[i+<span class="number">1</span>][j]*(<span class="number">1</span>-E[i]);</span><br><span class="line">		Pre[i][<span class="number">0</span>]=Pre[i+<span class="number">1</span>][<span class="number">0</span>]*(<span class="number">1</span>-E[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	Half=(Limit&gt;&gt;<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">0</span>,Limit) &#123;</span><br><span class="line">		<span class="keyword">int</span> Loc=Total+<span class="number">1</span>+i-Limit;</span><br><span class="line">		<span class="keyword">double</span> Res=<span class="number">0.0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,Half) Res+=Suf[i][j]*Pre[Loc][Half-j];</span><br><span class="line">		Ans=<span class="built_in">max</span>(Ans,Res);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%f\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>二分图+动态规划</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/02/1OdbSFhGfPqW32n.png" alt="T20200902-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>由于我已经<strong>咕咕咕</strong>了，所以这里就直接套一个<strong>solution</strong>吧</p>
<blockquote>
<p>首先把问题转化为<strong>二分图模型</strong>，左边 个点表示<strong>工人</strong>，右边 个点表示<strong>机器</strong>，左右两个点有边当且仅当对应工人会操作对应机器。无论哪种情况下所有机器都能有人操作，就等价于，<strong>任意一个极大匹配都是完美匹配</strong>。</p>
<p>考虑问题的一个弱化版本：<strong>判断是否任意一个极大匹配都是完美匹配</strong>。</p>
<p>观察发现，任意一个极大匹配都是完美匹配(a) iff<strong>任意一个联通块都是左右点数相等的完全二分图(b)</strong>。</p>
<p><strong>证明：</strong></p>
<p>从b推出a是显然的，下面只用证明从a推出b。</p>
<p><strong>反证法</strong></p>
<p>假设存在一张二分图，存在一个联通块不是左右点数相等的完全二分图，同时满足任意一个极大匹配都是完美匹配。</p>
<p>如果这个联通块左右点数不相等，那么它就不存在完美匹配，显然矛盾。</p>
<p>否则这个联通块不是完全二分图，设左边的a点和右边的b点之间没有边，随便找一条从<strong>a到b的简单路径</strong>，记作p。选择p上的奇数边，再随便选一些边构造一个<strong>极大匹配</strong>，那么这个极大匹配必定是<strong>完美匹配</strong>。把奇数边改成偶数边，其他的边不变，那么除了a,b以外的点都在匹配上，所以得到了一个<strong>非完美匹配的极大匹配</strong>，矛盾。</p>
<p><strong>Q.E.D.</strong></p>
</blockquote>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200903赛后总结</title>
    <url>/articles/T20200903%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200903赛后总结"><a href="#T20200903赛后总结" class="headerlink" title="T20200903赛后总结"></a>T20200903赛后总结</h1><h2 id="成绩排行：T20200903成绩"><a href="#成绩排行：T20200903成绩" class="headerlink" title="成绩排行：T20200903成绩"></a>成绩排行：<a href="file:///C:/Users/12298/Desktop/Exam/2020.9.3/result20200903.html">T20200903成绩</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次是真的全考<strong>数学</strong>了<strong>/kk</strong></p>
<p><strong>死磕T1</strong>，结果自我感觉最难的就是T1了。。。</p>
<p>最后直接<strong>雪崩</strong>。。。</p>
<p><img src="https://i.loli.net/2020/09/03/AqSZ17Qp6j28UWe.gif" alt="T20200903-1.gif"></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>构造</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/VrWSsyaoKw95gX6.png" alt="T20200903-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><hr>
<p>我们先考虑<strong>弱化版</strong>：</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{i=1} \sum^{n}_{j=i+1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k)</script><p>发现，非常简单，<strong>化简一下</strong></p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} \sum^{j-1}_{i=1} \sum^{n}_{k=j+1} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \\
=\sum^{n}_{j=1} \left( \sum^{j-1}_{i=1} A_i \bigoplus A_j \right) \times \left( \sum^{n}_{k=j+1} A_j \bigoplus A_k \right)</script><p>我们令</p>
<script type="math/tex; mode=display">
L[j] = \sum^{j-1}_{i=1} A_i \bigoplus A_j \\
R[j] = \sum^{n}_{k=j+1} A_j \bigoplus A_k</script><p>所以我们可以得到</p>
<script type="math/tex; mode=display">
Ans = \sum^{n}_{j=1} L[j] \times R[j]</script><p>我们进而化简</p>
<p>设，$ Bit(i,j) $表示$i$的第$j$位是$ 1/0 $</p>
<script type="math/tex; mode=display">
L[j] = \sum^{30}_{k=0} 2^k \times \sum^{j-1}_{i=0} [Bit(A_j,k) \neq Bit(A_i,k)] \\
R[j] = \sum^{30}_{k=0} 2^k \times \sum^{n}_{i=j+1} [Bit(A_j,k) \neq Bit(A_i,k)]</script><hr>
<p>有了上边的<strong>基础</strong></p>
<p>对于<strong>升级版</strong></p>
<p>我们就可以<strong>轻松切了</strong></p>
<p>（当时推到这儿了，结果还是没有维护出来。。。<strong>wtcl</strong>）</p>
<script type="math/tex; mode=display">
Ans = \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (A_i \bigoplus A_k) \\
= \sum_{i<j<k} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times \sum^{30}_{b=0} 2^b \times (Bit(A_i,b) \neq Bit(A_k,b)) \\
= \sum^{30}_{b=0} 2^b \times \sum_{i<j<K} (A_i \bigoplus A_j) \times (A_j \bigoplus A_k) \times (Bit(A_i,b) \neq Bit(A_k,b))</script><p>所以，我们只需要枚举$ Bit(A_i,b) \neq Bit(A_k,b) $时的<strong>每一位</strong>即可统计答案</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>吐槽一下：</strong>实现是真的<strong>闹心</strong>。。。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>,Limit=<span class="number">35</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Num[MAXN],Ans;</span><br><span class="line">LL L[MAXN][<span class="number">2</span>],R[MAXN][<span class="number">2</span>];</span><br><span class="line">LL Suf[Limit][<span class="number">2</span>][<span class="number">2</span>],Pre[Limit][<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">LL Two[Limit]=&#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"xor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"xor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Solve</span><span class="params">(LL Temp)</span> </span>&#123;</span><br><span class="line">	Cl(Suf,<span class="number">0</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		L[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		L[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(L[i][<span class="number">0</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(L[i][<span class="number">1</span>]+=Suf[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Suf[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	Cl(Pre,<span class="number">0</span>);</span><br><span class="line">	BOR(i,Total,<span class="number">1</span>) &#123;</span><br><span class="line">		R[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">		R[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(R[i][<span class="number">0</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">0</span>])%=MOD;</span><br><span class="line">			(R[i][<span class="number">1</span>]+=Pre[j][Loc ^ <span class="number">1</span>][<span class="number">1</span>])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">		LL Bit=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;Temp))&gt;<span class="number">0</span>);</span><br><span class="line">		FOR(j,<span class="number">0</span>,<span class="number">30</span>) &#123;</span><br><span class="line">			LL Loc=((Num[i] &amp; (<span class="number">1</span>&lt;&lt;j))&gt;<span class="number">0</span>);</span><br><span class="line">			(Pre[j][Loc][Bit]+=Two[j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	LL Res=<span class="number">0</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Val=(L[i][<span class="number">0</span>]*R[i][<span class="number">1</span>]+L[i][<span class="number">1</span>]*R[i][<span class="number">0</span>])%MOD;</span><br><span class="line">		(Res+=(Val*Two[Temp]))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,<span class="number">30</span>) Two[i]=Two[i<span class="number">-1</span>]*<span class="number">2</span>%MOD;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Num[i]);</span><br><span class="line">	FOR(Loc,<span class="number">0</span>,<span class="number">30</span>) (Ans+=Solve(Loc))%=MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/ocVUwvBbyXCkKgZ.png" alt="T20200903-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><hr>
<p><strong>吐槽一下：</strong>由于我把题读错了？导致对着<strong>题解</strong>搞了好久</p>
<hr>
<p>我们如果直接枚举$n,k$状态，那么算重是一定的了</p>
<p>所以，我们需要<strong>枚举每一个数选的个数</strong></p>
<p>自然，我们就可以设计出状态<code>DP[i][j]</code>表示<strong>选了$i$个数，总和位$j$的集合数</strong></p>
<p>所以我们可以先求出<code>DP[i][j]</code>，最后来枚举每一个数的个数即可</p>
<p>但我们不能像通常一样枚举$i,j$，这样是$ O(n^3) $</p>
<p>我们可以考虑两种<strong>转移方式</strong>：</p>
<ul>
<li>在当前集合状态下<strong>加一个1</strong></li>
<li>将当前集合中的<strong>所有数加1</strong></li>
</ul>
<p>所以，我们的转移就是$ O(n^2) $了</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//set</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lowbit(X) (X&amp;(-X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Lson (X&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Rson (X&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[MAXN][MAXN],Ans;</span><br><span class="line">LL Total,Base,Limit;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"set.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"set.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) &#123; Res=(Res*A)%MOD; &#125;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld %lld"</span>,&amp;Total,&amp;Limit,&amp;Base);</span><br><span class="line">	DP[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">0</span>,Limit<span class="number">-1</span>) </span><br><span class="line">		FOR(j,<span class="number">0</span>,Total) &#123;</span><br><span class="line">			(DP[i+<span class="number">1</span>][j+<span class="number">1</span>]+=DP[i][j])%=MOD;</span><br><span class="line">			<span class="keyword">if</span>(i &amp;&amp; j+i&lt;=Total) (DP[i][j+i]+=DP[i][j])%=MOD;</span><br><span class="line">		&#125;</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) &#123;</span><br><span class="line">		LL Sum=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(LL j=<span class="number">1</span>;j&lt;=(Total/i) &amp;&amp; j&lt;=Limit;j++) </span><br><span class="line">			(Sum+=DP[Limit-j][Total-i*j])%=MOD;</span><br><span class="line">		(Ans+=Sum*Fast(i,Base))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans%MOD);</span><br><span class="line">    fclose(<span class="built_in">stdin</span>); fclose(<span class="built_in">stdout</span>);</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>组合数学+构造</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/03/decQ8gDUjRNKpi6.png" alt="T20200903-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>因为我们直接<strong>正面解决</strong>问题是很困难的</p>
<p>所以我们考虑计算无法满足题目要求的集合的个数，即：</p>
<ul>
<li><strong>最大值不超过$k$</strong></li>
<li><strong>所有数异或之和位0</strong></li>
</ul>
<hr>
<h4 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h4><p><strong>从高到低</strong>考虑，<strong>一定存在</strong>一个$A_i$满足$ Bit(A_i,j) \neq Bit(k,j) $</p>
<p>证明<strong>显然</strong>，<strong>故咕</strong></p>
<p>因为$ \forall i \in [1,n],A_i \leq k $</p>
<p>所以当存在时，<strong>当且仅当</strong>$A_i$的第$j$位为<strong>0</strong></p>
<hr>
<p>有了这个引理，这道题基本就可以<strong>宣告结束</strong>了</p>
<p>对于剩下的$n-1$个数，他们的剩下$j-1$位可以<strong>乱填</strong>都是没有问题的</p>
<p>所以我们来考虑$ Bit(A_i,j)==0 $，他的$ [0,j-1] $有$ 2^j $种情况</p>
<p>对于$ Bit(A_i,j)==1 $，他的$ [0,j-1] $有$ k \,\,\, \&amp; \,\,\, (2^j-1)+1 $</p>
<p>所以，我们可以<strong>枚举</strong>满足$ Bit(A_i,j)==0 $的数的个数</p>
<p><strong>方案数</strong>为：</p>
<script type="math/tex; mode=display">
{n \choose v} \times (2^j)^{v-1} \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v}</script><p>我们必须要保证$v$和$n$的<strong>奇偶性相同</strong>，才能使得最后异或和为0</p>
<p>进而，我们可以通过<strong>二项式定理</strong>来化简</p>
<p>对于$n$为<strong>偶数</strong>的情况（<strong>奇数</strong>很简单的啦）</p>
<script type="math/tex; mode=display">
Ans = (2^{-j-1}) \times \sum^{n}_{n=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times ((-1)^v + 1^v)</script><p>所以</p>
<script type="math/tex; mode=display">
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times (-1)^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1-2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n) \\
(2^{-j-1}) \times \sum^{n}_{v=2} {n \choose v} \times (2^j)^v \times (k \,\,\, \& \,\,\, (2^j-1)+1)^{n-v} \times 1^v \\
\Rightarrow (2^{-j-1}) \times ((k \,\,\, \& \,\,\, (2^j-1)+1+2^j)^n - (k \,\,\, \& \,\,\, (2^j-1)+1)^n)</script><p><strong>时间复杂度：$ O(log^2n) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xor2 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Ans,Limit,Temp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"xor2.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"xor2.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	A=((A%MOD+MOD)%MOD);</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%MOD;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Limit);</span><br><span class="line">	<span class="keyword">if</span>(!(Total%<span class="number">2</span>)) Temp++;</span><br><span class="line">	BOR(i,<span class="number">29</span>,<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Limit &amp; (<span class="number">1</span>&lt;&lt;i)) &#123;</span><br><span class="line">			LL Last=(Limit &amp; ((<span class="number">1</span>&lt;&lt;i)<span class="number">-1</span>))+<span class="number">1</span>;</span><br><span class="line">			LL Val=(<span class="number">1</span>&lt;&lt;i);</span><br><span class="line">			<span class="keyword">if</span>(Total%<span class="number">2</span>==<span class="number">0</span>) &#123;</span><br><span class="line">				Ans=Fast(Last+Val,Total)%MOD;</span><br><span class="line">				(Ans+=Fast(Last-Val,Total))%=MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				Ans=((Ans-Fast(Last,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Temp+=(Ans*Fast(Val,MOD<span class="number">-2</span>)))%=MOD;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Ans=Fast(Last+Val,Total)%MOD;</span><br><span class="line">				Ans=((Ans-Fast(Last-Val,Total))%MOD+MOD)%MOD;</span><br><span class="line">				(Ans*=((MOD+<span class="number">1</span>)/<span class="number">2</span>))%=MOD;</span><br><span class="line">				(Temp+=Ans*Fast(Val,MOD<span class="number">-2</span>)%MOD)%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(Total &amp; <span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Fast(Limit+<span class="number">1</span>,Total)-Temp)%MOD+MOD)%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200904赛后总结</title>
    <url>/articles/T20200904%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200904赛后总结"><a href="#T20200904赛后总结" class="headerlink" title="T20200904赛后总结"></a>T20200904赛后总结</h1><h2 id="成绩排行：T20200904成绩"><a href="#成绩排行：T20200904成绩" class="headerlink" title="成绩排行：T20200904成绩"></a>成绩排行：<a href="file:///C:/Users/12298/Desktop/Exam/2020.9.4/result20200904.html">T20200904成绩</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>T1</strong>推了2个小时结果还不如一个<strong>暴力</strong>。。。</p>
<p><strong>T2</strong>就一个<strong>ZZ题</strong>？？？</p>
<p>总的来说，做题<strong>策略</strong>吧，以后千万不要纠结一个题$ \geq $<strong>1 hour</strong></p>
<p><strong>在线膜哲哥</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>唯一分解+动态规划</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/04/iG5ztxeKR7yQXm2.png" alt="T20200904-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>推了贼久，一直考虑<strong>容斥</strong>。。。</p>
<p>结果数据范围给的是<strong>DP</strong></p>
<p>首先我们可以想到关于$n$的<strong>因数分解</strong>的一些性质</p>
<p>所以</p>
<script type="math/tex; mode=display">
a_i = \frac{n}{b_i} \Rightarrow \prod_{i=1}^{2m} a_i \leq n^m \Rightarrow \prod^{2m}_{i=1} b_i \geq n^m</script><p>这里之后，我们发现对于一个$a_i$的选择，一定存在一个$b_i$序列与之<strong>一一对应</strong></p>
<p>所以我们设</p>
<script type="math/tex; mode=display">
s_1 = [ \prod^{2m}_{i=1} a_i < n^m] \\
s_2 = [ \prod^{2m}_{i=1} a_i = n^m] \\
s_3 = [ \prod^{2m}_{i=1} a_i > n^m]</script><p>进而</p>
<script type="math/tex; mode=display">
s_1+s_2+s_3= \sigma_{n}^{2m}\,\,\,and\,\,\,s_1=s_3 \\
\Rightarrow s_1=s_3= \frac{ \sigma^{2m}_{n}-s_2}{2}</script><p>那么</p>
<script type="math/tex; mode=display">
Ans=s_1+s_2 = \frac{ \sigma^{2m}_{n}+s_2}{2}</script><p>现在问题转<strong>换成了如何求$ s_2 $</strong></p>
<p>即：</p>
<script type="math/tex; mode=display">
Cnt= \prod_{i=1}^{2m} a_i = n^m</script><p>我们将$n$化为<strong>质因数分解</strong>形式$ n = p_1^{e_1} \cdot p_2^{e_2} \cdot p_3^{e_3} \cdots p_r^{e_r} $</p>
<p>那么$ n^m = p_1^{e_1m} \cdot p_2^{e_2m} \cdot p_3^{e_3m} \cdots p_r^{e_rm} $</p>
<p>由于$n$的<strong>质因数个数</strong>为<strong>$ logn $级别</strong></p>
<p>所以，我们可以直接统计对于$n$的<strong>每个质因子</strong>在结果中的<strong>贡献</strong></p>
<p>就是一个简单的<strong>DP</strong>了</p>
<script type="math/tex; mode=display">
dp[i][j] = \sum^{w}_{k=0} dp[i-1][j-k]</script><p><strong>时间复杂度：$ O( \sqrt{n} + logn \times m^2) $</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">5e3</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL DP[MAXN],N,M;</span><br><span class="line">LL Cnt,Num=<span class="number">1</span>,Ans=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"count.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"count.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(LL Temp)</span> </span>&#123;</span><br><span class="line">	Cl(DP,<span class="number">0</span>);</span><br><span class="line">	DP[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">1</span>,M*<span class="number">2</span>) &#123;</span><br><span class="line">		FOR(j,<span class="number">1</span>,M*Temp) (DP[j]+=DP[j<span class="number">-1</span>])%=MOD;</span><br><span class="line">		BOR(j,M*Temp,Temp+<span class="number">1</span>) DP[j]=((DP[j]-DP[j-Temp<span class="number">-1</span>])%MOD+MOD)%MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	(Ans*=(DP[M*Temp]))%=MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Fast</span><span class="params">(LL A,LL B)</span> </span>&#123;</span><br><span class="line">	LL Res=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(B) &#123;</span><br><span class="line">		<span class="keyword">if</span>(B &amp; <span class="number">1</span>) Res=(Res*A)%MOD;</span><br><span class="line">		A=(A*A)%MOD; B&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Res%MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;N,&amp;M);</span><br><span class="line">	<span class="keyword">for</span>(LL i=<span class="number">2</span>;i*i&lt;=N;i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(N%i) <span class="keyword">continue</span>;</span><br><span class="line">		Cnt=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(!(N%i)) Cnt++,N/=i;</span><br><span class="line">		Solve(Cnt);</span><br><span class="line">		(Num*=(Cnt+<span class="number">1</span>))%=MOD;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(N&gt;<span class="number">1</span>) Solve(<span class="number">1</span>),(Num*=<span class="number">2</span>)%=MOD;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,(((Fast(Num,<span class="number">2</span>*M)+Ans)%MOD+MOD)%MOD)*Fast(<span class="number">2</span>,MOD<span class="number">-2</span>)%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心+动态规划+树状数组</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/04/lrPu6B9zWtweNAa.png" alt="T20200904-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>看到这个数据范围，肯定有<strong>蹊跷</strong></p>
<p>由于这是一个类似的<strong>偏序列</strong></p>
<p>我们设$ a $为<strong>最小链划分</strong>，$b$为<strong>最大反链长度</strong></p>
<p>由<strong><code>Dilworth</code>定理</strong>，我们可以知道</p>
<script type="math/tex; mode=display">
a \times b \geq n \\
\Rightarrow max(a,b) \geq \sqrt{n}</script><p>所以，我们每次取<strong>最长的偏序列</strong></p>
<p>可以在$ \sqrt{n} \leq 500 $的次数内取完</p>
<p>所以我们直接<strong>暴力</strong>计算每次的<strong>最长链</strong>即可</p>
<p><strong>时间复杂度：$ O(500 \times nlogn) $</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>（主要是懒得写了，就直接贴std了，嘿嘿嘿）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">64005</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn],a0[maxn],n,tot,f[maxn],g[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec[maxn];</span><br><span class="line"><span class="keyword">int</span> mx1[maxn],mx2[maxn],bac[maxn],del[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,tot);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> len=vec[i].<span class="built_in">size</span>();</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>,len);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j=len<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d%c"</span>,vec[i][j],<span class="string">" \n"</span>[j==<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		mx1[i]=<span class="built_in">max</span>(mx1[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		mx2[i]=<span class="built_in">max</span>(mx2[i],v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i;i-=i&amp;-i)</span><br><span class="line">		res=<span class="built_in">max</span>(res,mx1[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=x;i&lt;=n;i+=i&amp;-i)</span><br><span class="line">		res=<span class="built_in">max</span>(res,mx2[i]);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DP</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	++tot;</span><br><span class="line">	<span class="built_in">memset</span>(mx1,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="built_in">memset</span>(mx2,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> ans1=<span class="number">0</span>,ans2=<span class="number">0</span>;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		f[i]=query1(a[i])+<span class="number">1</span>;</span><br><span class="line">		g[i]=query2(a[i])+<span class="number">1</span>;</span><br><span class="line">		insert1(a[i],f[i]);</span><br><span class="line">		insert2(a[i],g[i]);</span><br><span class="line">		ans1=<span class="built_in">max</span>(ans1,f[i]);</span><br><span class="line">		ans2=<span class="built_in">max</span>(ans2,g[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(del,<span class="number">0</span>,n+<span class="number">1</span>&lt;&lt;<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span> (ans1&gt;ans2) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t=ans1,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (f[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].pb(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> t=ans2,i=n;t;i--)</span><br><span class="line">			<span class="keyword">if</span> (g[i]==t) del[a[i]]=<span class="number">1</span>,t--,vec[tot].pb(a0[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		bac[i]=bac[i<span class="number">-1</span>]+<span class="number">1</span>-del[i];</span><br><span class="line">	<span class="keyword">int</span> pos=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">if</span> (!del[a[i]]) a0[++pos]=a0[i],a[pos]=bac[a[i]];</span><br><span class="line">	n=pos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">		freopen(<span class="string">"delete.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">		freopen(<span class="string">"delete.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]),a0[i]=a[i];</span><br><span class="line">	<span class="keyword">while</span> (n) DP();</span><br><span class="line">	Print();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>生成函数+构造+矩阵快速幂</strong></p>
<p>（<strong>打表？？？</strong>）</p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/04/FwYCZc1pSDXaLMh.png" alt="T20200904-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><hr>
<p><strong>吐槽一下：</strong></p>
<p>考场上，肯定是第一时间来<strong>打一个表</strong>鸭！！！</p>
<p>注意一点，就是要<strong>特判</strong>几个地方</p>
<p>不然就像哲哥一样<strong>99分</strong>了。。。</p>
<hr>
<p>由<strong>斐波那契数列通项公式</strong>可以得到启发</p>
<p>我们设</p>
<script type="math/tex; mode=display">
a= \frac{ \sqrt{5}+1}{2} \\
b= \frac{ \sqrt{5}-1}{2}</script><p>所以我们发现，这个是数列$ A<em>i=A</em>{i-1}+A_{i-2} $的<strong>特征方程</strong></p>
<script type="math/tex; mode=display">
t^2 = t + 1</script><p>的解</p>
<p>所以我们可以直接<strong>构造这个数列</strong></p>
<p>并且将<strong>系数</strong>带入特征方程$ t^2 = q \cdot t + p $后</p>
<p>得到$ A_i=a^i + b^i $</p>
<p>所以得到，$ A_1=1,A_2=3 $</p>
<p>所以得出<strong>结论</strong></p>
<script type="math/tex; mode=display">
n \equiv 0 (mod\,\,\,2) \Rightarrow 0 < b^n < 1 \Rightarrow \lfloor x^n \rfloor =A_n-1 \\
n \equiv 1 (mod\,\,\,2) \Rightarrow -1 <b^n < 0 \Rightarrow \lfloor x^n \rfloor =A_n</script><p>所以我们直接<strong>矩阵快速幂</strong>转移一下即可</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//floor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR_SIDE(i,A) for(LL i=Head[A];i;i=Next[i])</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">LL Total,MOD,Res;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL Squ[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">	LL Row,Line;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Clean</span><span class="params">(LL X)</span> </span>&#123;</span><br><span class="line">		FOR(i,<span class="number">1</span>,<span class="number">3</span>) FOR(j,<span class="number">1</span>,<span class="number">3</span>) Squ[i][j]=X;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">friend</span> Node <span class="keyword">operator</span> * (Node A,Node B) &#123;</span><br><span class="line">		Node Temp;</span><br><span class="line">		Temp.Clean((LL)<span class="number">0</span>);</span><br><span class="line">		FOR(i,<span class="number">1</span>,<span class="number">3</span>) FOR(j,<span class="number">1</span>,<span class="number">3</span>) FOR(k,<span class="number">1</span>,<span class="number">3</span>) </span><br><span class="line">			(Temp.Squ[i][j]+=(A.Squ[i][k]*B.Squ[k][j])%MOD)%=MOD;</span><br><span class="line">		<span class="keyword">return</span> Temp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;Sta,Base;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"floor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"floor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Fast</span><span class="params">(LL F)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(F) &#123;</span><br><span class="line">		<span class="keyword">if</span>(F &amp; <span class="number">1</span>) Sta=(Sta*Base);</span><br><span class="line">		Base=(Base*Base);</span><br><span class="line">		F&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;MOD); Res=Total;</span><br><span class="line">	Sta.Clean((LL)<span class="number">0</span>); Base.Clean((LL)<span class="number">0</span>);</span><br><span class="line">	Sta.Squ[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">4</span>; Sta.Squ[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">3</span>; Sta.Squ[<span class="number">1</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">	Base.Squ[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">1</span>; Base.Squ[<span class="number">2</span>][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	Base.Squ[<span class="number">1</span>][<span class="number">2</span>]=<span class="number">1</span>; Base.Squ[<span class="number">2</span>][<span class="number">3</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(MOD==<span class="number">1</span>) &#123; <span class="built_in">printf</span>(<span class="string">"0\n"</span>); <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">	<span class="keyword">if</span>(Total==<span class="number">0</span> || Total==<span class="number">1</span>) &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">	<span class="keyword">if</span>(Total==<span class="number">2</span>) &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"1"</span>&lt;&lt;<span class="built_in">endl</span>; <span class="keyword">return</span> <span class="number">0</span>; &#125; </span><br><span class="line">	Fast(Total<span class="number">-3</span>);</span><br><span class="line">	<span class="keyword">if</span> (!(Total % <span class="number">2</span>)) &#123; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,((Sta.Squ[<span class="number">1</span>][<span class="number">1</span>]<span class="number">-1</span>)%MOD+MOD)%MOD); &#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Sta.Squ[<span class="number">1</span>][<span class="number">1</span>]%MOD);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200905-day1赛后总结</title>
    <url>/articles/T20200905-day1%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200905-day1赛后总结"><a href="#T20200905-day1赛后总结" class="headerlink" title="T20200905-day1赛后总结"></a>T20200905-day1赛后总结</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>wtcl！！！</strong></p>
<p>不说了，我觉得我参加了一次<strong>NOI模拟赛</strong>。。。</p>
<p><strong>暴力</strong>打的跟打<strong>NOI同步赛</strong>的时候差不多了</p>
<p><strong>T1</strong>思路对的，但还是没打出来。。。</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>作为一个<strong>一般不会咕咕咕</strong>的<strong>蒟蒻</strong></p>
<p>这次还是<strong>勉为其难</strong>的咕了吧。。。</p>
<p><img src="https://i.loli.net/2020/09/05/pJdBxHGY9hkrLSb.gif" alt="T20200903-1.gif"></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/05/LQ6pRGH1XekYO32.png" alt="T20200905-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/05/TjeZDrfQ4pcNV91.png" alt="T20200905-1.png"></p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/05/scWovn8dzKpjhOM.png" alt="T20200905-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/05/uPw2tWF4sQ5mbYk.png" alt="T20200905-2.png"></p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/05/YhlvHoMxWRcKU38.png" alt="T20200905-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/05/lhp9cfoUdRZWq8X.png" alt="T20200905-3.png"></p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/05/ZO9C5FYawxzk2Uu.png" alt="T20200905-D.png"></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/05/uoiPWEIBpvmwjQk.png" alt="T20200905-4.png"></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200907-day2赛后总结</title>
    <url>/articles/T20200907-day2%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200907-day2赛后总结"><a href="#T20200907-day2赛后总结" class="headerlink" title="T20200907-day2赛后总结"></a>T20200907-day2赛后总结</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>混吃等死</strong>一早上，<strong>睡舒服了</strong>。。。</p>
<p><strong>长乐一中</strong>出题咋就是喜欢每道题沾一点<strong>组合数学</strong>的边呢？？？</p>
<p><strong>贼难受了！</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/07/vPqQLnN9Hyl6Ufj.png" alt="T20200907-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/07/S28xPLTwcD7vUfg.png" alt="T20200907-1.png"></p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/07/A8whbZXLQDqk4Gz.png" alt="T20200907-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/07/GXxlkpDJHNTI9hL.png" alt="T20200907-2.png"></p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/07/Z7n94UGwJkWoeu8.png" alt="T20200907-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/07/TraSkIl9hV3LAe1.png" alt="T20200907-3.png"></p>
<h2 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/07/cLF1C7UgYWqxrNh.png" alt="T20200907-D.png"></p>
<h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/07/gk5sDqmhafudRFc.png" alt="T20200907-4.png"></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200908赛后总结</title>
    <url>/articles/T20200908%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200908赛后总结"><a href="#T20200908赛后总结" class="headerlink" title="T20200908赛后总结"></a>T20200908赛后总结</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>没啥好说的。。。</p>
<p>再次提前参加了一次<strong>“IOI同步赛”</strong>。。。</p>
<p>祝明儿<strong>不要爆零/qd /qd</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/08/JrWUG8pIqMXcA1D.png" alt="T20200908-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/08/Da7yKvGufwi9PBF.png" alt="T20200908-1.png"></p>
<p><img src="https://i.loli.net/2020/09/08/VieuyDZJPLKbfY8.png" alt="T20200908-2.png"></p>
<p><img src="https://i.loli.net/2020/09/08/GwBveJ1ClFX4S7W.png" alt="T20200908-3.png"></p>
<p><img src="https://i.loli.net/2020/09/08/4il9YVOGjChLuqz.png" alt="T20200908-4.png"></p>
<p><img src="https://i.loli.net/2020/09/08/2AmPz6GN5Hu4eVg.png" alt="T20200908-5.png"></p>
<p><img src="https://i.loli.net/2020/09/08/hOE6kr4SJCFf2T1.png" alt="T20200908-6.png"></p>
<p><img src="https://i.loli.net/2020/09/08/DKnlYCbX4jGgBAh.png" alt="T20200908-7.png"></p>
<p><img src="https://i.loli.net/2020/09/08/BsYd8GoWceO1qfP.png" alt="T20200908-8.png"></p>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/08/Evk98UYZXg4RaOz.png" alt="T20200908-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/08/cMNOuXpkgonJ4Fh.png" alt="T20200908-9.png"></p>
<p><img src="https://i.loli.net/2020/09/08/gTsq3vfOoj1FG2C.png" alt="T20200908-10.png"></p>
<p><img src="https://i.loli.net/2020/09/08/urfQ6P9BgRp3Ln7.png" alt="T20200908-11.png"></p>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/08/mz2OntQTE3RKeWG.png" alt="T20200908-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p><img src="https://i.loli.net/2020/09/08/hsuvpSFUlGoCM8z.png" alt="T20200908-12.png"></p>
<p><img src="https://i.loli.net/2020/09/08/ZvA49FTDuUciewS.png" alt="T20200908-13.png"></p>
<p><img src="https://i.loli.net/2020/09/08/pN4jAwRIKSMDyk7.png" alt="T20200908-14.png"></p>
<p><img src="https://i.loli.net/2020/09/08/e3yJdUcZ5MFQ7sx.png" alt="T20200908-15.png"></p>
<p><img src="https://i.loli.net/2020/09/08/BNytU73uxKcODlQ.png" alt="T20200908-16.png"></p>
<p><img src="https://i.loli.net/2020/09/08/wJUpWOVSaKZEvyC.png" alt="T20200908-17.png"></p>
<p><img src="https://i.loli.net/2020/09/08/EPaDoAkyHmpeNFv.png" alt="T20200908-18.png"></p>
<p><img src="https://i.loli.net/2020/09/08/wtOzKVAgoMlFZk1.png" alt="T20200908-19.png"></p>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200909赛后总结</title>
    <url>/articles/T20200909%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200909赛后总结"><a href="#T20200909赛后总结" class="headerlink" title="T20200909赛后总结"></a>T20200909赛后总结</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本次考的是<strong>正睿秋季提高组十连测day2</strong></p>
<p>感觉<strong>海星</strong>，（<strong>哲哥40分钟200分</strong>直接转身走人%%%）</p>
<p>难度<strong>梯度</strong>十分友好，能够拿到分。。。</p>
<p><strong>T3</strong>最为<strong>压轴题</strong>，很有<strong>思考性</strong></p>
<p>但由于蒟蒻我实在是不会<strong>位运算优化三进制</strong></p>
<p>internet也<strong>找不到</strong>，所有只好<strong>咕咕</strong>了</p>
<p>但T3的思想<strong>很值得学习</strong>，总结</p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>贪心+线段树（单调栈）</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/09/mlq1HnIGwSdseu4.png" alt="T20200909-A.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>由于本题的意思是，每一个月可以<strong>补给一波</strong></p>
<p>所以我们可以<strong>逐月贪心</strong></p>
<p>并且每次尽量从<strong>最小</strong>的开始取</p>
<p>所以，我们记录之前所有月<strong>使用某种方案的次数</strong></p>
<p>当前月可以使用的次数即为：</p>
<script type="math/tex; mode=display">
i \times State[j].Limit-State[j].Cnt</script><p><strong>贪心转移</strong>即可</p>
<p>但如果数据十分<strong>毒瘤</strong>，这种时间复杂度可以被卡到$ O(nm) $</p>
<p><strong>期望得分：60分</strong></p>
<p><strong>实际得分：100分</strong></p>
<p>所以，我们考虑<strong>优化</strong>贪心过程</p>
<p>使用<strong>线段树维护前缀</strong>，每次取最优$ O(logn) $即可</p>
<p><strong>时间复杂度：$ O(nlogn) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>懒</strong>得改了，就直接<strong>水</strong>了一个$ O(nm) $的（$ O( \text{能过}) $）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//day2 A</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MAXN=<span class="number">2e5</span>+<span class="number">10</span>,Max=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Test,Need[MAXN],Ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	LL Cnt;</span><br><span class="line">	LL Mon,Limit;</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node A,Node B) </span><br><span class="line">	&#123; <span class="keyword">return</span> A.Mon&lt;B.Mon; &#125;</span><br><span class="line">&#125;State[MAXN];</span><br><span class="line">				</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">".out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Total,&amp;Test);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;Need[i]);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Test) &#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;State[i].Mon,&amp;State[i].Limit);</span><br><span class="line">		<span class="keyword">if</span>(State[i].Limit==<span class="number">-1</span>) State[i].Limit=Max;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(State+<span class="number">1</span>,State+Test+<span class="number">1</span>);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) FOR(j,<span class="number">1</span>,Test) &#123;</span><br><span class="line">		LL Use=State[j].Limit*i-State[j].Cnt;</span><br><span class="line">		<span class="keyword">if</span>(Use&gt;=Need[i])&#123; </span><br><span class="line">			State[j].Cnt+=Need[i]; </span><br><span class="line">			Ans+=State[j].Mon*Need[i]; </span><br><span class="line">			<span class="keyword">break</span>; </span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			State[j].Cnt+=Use;</span><br><span class="line">			Ans+=Use*State[j].Mon;</span><br><span class="line">			Need[i]-=Use; </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line"><span class="comment">//	fclose(stdin);</span></span><br><span class="line"><span class="comment">//	fclose(stdout);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">2 3</span></span><br><span class="line"><span class="comment">3 10</span></span><br><span class="line"><span class="comment">1 4</span></span><br><span class="line"><span class="comment">2 4</span></span><br><span class="line"><span class="comment">3 -1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>排序</strong>。。。</p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/09/BzKrMRVUAOoHQWe.png" alt="T20200909-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><hr>
<p><strong>吐槽一下：</strong>这<strong>签到题</strong>是不是太直白了。。。</p>
<hr>
<p>因为两个字符串谁在前，只需要比较$a+b$和$b+a$即可</p>
<p>但我们手动$+$十分难受</p>
<p>所以我们直接使用<strong><code>string</code>重载</strong>即可</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//day2 B</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total;</span><br><span class="line"><span class="built_in">string</span> Num[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Comp</span><span class="params">(<span class="built_in">string</span> A,<span class="built_in">string</span> B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (A+B)&lt;(B+A);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">".in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">",out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//	File();</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">cin</span>&gt;&gt;Num[i];</span><br><span class="line">	sort(Num+<span class="number">1</span>,Num+Total+<span class="number">1</span>,Comp);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">cout</span>&lt;&lt;Num[i];</span><br><span class="line"><span class="comment">//	fclose(stdin);</span></span><br><span class="line"><span class="comment">//	fclose(stdout);</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">aa</span></span><br><span class="line"><span class="comment">abb</span></span><br><span class="line"><span class="comment">ab</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>博弈论+线性基+位运算优化三进制</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/09/ksFax7yTBwJ9hKZ.png" alt="T20200909-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>作为<strong>压轴题</strong>，真的十分有质量，把很多问题都合在一起了</p>
<p>做这道题，首先我们需要了解<strong><code>K-NIM</code>问题</strong>（Blog写过了）</p>
<p>然后我们将每个$a_i$转换成<strong>二进制</strong>后表示成一个<strong>向量</strong></p>
<p>比如：</p>
<script type="math/tex; mode=display">
3+2 \Rightarrow  
\begin{pmatrix} 
1 \\
1
\end{pmatrix}
+
\begin{pmatrix}
1 \\
0
\end{pmatrix}</script><p>我们再用$ 0 \leq x_i \leq 2,x \in \mathbb{N} $表示<strong>选了多少个$ a_i $</strong></p>
<p>那么，我们可以转化为</p>
<p>在$ n $个数中每个选择$x_i$个，使得</p>
<script type="math/tex; mode=display">
x_1 \cdot a_1 + x_2 \cdot a_2 + \cdots + x_n \cdot a_n = 0</script><p>时，<strong>后手必胜</strong></p>
<p>我们发现，这其实是一个$ \forall a_i $的一个<strong>线性相关</strong></p>
<p>若我们需要先手获胜，那么我们就需要使得这个式子<strong>线性无关</strong></p>
<p>并且需要使得所选的数的<strong>攻击力之和最大</strong></p>
<p>这里我们可以使用<strong>线性基</strong>维护</p>
<p>当遇到这一位已经有数时，将<strong>较小</strong>的取出继续<strong>消元</strong>即可</p>
<p>但这里需要使用<strong>位运算优化三进制</strong>（不会，<strong>故咕</strong>。。。）</p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>（感谢<strong>ZR巨佬gaolinxiang</strong>的<strong>无声资瓷</strong>）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i, a, b) for (int i = (a); i &lt;= int(b); i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> per(i, a, b) for (int i = (a); i &gt;= int(b); i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tct template<span class="meta-string">&lt;class type&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> n, b0[<span class="number">60</span>];</span><br><span class="line">ll b1[<span class="number">60</span>], b2[<span class="number">60</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">red</span><span class="params">(<span class="keyword">int</span> &amp;x)</span> </span>&#123; x += x &gt;&gt; <span class="number">31</span> &amp; mod; &#125;</span><br><span class="line"><span class="function">tct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cmax</span><span class="params">(type &amp;x, type y)</span> </span>&#123; x &lt; y ? x = y : <span class="number">0</span>; &#125;</span><br><span class="line"><span class="function">tct <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cmin</span><span class="params">(type &amp;x, type y)</span> </span>&#123; x &gt; y ? x = y : <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ins</span><span class="params">(ll x, ll y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">	per(i, <span class="number">60</span> - <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">if</span> (x &gt;&gt; i &amp; <span class="number">1</span> || y &gt;&gt; i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!b1[i] &amp;&amp; !b2[i]) &#123; b1[i] = x, b2[i] = y, b0[i] = z; <span class="keyword">return</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (z &gt; b0[i]) swap(x, b1[i]), swap(y, b2[i]), swap(z, b0[i]);</span><br><span class="line">		ll p = b1[i], q = b2[i];</span><br><span class="line">		<span class="keyword">if</span> ((y ^ q) &gt;&gt; i &amp; <span class="number">1</span>) swap(p, q);</span><br><span class="line">		ll u = (x &amp; ~(p | q)) | (y &amp; p) | (~(x | y) &amp; q);</span><br><span class="line">		ll v = (y &amp; ~(p | q)) | (~(x | y) &amp; p) | (x &amp; q);</span><br><span class="line">		x = u, y = v;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">	rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">		ll x; <span class="keyword">int</span> y;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>, &amp;x, &amp;y);</span><br><span class="line">		x ^= ans;</span><br><span class="line">		ins(x, <span class="number">0</span>, y);</span><br><span class="line">		ans = <span class="number">0</span>;</span><br><span class="line">		rep(i, <span class="number">0</span>, <span class="number">60</span> - <span class="number">1</span>) ans += b0[i];</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>T20200910赛后总结</title>
    <url>/articles/T20200910%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="T20200910赛后总结"><a href="#T20200910赛后总结" class="headerlink" title="T20200910赛后总结"></a>T20200910赛后总结</h1><h2 id="成绩排行：T20200910成绩"><a href="#成绩排行：T20200910成绩" class="headerlink" title="成绩排行：T20200910成绩"></a>成绩排行：<a href="file:///C:/Users/12298/Desktop/Exam/2020.9.10/result.html">T20200910成绩</a></h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>T1</strong>出的是<strong>“真的好”</strong></p>
<p>T2，T3比较好，<strong>码量不大</strong>，但<strong>思维挺好</strong></p>
<p>总的来说，改完题之后<strong>感觉很好</strong></p>
<h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p><strong>模拟</strong></p>
<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/10/Spfld9eiuEY2ZWw.png" alt="T20200910-A-1.png"></p>
<p><img src="https://i.loli.net/2020/09/10/q4ebU2doxzMfHNW.png" alt="T20200910-A-2.png"></p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><blockquote>
<p>这道题$ 95\% $ 的信息<strong>没用</strong>。。。</p>
</blockquote>
<p>所以我们直接得到最终<strong>王</strong>在<strong>哪个人手中</strong>即可</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e5</span>+<span class="number">5</span>,INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N],s3[N],c[N],level[N];</span><br><span class="line"><span class="keyword">int</span> len1,len2,len3,lenc,lenl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(c&lt;<span class="string">'0'</span>||c&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span>(c==<span class="string">'-'</span>) f=<span class="number">-1</span>;c=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span>(c&gt;=<span class="string">'0'</span>&amp;&amp;c&lt;=<span class="string">'9'</span>) x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=getchar();</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Read_char</span><span class="params">(<span class="keyword">char</span> *Num,<span class="keyword">int</span> &amp;Cnt)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> Ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(Ch==<span class="string">'\n'</span>) Ch=getchar();</span><br><span class="line">	<span class="keyword">while</span>(Ch!=<span class="string">'\n'</span>) Num[Cnt++]=Ch,Ch=getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"joker.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"joker.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="keyword">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> py=<span class="number">0</span>;</span><br><span class="line">		lenl=<span class="number">0</span>; len1=<span class="number">0</span>; len2=<span class="number">0</span>; len3=<span class="number">0</span>; lenc=<span class="number">0</span>;</span><br><span class="line">		Read_char(level,lenl);</span><br><span class="line">		Read_char(s1,len1);		</span><br><span class="line">		Read_char(s2,len2);</span><br><span class="line">    	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len2;i++) </span><br><span class="line">		&#123;</span><br><span class="line">      	 	<span class="keyword">if</span>(s2[i]==<span class="string">'R'</span>&amp;&amp;s2[i+<span class="number">1</span>]==<span class="string">'J'</span>) py++;</span><br><span class="line">      		<span class="keyword">if</span>(s2[i]==<span class="string">'B'</span>&amp;&amp;s2[i+<span class="number">1</span>]==<span class="string">'J'</span>) py++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	Read_char(s3,len3);</span><br><span class="line">    	Read_char(c,lenc);</span><br><span class="line">    	<span class="keyword">if</span>(py==<span class="number">2</span>) </span><br><span class="line">      		<span class="built_in">printf</span>(<span class="string">"laohu\n"</span>);</span><br><span class="line">    	<span class="keyword">else</span> </span><br><span class="line">      		<span class="built_in">printf</span>(<span class="string">"dasuan\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line"><span class="comment">//	system("pause");</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3 </span></span><br><span class="line"><span class="comment">246 </span></span><br><span class="line"><span class="comment">2C 4C 6C 6D 6H 6S </span></span><br><span class="line"><span class="comment">2D 2H RJ 2S 4D BJ </span></span><br><span class="line"><span class="comment">4H 4S </span></span><br><span class="line"><span class="comment">C </span></span><br><span class="line"><span class="comment">23456789TJQKA </span></span><br><span class="line"><span class="comment">TC QD 2S TH 4S 3C </span></span><br><span class="line"><span class="comment">AS RJ AC 7D 6C BJ </span></span><br><span class="line"><span class="comment">3D 4C 8C AD TD TS 7H JS KD 4H QC 6H 9D 7C 9H JC AH 5H 6S QH KS 5S 5D 3H JD JH 8H QS 2H 4D 5C 9S KH 6D 9C 8D 8S KC 7S 3S 2D 2C </span></span><br><span class="line"><span class="comment">S </span></span><br><span class="line"><span class="comment">23456789TJQKA </span></span><br><span class="line"><span class="comment">TC 8S JS JD 5C 9C </span></span><br><span class="line"><span class="comment">QS 8C 3H 4D 4H 2D </span></span><br><span class="line"><span class="comment">QH 7S 7H 3C 2H 7C TD 9H 8D AH 7D QC JH 5D AS 5H 3D JC 2S 6D AC 9D 4C 6S KD 8H 6C 4S RJ KH 3S TS KC KS 5S QD 9S BJ 6H TH AD 2C </span></span><br><span class="line"><span class="comment">D</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><p><strong>分治+归并+快排+构造</strong></p>
<h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/10/vgli2MFLrNx4Rmz.png" alt="T20200910-B.png"></p>
<h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>因为题目意思是求出步数在<strong>345678之内</strong>的方案</p>
<p>所以我们可以尝试<strong>构造</strong></p>
<p>因为操作<strong>可逆</strong></p>
<p>并且将一个序列使用题目所属方法<strong>期望次数</strong>为$ nlogn $次</p>
<p>所以我们可以直接将$S$和$T$排列成<strong>递增序列</strong></p>
<p><strong>一定</strong>可以在限定次数内完成转化</p>
<p>然后将$S$<strong>正序输出方案</strong>，$T$<strong>逆序输出方案</strong></p>
<p>我们考虑找到如图的位置，使得$ Num[R0-Loc+1]&gt;=Num[L1+Loc-1] $</p>
<p><img src="https://i.loli.net/2020/09/10/OTIuh7rotPEyRk8.png" alt="T20200910-4.png"></p>
<p><img src="https://i.loli.net/2020/09/10/G385oCNVjDyLvuE.png" alt="T20200910-1.png"></p>
<p>这样，我们可以使用$ \frac{Len}{2} $ 的次数<strong>翻转区间</strong></p>
<p>将$ [r0-Loc+1,r0] $和$ [l1,l1+Loc-1] $<strong>翻转</strong></p>
<p><img src="https://i.loli.net/2020/09/10/zPtLMqhiB2vgbVm.png" alt="T20200910-2.png"></p>
<p>然后将$ [r0-Loc+1,l1+Loc-1] $<strong>翻转</strong></p>
<p><img src="https://i.loli.net/2020/09/10/r2cSMTAmt7pIjG5.png" alt="T20200910-3.png"></p>
<p>这样之后，我们就将这个区间分为了<strong>两个小区间</strong>，<strong>递归</strong>求解即可</p>
<p><strong>时间复杂度：$ o(nlog^2n) $</strong></p>
<p><strong>期望得分：100分</strong></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//swap</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(int i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(int i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memset((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MaxN=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Total,Num[MaxN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span> <span class="keyword">int</span> Fir,Sec; &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt;Temp[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"swap.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"swap.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> Base,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">	FOR(i,<span class="number">0</span>,(R-L+<span class="number">1</span>)/<span class="number">2</span><span class="number">-1</span>) &#123;</span><br><span class="line">		Temp[Base].push_back(Node&#123; L+i,R-i &#125;);</span><br><span class="line">		swap(Num[L+i],Num[R-i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span> Base,<span class="keyword">int</span> L0,<span class="keyword">int</span> R0,<span class="keyword">int</span> L1,<span class="keyword">int</span> R1)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L0&gt;R0 || L1&gt;R1) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> Len=<span class="built_in">min</span>(R0-L0,R1-L1),Loc=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(Loc&lt;=Len) &#123;</span><br><span class="line">		<span class="keyword">if</span>(Num[R0-Loc]&gt;=Num[L1+Loc]) &#123; Loc++; &#125; </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(!Loc) <span class="keyword">return</span>;</span><br><span class="line">	Update(Base,R0-Loc+<span class="number">1</span>,R0);</span><br><span class="line">	Update(Base,L1,L1+Loc<span class="number">-1</span>);</span><br><span class="line">	Update(Base,R0-Loc+<span class="number">1</span>,L1+Loc<span class="number">-1</span>);</span><br><span class="line">	Merge(Base,L0,R0-Loc,R0-Loc+<span class="number">1</span>,R0);</span><br><span class="line">	Merge(Base,L1,L1+Loc<span class="number">-1</span>,L1+Loc,R1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> Base,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(L&gt;=R) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">	<span class="keyword">int</span> Mid=(L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">	Solve(Base,L,Mid); Solve(Base,Mid+<span class="number">1</span>,R);</span><br><span class="line">	Merge(Base,L,Mid,Mid+<span class="number">1</span>,R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Num[i]);</span><br><span class="line">	Solve(<span class="number">0</span>,<span class="number">1</span>,Total);</span><br><span class="line">	FOR(i,<span class="number">1</span>,Total) <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Num[i]);</span><br><span class="line">	Solve(<span class="number">1</span>,<span class="number">1</span>,Total);</span><br><span class="line">	reverse(Temp[<span class="number">1</span>].<span class="built_in">begin</span>(),Temp[<span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Temp[<span class="number">0</span>].<span class="built_in">size</span>()+Temp[<span class="number">1</span>].<span class="built_in">size</span>());</span><br><span class="line">	FOR(i,<span class="number">0</span>,Temp[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Temp[<span class="number">0</span>][i].Fir,Temp[<span class="number">0</span>][i].Sec);</span><br><span class="line">	FOR(i,<span class="number">0</span>,Temp[<span class="number">1</span>].<span class="built_in">size</span>()<span class="number">-1</span>) <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,Temp[<span class="number">1</span>][i].Fir,Temp[<span class="number">1</span>][i].Sec);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">1 3 5 6 4 2</span></span><br><span class="line"><span class="comment">1 2 3 4 5 6</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h3 id="算法-2"><a href="#算法-2" class="headerlink" title="算法"></a>算法</h3><p><strong>动态规划+组合数学</strong></p>
<h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p><img src="https://i.loli.net/2020/09/10/t4ckBYnfZSLIxu5.png" alt="T20200910-C.png"></p>
<h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>因为我们需要的是求出<strong>没有交叉</strong>的染色的方案数</p>
<p>并且最终的序列一定是由<strong>不多于$2m$个颜色区间</strong>构成的</p>
<p>所以我们可以考虑<strong>DP</strong>，设</p>
<p><strong><code>DP[i][j][k]</code></strong>表示<strong>考虑了$i$个颜色区段，使用了$j$个颜色，还有$k$曾用过的颜色可以在后边必须出现的方案数</strong></p>
<p>所以<code>DP[i+1][j][k]</code>表示<strong>使用曾使用过的颜色</strong></p>
<p>可以由<code>DP[i][j][k=1,2,...,j]</code>转移过来</p>
<p>并且<code>DP[i+1][j+1][k+1]</code>表示在<strong>后边加一个未出现过的颜色</strong></p>
<p>可以由<code>DP[i][j][k]</code>转移过来</p>
<p>每次枚举$i,j$后，需要一个<code>Sum</code>记录<strong>总方案数</strong></p>
<p>并用<strong>隔板法</strong>算出<strong>还原原数列</strong>之后的总方案数</p>
<p><strong><code>Ans+=Sum*C(n-1,i-1)</code></strong></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//actor</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOR(i,A,B) for(LL i=A;i&lt;=B;i++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOR(i,A,B) for(LL i=A;i&gt;=B;i--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Cl(X,Y) memest((X),(Y),sizeof(X))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> LL MaxN=<span class="number">310</span>;</span><br><span class="line"></span><br><span class="line">LL Total,Day,Ans,Temp;</span><br><span class="line">LL DP[MaxN&lt;&lt;<span class="number">1</span>][MaxN][MaxN];</span><br><span class="line">LL Inv[MaxN&lt;&lt;<span class="number">1</span>],C[MaxN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">File</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	freopen(<span class="string">"actor.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">	freopen(<span class="string">"actor.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">File</span>();</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%lld %lld"</span>,&amp;Day,&amp;Total);</span><br><span class="line">	Inv[<span class="number">0</span>]=Inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	C[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	FOR(i,<span class="number">2</span>,(MaxN&lt;&lt;<span class="number">1</span>)<span class="number">-5</span>) &#123;</span><br><span class="line">        Inv[i]=MOD-(MOD/i)*Inv[MOD%i]%MOD;</span><br><span class="line">        C[i]=C[i<span class="number">-1</span>]*Inv[i<span class="number">-1</span>]%MOD*(Day-i+<span class="number">1</span>)%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    DP[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>]=Total;</span><br><span class="line">    FOR(i,<span class="number">1</span>,Total&lt;&lt;<span class="number">1</span>) &#123;</span><br><span class="line">    	FOR(j,<span class="number">1</span>,Total) &#123;</span><br><span class="line">    		Temp=<span class="number">0</span>;</span><br><span class="line">			BOR(k,j,<span class="number">1</span>) &#123;</span><br><span class="line">				(DP[i+<span class="number">1</span>][j][k]+=Temp)%=MOD;</span><br><span class="line">				(DP[i+<span class="number">1</span>][j+<span class="number">1</span>][k+<span class="number">1</span>]+=(Total-j)*DP[i][j][k])%=MOD;</span><br><span class="line">				(Temp+=DP[i][j][k])%=MOD;</span><br><span class="line">			&#125;</span><br><span class="line">			(Ans+=Temp*C[i])%=MOD;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,Ans);</span><br><span class="line">	fclose(<span class="built_in">stdin</span>);</span><br><span class="line">	fclose(<span class="built_in">stdout</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Summary</tag>
      </tags>
  </entry>
  <entry>
    <title>循环矩阵</title>
    <url>/articles/%E5%BE%AA%E7%8E%AF%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="循环矩阵"><a href="#循环矩阵" class="headerlink" title="循环矩阵"></a>循环矩阵</h1><h2 id="表达方式声明"><a href="#表达方式声明" class="headerlink" title="表达方式声明"></a>表达方式声明</h2><ul>
<li>循环矩阵行列使用<strong>0</strong>开始编号。因为<strong>方便取余</strong></li>
<li>我们定义<code>a[i]</code>表示<code>A[0][i]</code></li>
</ul>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>对于$n$阶矩阵$C$，若$ C[i][j]=c[(n-i+j)\%n] $，则称$C$为<strong>循环矩阵</strong></p>
<p>通俗定义：</p>
<script type="math/tex; mode=display">
\left[ \begin{matrix} c[0] & c[1] & c[2] & \cdots & c[n-1] \\ c[n-1] & c[0] & c[1] & \cdots & c[n-2] \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ c[1] & c[2] & c[3] & \cdots & c[n] \end{matrix} \right]</script><p>另外，我们可以知道通常使用的<strong><a href="[https://baike.baidu.com/item/%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5/8540268?fr=aladdin](https://baike.baidu.com/item/单位矩阵/8540268?fr=aladdin">单位矩阵</a>)</strong>是<strong>特殊的循环矩阵</strong></p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>循环矩阵的<strong>线性运算</strong>的乘积仍是<strong>循环矩阵</strong></p>
<h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><ul>
<li><p>在$n$阶循环矩阵$ A,B $中，$ \forall i \in \mathbb{Z}$，有：</p>
<script type="math/tex; mode=display">
\sum^{n-1}_{k=0} a[(x+k) \% n] \times b[(y-k) \% n] \\
\Rightarrow \sum^{n+i-1}_{k=i} a[(x+k) \% n] \times b[(y-k) \% n]</script><p>大伙儿手摸一下或者<strong>感性理解</strong>就欧了！</p>
</li>
</ul>
<p>严格的证明我们需要<strong>完全剩余系</strong>（感觉很有聊）</p>
<ul>
<li><p>若$A,B$是$n$阶循环矩阵，则$ C=A \times B $也是循环矩阵：</p>
<script type="math/tex; mode=display">
C[i][j]= \sum^{n-1}_{k=0} A[i][k] \times B[k][j] \\
\Rightarrow \sum^{n-1}_{k=0} a[(n-i+k) \% n] \times b[(n-k+j) \% n] \\
\Rightarrow \sum^{n+i-1}_{k=i} a[(n-i+k) \% n] \times b[(n-k+j) \% n] \\
\Rightarrow \sum^{n-1}_{k=0} a[(n+k) \% n] \times b[(n-k-i+j) \% n] \\</script><p>我们设$ t=-i+j $，则</p>
<script type="math/tex; mode=display">
C[i][j]= \sum^{n-1}_{k=0} A[0][k] \times B[k][t] = C[0][t]</script><p>我们由<strong>表达方式声明可化简并展开$t$</strong></p>
<script type="math/tex; mode=display">
C[i][j]=c[(n+t) \% n] = c[(n-i+j) \% n]</script><p><strong>综上所述</strong>，我们可由<strong>循环矩阵的定义</strong>可得：</p>
</li>
</ul>
<p>$C=A \times B$为<strong>循环矩阵</strong></p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>满足<strong>乘法交换律</strong>：</p>
<script type="math/tex; mode=display">
A \times B = B \times A</script><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>循环矩阵的<strong><a href="[https://baike.baidu.com/item/%E9%80%86%E7%9F%A9%E9%98%B5](https://baike.baidu.com/item/逆矩阵">逆矩阵</a>)</strong>也是循环矩阵</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我们在使用<strong>矩阵快速幂</strong>时，会发现有些题目给的边长贼大了</p>
<p>比如<a href="https://ac.nowcoder.com/acm/contest/7079/D" target="_blank" rel="noopener">Newcoder 68 D 牛牛的粉丝</a>给的$ n \leq 500 $</p>
<p>总的<strong>时间复杂度</strong>就变为了$ O(n^3 logk) $明显是超过了$1e9$</p>
<p>但仔细观察，发现我们的转移矩阵<code>Base</code>其实是一个<strong>循环矩阵</strong></p>
<p>所以我们可以<strong>忽略一维</strong></p>
<p>直接$ O(n^2 logk) $求出在环上相差$x$的点之间的贡献</p>
<p>最后直接$ O(n^2) $<strong>枚举点与点之间的贡献</strong>求出结果即可</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>线性相关 &amp; 线性无关</title>
    <url>/articles/%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3-%E7%BA%BF%E6%80%A7%E6%97%A0%E5%85%B3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="线性相关-amp-线性无关"><a href="#线性相关-amp-线性无关" class="headerlink" title="线性相关 &amp; 线性无关"></a>线性相关 &amp; 线性无关</h1><h2 id="口胡"><a href="#口胡" class="headerlink" title="口胡"></a>口胡</h2><p>在<strong>线性代数</strong>中，<strong>矢量空间</strong>的<strong>一组元素</strong>中，若<strong>没有矢量可以用有限个其他向量的线性组合表示</strong>的话，则称<strong>线性无关或线性独立</strong>，<strong>反之</strong>称为<strong>线性相关</strong></p>
<hr>
<p>$ e.g: $</p>
<p><strong>三维欧几里得空间</strong>$R$的三个矢量</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
1 \\
0 \\
0
\end{pmatrix}
,
\begin{pmatrix}
0 \\
1 \\
0
\end{pmatrix}
,
\begin{pmatrix}
0 \\
0 \\
1
\end{pmatrix}</script><p><strong>线性无关</strong></p>
<script type="math/tex; mode=display">
\begin{pmatrix}
2 \\
-1 \\
1
\end{pmatrix}
,
\begin{pmatrix}
1 \\
0 \\
1
\end{pmatrix}
,
\begin{pmatrix}
3 \\
-1 \\
2
\end{pmatrix}</script><p><strong>线性相关</strong></p>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在向量空间$R$的一组向量$ A: \alpha_1,\alpha_2, \cdots , \alpha_m $，如果<strong>存在不全为零</strong>的数$ k_1,k_2, \cdots , k_m $使得</p>
<script type="math/tex; mode=display">
k_1 \cdot \alpha_1 + k_2 \cdot \alpha_2 + \cdots + k_m \cdot \alpha_m = 0</script><p>则称<strong>向量组$A$是线性相关</strong></p>
<p>否则若$ \forall i \in [1,m],k_i=0 $</p>
<p>则称<strong>向量组$A$是线性无关</strong></p>
<hr>
<p><strong>求解</strong></p>
<p>即是看$ k_1 \cdot \alpha_1 + k_2 \cdot \alpha_2 + \cdots + k_m \cdot \alpha_m = 0 $这个<strong>齐次线性方程组</strong>是否存在<strong>非零解</strong>，将其<strong>系数矩阵</strong>化为<strong>最简型矩阵</strong>，即可求解</p>
<p>此外，当这个齐次线性方程组的系数矩阵是一个<strong>方阵</strong>时，这个系数矩阵存在<strong>行列式</strong>为<strong>0</strong>，即有<strong>非零解</strong>，从而其<strong>线性相关</strong></p>
<hr>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul>
<li><p>对于<strong>任一向量组</strong>而言，<strong>不是线性无关的就是线性相关</strong>的</p>
</li>
<li><p>向量组只包含<strong>一个</strong>向量$a$时，$ a = \vec{0} $，则说<strong>A线性相关</strong>; $a \neq \vec{0}$, 则说<strong>A线性无关</strong></p>
</li>
<li><p>包含$ \vec{0} $的<strong>任何向量组</strong>是线性相关的</p>
</li>
<li><p>含有<strong>相同向量</strong>的向量组必线性相关</p>
</li>
<li><p><strong>增加</strong>向量的个数，不改变向量的<strong>相关性</strong>【局部相关，整体相关】</p>
</li>
<li><p><strong>减少</strong>向量的个数，不改变向量的<strong>无关性</strong>【整体无关，局部无关】</p>
</li>
<li><p>一个向量组线性无关，则在<strong>相同位置处</strong>都<strong>增加</strong>一个<strong>分量</strong>后得到的新向量组仍<strong>线性无关</strong>【无关组的加长组仍无关】</p>
</li>
<li><p>一个向量组线性相关，则在<strong>相同位置处</strong>都<strong>去掉</strong>一个<strong>分量</strong>后得到的新向量组仍<strong>线性相关</strong>【相关组的缩短组仍相关】</p>
</li>
<li><p>若向量组所包含<strong>向量个数等于分量个数</strong>时，判定向量组是否线性相关即是判定<strong>这些向量为列组成的行列式是否为零</strong>。若行列式为<strong>零</strong>，则向量组<strong>线性相关</strong>；<strong>否则</strong>是<strong>线性无关</strong>的</p>
</li>
</ul>
<h2 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h2><ul>
<li><p>向量$ a_1,a_2, \cdots ,a_m (m \geq 2) $线性相关的<strong>充要条件</strong>是这$n$个向量的一个为其余$ (n-1) $个向量的<strong>线性组合</strong></p>
</li>
<li><p><strong>一个</strong>向量线性相关的<strong>充分条件</strong>是它是一个$ \vec{0} $ </p>
</li>
<li><p><strong>两个</strong>向量$ \vec{a},\vec{b} $<strong>共线</strong>的<strong>充要条件</strong>是$ \vec{a},\vec{b} $线性相关</p>
</li>
<li><p><strong>三个</strong>向量$ \vec{a},\vec{b},\vec{c} $<strong>共面</strong>的<strong>充要条件</strong>是$ \vec{a},\vec{b},\vec{c} $线性相关</p>
</li>
<li><p>$ n+1 $个<strong>$n$维向量</strong>总是线性相关</p>
<p>【个数大于维数比相关】</p>
</li>
</ul>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><strong>[杜洪艳，胡满姑，高萍副．线性代数：机械工业出版社，2015年05月]</strong></p>
<p><strong>[同济大学数学系．工程数学线性代数：高等教育出版社，2014]</strong></p>
]]></content>
      <tags>
        <tag>Basic concept</tag>
      </tags>
  </entry>
  <entry>
    <title>闵可夫斯基和</title>
    <url>/articles/%E9%97%B5%E5%8F%AF%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="闵可夫斯基和"><a href="#闵可夫斯基和" class="headerlink" title="闵可夫斯基和"></a>闵可夫斯基和</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p><strong>闵可夫斯基和</strong>是两个<strong><a href="https://baike.baidu.com/item/欧几里得空间" target="_blank" rel="noopener">欧几里得空间</a></strong>的<strong>点集的和</strong>，也称为这两个空间的<strong>膨胀集</strong>，以德国数学家<a href="https://baike.baidu.com/item/闵可夫斯基" target="_blank" rel="noopener">闵可夫斯基</a>命名。点集A与B的闵可夫斯基和被定义为：</p>
</blockquote>
<script type="math/tex; mode=display">
A+B=C= \lbrace a+b|a \in A,b \in B \rbrace</script><p>比如：</p>
<p>$ \color{orange}{橙色} $表示<strong>闵可夫斯基和</strong></p>
<p>$ \color{red}{红色} $表示$A,B$</p>
<p><img src="https://i.loli.net/2020/08/18/KYsJaiRE4qDhjNk.png" alt="闵可夫斯基和-1.png"></p>
<h2 id="数学应用"><a href="#数学应用" class="headerlink" title="数学应用"></a>数学应用</h2><ul>
<li>证明常宽图形周长的<strong>Barbier定理</strong></li>
<li>证明关于格点图形的<strong>闵可夫斯基定理</strong></li>
<li><strong>数学形态学</strong></li>
<li>图像的<strong>膨胀和腐蚀变换</strong></li>
</ul>
<p>（我摊牌了，好像一个都不会）</p>
<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><p>若集合元素所处的代数系统满足<strong><a href="[https://baike.baidu.com/item/%E9%98%BF%E8%B4%9D%E5%B0%94%E7%BE%A4/6327109](https://baike.baidu.com/item/阿贝尔群/6327109">阿尔贝群</a>)</strong>，则闵可夫斯基和本身也满足<strong>交换律</strong>;</p>
<script type="math/tex; mode=display">
A+B=B+A</script><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="引理1："><a href="#引理1：" class="headerlink" title="引理1："></a>引理1：</h3><ul>
<li><strong>凸包</strong>的闵可夫斯基和也是<strong>凸包</strong></li>
</ul>
<p>由定义，可知对于凸包，就是以一个凸包在另一个凸包的边际上<strong>绕过一圈</strong>的结果</p>
<h3 id="引理2："><a href="#引理2：" class="headerlink" title="引理2："></a>引理2：</h3><ul>
<li>构成$n$个凸包的所有边<strong>合成</strong>一个的一个凸包就是原$n$个凸包的<strong>闵可夫斯基和</strong></li>
</ul>
<p>这个也可以由上边的图用<strong>瞪眼法</strong>看出。。。</p>
<h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>由引理2可知，我们在求出两个（多个）图形$A,B$之后，因为每个凸包的直线都是<strong>有序</strong>的（经过<strong>极角排序</strong>之后），所以可以直接试使用<strong>归并排序</strong>处理出闵可夫斯基和</p>
<h3 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h3><ul>
<li>在形成闵可夫斯基和时，需要将原来的两个凸包的<strong>线段</strong>化为起点在原点的<strong>向量</strong>，方便归并排序（排序完了之后还是<strong>向量</strong>）</li>
<li>在求出闵可夫斯基和包含的所有向量顺序之后，需要找到此凸包的<strong>起点</strong>—即<strong>两个凸包的最左边的点之和</strong>（因为这个点时<strong>唯一确定</strong>的，可以作为向量复原线段的起点）</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>判断两个凸包<strong>是否有相交</strong></li>
</ul>
<p>当两个凸包相交时，满足：</p>
<script type="math/tex; mode=display">
\exist a \in A ,b \in B \Rightarrow a+ \omega = b</script><p>转换一下就是$ \omega = b-a \Rightarrow  \omega =b+(-a) $</p>
<p>所以可以直接<strong>构造</strong>$b$和$-a$的<strong>闵可夫斯基和</strong></p>
<p>然后就是一通<strong>乱搞</strong>就欧了。。。</p>
<ul>
<li>给出三个凸包，每次询问一个点，问能否从三个凸包中各选出一个点并连接成三角形，使得三角形的<strong>重心</strong>在询问点上。</li>
</ul>
<p>考虑重心的<strong>表达式</strong>可知重心在$ ((x_1+x_2+x_3)/3,(y_1+y_2+y_3)/3) $</p>
<p>发现这个表达式显然是一个闵可夫斯基和的形式，因此，可以直接求出<strong>三个凸包的闵可夫斯基和</strong>然后按<strong>同比例缩放</strong>即可</p>
]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
</search>
